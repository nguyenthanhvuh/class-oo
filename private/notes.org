* Notes
:PROPERTIES:
:CUSTOM_ID: notes
:END:
** Week 1
:PROPERTIES:
:CUSTOM_ID: week-1
:END:
- Syllabus
  - No cheating
- Correctness:
  - specification or contract ...
  - code is correct if it satisfies the contract
  - if you give it no contract, well then anything would be correct
  - so we want strong and precise contract

*** Method/Program specifications
:PROPERTIES:
:CUSTOM_ID: methodprogram-specifications
:END:
- Preconditions: assumptions, properties about the inputs
  - established by clients (e.g., inputs are strings, unsorted list,
    ...)
- Postconditions: properties/behaviors of the method/program (usually
  related inputs)
  - done/established by the developers/implementations (e.g., outputs
    are sorted list, ...)
- When something goes wrong, *who to blame*?
  - If preconditions are incorrect: blame the clients
  - If preconditions are correct, and the postconditions are not
    correct: blame developers
- Pre/Post conditions
  - specs/contracts consist of pre and postconditions
    - preconds (or requires)
    - postconds (or effects)
  - Example: __sorting a list_
    - preconds: input is a list of /comparable/ items
    - postcond:
      - output is sorted
      - output is a __permutation_ of data input
  - Precondition
    - as weak or general as possible
  - Postcondition
    - as strong or precise as possible
- In class exercise
  - Equality (=__equals__= in Java or =_eq_= in Python)

** Week 2 More on Specifications
:PROPERTIES:
:CUSTOM_ID: week-2
:END:

*** Weaker Preconditions and Stronger Postconditions
:PROPERTIES:
:CUSTOM_ID: weaker-preconditions-and-stronger-postconditions
:END:
- Reconsider the =intdiv= example from previous class

#+begin_src java
int intdiv(int x, int y){
  /*
  Return the integer division result x/y.
  

  precondition 
  - 
  -
  
  postconditions
  - if x or y are not integers, raise Exception
  - z is a number
  - z is an integer
  - if y is 0, then raise an Exception 
  - z*y ==  x
  */

  if not typeof(x, Int): raise 
  if not typeof(y, Int): raise     
  if (y == 0){ // raise ...
     ...     
  }
  return z
}
#+end_src

#+begin_example
preconds:
- x and y are integers # (already given in type)
// - y cannot be zero   # better if we can remove this

postconds:
- z is a number  # weak
- z is an integer  # weak
- z = x // y  # *strong*
,*/
#+end_example

If we have =S1 = P => Q= and =S2 = P' => Q'=, then - S1 is better than
S2 : if P is weaker than P' - S1 is better than S2 : if Q is stronger
than Q'

*** Partial vs Total Contracts/Specifications
:PROPERTIES:
:CUSTOM_ID: partial-vs-total-contractsspecifications
:END:
- /partial/ specification: has a precondition

- /total/ specification: has NO precondition

- to turn a partial spec into a total spec:

  - for every precondition, remove and turn it into a new behavior in
    postcondition (of the form if not precondition, then do something,
    e.g., raising an excpetion)
    - E.g., if we have a precondition =list= cannot be =null=
    - Then we remove that precondition
    - And create the postcondition: if list is null then raise
      NullPointerExeception

- in the implementation, create conditions and raise exception

*** Check vs Unchecked Exception
:PROPERTIES:
:CUSTOM_ID: check-vs-unchecked-exception
:END:
- precondition (purely specification): if violated can gives undefine
  behavior
- exception (more implementation): turn undefine behavior into defined
  ones
- *checked exception**
  - things that you should explicitly catch or rethrow
  - Block: throw checked exceptions for __recoverable conditions_ and
    /unchecked exceptions/ for programming errors. When in doubt, throw
    unchecked exceptions.

*** Check vs vs Unchecked (Bloch item 70)
:PROPERTIES:
:CUSTOM_ID: check-vs-vs-unchecked-bloch-item-70
:END:
- check exception: recoverable
  - force the caller to handle the exception
  - IOException: file not found, well probably can have a backup ,
    default one
- unchecked exception:
  - recovery not possible
  - NPE: if you pass me a null pointer, and I try to dereference it,
    well then I should get NPE. Not much I can do to turn a null pointer
    into a non-null pointer.

*** Abstraction
:PROPERTIES:
:CUSTOM_ID: abstraction
:END:
- focuses on what (not how)
  - signature: formal parameters, return types, etc
  - isPrime: detemrine if arg is prime is important , how this is
    determine is irrelevant

*** Specifications/Contracts
:PROPERTIES:
:CUSTOM_ID: specificationscontracts
:END:
#+begin_example
int foo(string s, char d): ... 
 // pre: 
 // post
 // modify: s
 ....
 //implementation
  ..
 return 
#+end_example

*** Signatures/Header
:PROPERTIES:
:CUSTOM_ID: signaturesheader
:END:
- requires/modifies/effects in comments
- requires/precond: partial vs total (partial: only for certain input so
  have require/preconditions, total: for all correct type inputs, so
  precondition is TRUE, i.e.Â no precondition/require clause)
- modifies: input modification -> side-effect
- effects/postcond: under assumption that requires are satisfied (x' or
  x_post)
- Precondition: weakest is best, nothing (i.e., True) is even better
- weaker vs stronger

** Implementation
:PROPERTIES:
:CUSTOM_ID: implementation
:END:
- Adhere to specifications
- weaker vs stronger , e.g., if specification says return a number, then
  always return 3 is ok. but if specification says return an odd number,
  then cannot return any number.
- 

IC2a 3. total specs

* pre: Nothing
:PROPERTIES:
:CUSTOM_ID: pre-nothing
:END:
* post:
:PROPERTIES:
:CUSTOM_ID: post
:END:
1. if input list is null/None, throw NullPointException
2. if input list is empty, throw Exception (or return [])
   - don't say anything about IndexError as that requires an Index-based
     datastructure in the implementation
3. return the original list in the same order without first element
4. remove the first element and return the rest: WRONG, X, too
   implemntation specific

* side-effects
:PROPERTIES:
:CUSTOM_ID: side-effects
:END:
- Nothing

4. [@4] 

hasNext() Method: -Preconditions: Nothing explicitly mentioned in the
Iterator interface documentation. It is generally assumed that the
iterator is positioned at a valid element or at the end of the
collection.

- Postconditions:
  - Returns true if there is at least one more element in the
    collection; otherwise, returns false.

next() Method: - Preconditions: There is at least one more element in
the collection. indicating the end of the collection. - Postconditions:
Returns the next element in the collection. The iterator is moved to the
next position.

- Violation Example:
  - Calling next multiple times without calling hasNext to check if
    there are more elements.
  - Calling next when hasNext returns false,

remove() Method: - Preconditions: next() has been called at least once
after the last call to remove. - Violation Example: Calling remove
without first calling next. Postconditions: Removes the last element
returned by next from the underlying collection. - Violation Example:
Calling remove multiple times consecutively without calling next in
between.

** Week 3: Automatic Verification and Hoare Logic
:PROPERTIES:
:CUSTOM_ID: week-3
:END:


*** Quiz 1: Binary Search
- precondition:
  - arrays: sorted, cannot null,
- postcondition:
  - if x not in arrays: raise some exception ...
  - ow: returns index of x in array


- **Prev lectures**: about specifications and contracts
  - Written in English, human language
  - Manual check that implementation and specification are consistent (e.g., run the program, return exception ~X~, see if ~X~ is in the postcondition)
    - **Pros**: easy to do
    - **Cons**: manual, time-consuming, error-prone  (imagine having to do this with real-world programs)
- **Today**: automatic verification
    - You: provide specifications (pre/postconditions)
    - Computer: **automatically** check if implementation is correct wrt to specifications
    - **Pros**: automatic, fast, no human error
    - **Cons**: hard to do, requires some knowledge of logic
    - Formal Methods
    - Industry:  used in many places (e.g., Facebook, Amazon, NASA, Airbus, ...)

- **Hoare logic**: The classicial logic for program verification


*** Logic Primer
:PROPERTIES:
:CUSTOM_ID: logic-primer
:END:

- **Satisfiability**

  - formula ~f~ is **satisfiable** if there is some assignment to the values in ~f~ that makes ~f~ evaluate to ~True~.
  - ~f~ is **unsatisfiabile** is there is no such assignment.
  - Examples
    - x <= 6 or y = 3  is satisfiable  (e.g., x=4, y=3)
    - x > 6  and  y = 3 is SAT (e.g.,  x =7, y=3)
    - x > 6  =>  x > 1   is SAT (e.g.,  x=7)
      - x = -1
      -  False => False: True
      -  True => False: Not possible
    - x > 6 and x < 5  is UNSAT

    - 3-SAT: (x || y | z)  && (!x || y || w )  &&  .....
    - NP-Complete: Nondeterministic polynomial
     - Graph Coloring
     -


 - **valid (tautology)**
    - f is a tautology if f evaluates to True for *every* assignment (f is *always* satisfiable)
    - Examples
      - x > 6  =>  x > 1   is valid
      - x = x  is valid

  - **falsification**
    - f is a *falsification* if f elvalues to False for *every* assignment (f is *always* unsat)
    - Examples
      - x > 6  and  x < 5   is falsification
      - x != x  is falsification
      - x == x + 1 (assuming x is a finite number,  why ?  because if x = some infinite number, then x = x + 1 would True)


- Implication can be tricky (e.g., x > 6  =>  x > 1)
   - a => b   =  !a or b

   - f => f      =  Valid    (!f or f)
   - f => True   =  Valid    (!f or True)
   - True => f   = Not Valid  !True or f  = False or f   =  f
   - f => False   =  Not Valid       !f or False   = !f
   - False => f  =  Valid      !False or f  =  True or f  = True

**** Using Z3 to check satisfiability


*** Hoare Logic
   - Tony Hoare: Sir. Hoare, quick sort, verification, ...
     - medical (surgeries), airplan, weapons, ...
     - Hardware design (CPU)
     - Airbus:  verification to check floating errors do not occur A380 ...
     - NASA:  Rovers  (symbolic execution)
     - Facebook Newsfeed :  verification (currency), Instagram
     - Amazon AWS :  cloud computing

   - automatic verification that a program ~S~ is correct with respect to precondition ~P~ and postcondition ~Q~

**** Hoare tripple: {P}  S  {Q}
     - Precondition: P
     - Postcond :  Q
     - S :  program (a list of statements)
     - Hoare tripple is valid: if P holds, and the successful execution of S results in Q
       - S is correct with respect to P and Q

   - Testing  S,  P , Q

     Goal: given a program S,  {P, Q},  check if S is correct wrt to P, Q
     - testing: finding some bug:  want to find if there is some (bad) input that satisfy P,  but doesn't satisy Q
       - pros: quick , test it on some finite number of inputs (K,M,B ..)
       - cons: if the test shows no bug, DOES NOT mean the program really has no bug

"Testing shows the presence of bugs, not its absence" -- Dijkstra

"Verification shows the absence of bugs, not its existence" ...

     - verification: want to show there exist no bad input that satisfies P but violates Q
       - pros: if verification tool shows no bug, then DOES mean program has no bug
       - cons: runs slowly (have to consider all possible inputs)

def foo(x:int):
  {True}
  y = x
  y += 1;
  {x <= y}
  {x == y - 1}



Examples of Hoare tripples

- {True} x := 5  {x==5}  : Valid HT # strongest post
- {True} x := 5  {x > 4} :  Valid HT
- {True} x := 5  {x==5 or x==6}  : Valid HT
# postcondition:  prefer strongest postcondition
# precondition: prefer weakest precondition



- {True}  x:= 5  {x > 5}  : Invalid HT

- {x = 1 & y = 2} z:= x/y  {z < 1}   : Valid
- {x < y} z:= x/y  {z < 1}   :   Invalid     counterexample :  x=-2, y=-1
- {False} x:=3 {x=8} : Valid
- {True} x:=8 while(1){x:=8} {x=3}  : Valid (*Partial* correct)
  - Partial vs Total (you have to check that the program terminates)

- Halting problem
  - given a program, is it possible to determine if it will halt or not?
  - Alan Turing
    - Break Engima (10 years of WW-II)
    - Father of Computer Science
      - Show that Halting problem is undecidable
      - Turing machine - Universal Machine
      - Turing test
    - Matrix multiplication (LU-)
  - Halting: Undecidable problem

How to determine if Hoare Triple is valid or not?
- Compute *weakest* preconditions (WP)  --- Disjkstra
- WP(S, Q) = P'

- Skip: WP(skip, {x=3})=  {x=3}
- Assignment:
  - WP(x:=x+1, {x=3})= {x=2}
    - {x=2} x:= x+1 {x=3}
  - WP(x:=x+1, {x>3})= x>2
     {x > 2} x:=x+1  {x>3}
     {x >= 3} x:=x+1  {x>3}
     {x >= 100} x:=x+1  {x>3}

  - WP(x:=1, {x=3}) = False
    {False}  x:= 1 {x=3}

- Condition
  - WP(if x > 0 then y := x + 2  else y:= y + 1,  {y > x})
  x>0 => WP(y := x +2, {y > x}) AND !(x>0) =>  WP(y:= y + 1, {y > x})
  x>0 =>  x + 2 > x             AND !(x>0) =>  y+1 > x
  x>0 =>  TRUE
     TRUE                       AND !(x>0) =>  y+1 > x
     !(x>0) =>  y+1 > x

- While loop
  - loop invariant (I)
    - true when entering the loop
#+begin_src python
  while (b){
    # loop body
  }

  while (True){
    [I]      # loop invariant I is right here
    if (!b) break
      # loop body
  }
#+end_src

#+begin_src python
  {N >= 0} # precondition

  i := 0
  while(True):
    [L]
    if(!(i < N)):  # i >= N : break
        break
    i := N;
#+end_src

i = i = True
N= N
i >= 0
i <= N


{False}
x := 3
{x == 4}

wp(x:=3, x==4)
3==4
False


x <= 0 => 0 > 0
x <= 0 => False
x > 0

A => False   = True
*** In-Class
:PROPERTIES:
:CUSTOM_ID: in-class
:END:


b => X  &  !b => Y
(b => X  &  !b => Y)
(!b V X  &  b V Y)



// {N >= 0}  {0 <= N}  =>  {N>=0} Can prove

// {N >= 10} ** cannot prove** {0 <= N} => {N >= 10} Cannot prove


N= -10

i := 0;

{i <= N}
while(true){
  // [I]: loop invariants here
  if(!i < N) break;
  i := N;
}

{i = N} // post condition



i = 0
while (true)
         [I]
         if(!false) break
         i = 10



(N >=0 & i >= N)    =>  i == N
(N >=0 & N <= i)    =>  i == N

(i >= N >= 0)       =>  i == N



```
// {N >= 0}   # P
i = 0;
[L1]
while (i < N){
    [L2]
    i = i + 1;
    [L2']
}
[L3]
//{i == N}  # Q


// {N >= 0}   # P
i = 0;
while (true){
    [L]
    if(!(i < N) break;

    i = i + 1;   //loop body
}
// {i == N}  # Q
```

Candidate loop invariants:
  - i <= N
  - N >= 0


wp({i := 0; while(...)}, i==N)
wp(i:=0, wp(while(...), i==N))

wp(while(...), i==N)  // I = i <= N

1. i <= N

2. i <= N & i < N  => WP(i:=i+1, i<=N)
         i <= N & i < N  => WP(i:=i+1, i<=N)
         i <= N & i < N  => i+1<=N
      i < N        =>  i < N
      True

3. i <= N & !(i < N) => I == N
   i <= N & i >= N    =>  I == N
      i == N          =>  I == N
      True

i <= N  & True  & True
i <= N

wp(i:=0, i<=N)
      0<=N

      Verification Condition (VC)
      P  =>  wp(S, Q)
      P  =>  0 <= N
      N >= 0   =>   0 <= N
      N >= 0   =>   N => 0
      True    # formally proved that {P} S {Q}

----
try with loop invariant N >= 0
wp({i := 0; while(...)}, i==N)
wp(while(...), i==N)  // I = N >= 0

1. N >= 0

2. N >= 0  & i < N  => WP(i:=i+1, N >= 0)
   (N >= 0  & i < N) =>  N >= 0
        True

3. N >=0   & !(i < N)  => i == N
   N >= 0  &  i >= N   =>  i == N
   i >= N >= 0         =>  i == N

   (N >= 0)  &  (i >= N >= 0 => i == N)

   wp(i:=0,  wp(while ...))
   wp(i:=0,  (N >= 0)  &  (i >= N >= 0 => i == N))

   (N >= 0)  &  (0 >= N >= 0    =>  0 == N)
   (N >= 0)  &   N ==0   =>  N == 0
   (N >= 0)  & True
    N >= 0

VC =  N >= 0  =>  N >= 0  = True

---------
try loop invariant i >= 0

1. i >= 0

2. i >= 0  & i < N  => WP(i:=i+1, i >= 0)
   (i >= 0  & i < N)  =>  i + 1 >= 0   //  equiv to True

3. i >= 0   & !(i < N)  => i == N
   (i >= 0   & i>=N)     =>   i == N

i >= 0  & (i >= 0  & i < N)  =>  i + 1 >= 0  &  (i >= 0   & i>=N)     =>   i == N

wp(i := 0, i >= 0  & (i >= 0  & i < N)  =>  i + 1 >= 0  &  (i >= 0   & i>=N)     =>   i == N)


0 >= 0  &
 True

(0 >= 0  & 0 < N)  =>  0 + 1 >= 0  &
  True  &  0 < N   =>   True
  0<N  => True
  !(0 < N) | True
  True

(0 >= 0   & 0>=N)     =>   0 == N
0 >= N  =>  0 == N

wp(..) =  0 >= N  =>  0 == N

VC   N >= 0   =>    (0 >= N  =>  0 == N)
 N >= 0 =>  (0 < N  |  0 == N)

 N >= 0 =>  O <= N

True

VC : True


(0 < N  |  0 == N)   ==   0 <= N



try loop invariant True (weakest invariant)
1.  True
2.  True &  i < N  => WP(i:=i+1, True)
     i< N  =>   True     !(i<N)  | True
     True

3.  True   & !(i < N)  => i == N
    !(i < N)  => i == N
    i >= N  => i == N

wp(i:=0, i >= N  => i == N)

0 >= N  => 0 == N


VC:  (N>=0)  => (0 >= N  => 0 == N)
     (N>=0)  => (0 < N | 0 == N)
     N>=0  => 0 <= N
     True


N >= -10   =>  N >= 0
