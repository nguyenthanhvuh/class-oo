\documentclass[oneside,11pt,dvipsnames]{book}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[margin=1.5in]{geometry}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{soul}
% \usepackage[small,compact]{titlesec} %very powerful
\usepackage[most]{tcolorbox}
% \setsecnumdepth{subsection}
% \setcounter{tocdepth}{3}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{enumitem}
\usepackage{epigraph}
\usepackage{cite}
\usepackage{caption}
\captionsetup{font=small}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{hyperref}
\usepackage{wrapfig}
\setlength\intextsep{0pt} % remove extra space above and below in-line float
\usepackage{hyperref}
\hypersetup{
  colorlinks,
  citecolor=black,
  filecolor=black,
  linkcolor=blue,
  urlcolor=blue,
}
\usepackage{booktabs}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\scriptsize,
  language=python,
  morekeywords={assert},
  keywordstyle=\color{blue},
  commentstyle=\color{magenta},
  numbers=none,
  mathescape,
  stepnumber=1,
  numbersep=8pt,
  tabsize=4,
  showspaces=false,
  showstringspaces=false,
  emph={},
  emphstyle=\color{red}\bfseries
}

\usepackage{tikz}
\usetikzlibrary{calc}
\usepackage{xcolor}

\usepackage{anyfontsize}
\usepackage{sectsty}

\usepackage{etoolbox}

\newtoggle{usesol}
\settoggle{usesol}{false} % not sol version
\newcommand{\sol}[1]{\iftoggle{usesol}{\textbf{Sol:} #1}{}}
\newcommand{\notsol}[1]{\nottoggle{usesol}{#1}{}}
\newcommand{\solite}[2]{\iftoggle{usesol}{#1}{#2}}

\usepackage[makeroom]{cancel}

\newtcolorbox{mybox}{
  enhanced,
  boxrule=0pt,frame hidden,
  borderline west={2pt}{0pt}{green!75!black},
  colback=green!10!white,
  sharp corners
}

\newenvironment{commentbox}[1][]{
  \small
  \begin{mybox}
    {\small \textbf{#1}}
  }{
  \end{mybox}
}

\newtcolorbox{myhistorybox}{
  enhanced,
  boxrule=0pt,frame hidden,
  borderline west={2pt}{0pt}{red!75!black},
  colback=blue!10!white,
  sharp corners
}


\newenvironment{historybox}[1][]{
  \small
  \begin{myhistorybox}
    {\small \textbf{#1}}
  }{
  \end{myhistorybox}
}


\newtcolorbox{mycenterdisplay}{
    colframe=green!50!black, colback=gray!5!white, boxrule=0.5mm, sharp corners
}

\newenvironment{centerdisplay}[1][]{
  \small
  \centering
  \begin{mycenterdisplay}
    {\small \textbf{#1}}
  }{
  \end{mycenterdisplay}
}

\renewcommand{\figurename}{Fig.}
\renewcommand{\tablename}{Tab.}
\def\Section{\S}
\renewcommand{\figureautorefname}{Fig.}
\renewcommand{\tableautorefname}{Tab.}
\makeatletter
\renewcommand{\chapterautorefname}{\S\@gobble}
\renewcommand{\sectionautorefname}{\S\@gobble}
\renewcommand{\subsectionautorefname}{\S\@gobble}
\renewcommand{\appendixautorefname}{\S\@gobble}
\makeatother

\newcommand{\mycomment}[3][\color{blue}]{{#1{{#2}: {#3}}}}
\newcommand{\tvn}[1]{\mycomment{TVN}{#1}}{}
\newcommand{\red}[1]{{\color{red}{#1}}}
\newcommand{\code}[1]{\texttt{#1}}

\begin{document}

%\pagestyle{empty}
\begin{tikzpicture}[overlay,remember picture]

    % Background color
    \fill[
    black!2]
    (current page.south west) rectangle (current page.north east);

    % Rectangles
    \shade[
    left color=Dandelion,
    right color=Dandelion!40,
    transform canvas ={rotate around ={45:($(current page.north west)+(0,-6)$)}}]
    ($(current page.north west)+(0,-6)$) rectangle ++(9,1.5);

    \shade[
    left color=lightgray,
    right color=lightgray!50,
    rounded corners=0.75cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(.5,-10)$)}}]
    ($(current page.north west)+(0.5,-10)$) rectangle ++(15,1.5);

    \shade[
    left color=lightgray,
    rounded corners=0.3cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(.5,-10)$)}}] ($(current page.north west)+(1.5,-9.55)$) rectangle ++(7,.6);

    \shade[
    left color=orange!80,
    right color=orange!60,
    rounded corners=0.4cm,
    transform canvas ={rotate around ={45:($(current page.north)+(-1.5,-3)$)}}]
    ($(current page.north)+(-1.5,-3)$) rectangle ++(9,0.8);

    \shade[
    left color=red!80,
    right color=red!80,
    rounded corners=0.9cm,
    transform canvas ={rotate around ={45:($(current page.north)+(-3,-8)$)}}] ($(current page.north)+(-3,-8)$) rectangle ++(15,1.8);

    \shade[
    left color=orange,
    right color=Dandelion,
    rounded corners=0.9cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(4,-15.5)$)}}]
    ($(current page.north west)+(4,-15.5)$) rectangle ++(30,1.8);

    \shade[
    left color=RoyalBlue,
    right color=Emerald,
    rounded corners=0.75cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(13,-10)$)}}]
    ($(current page.north west)+(13,-10)$) rectangle ++(15,1.5);

    \shade[
    left color=ForestGreen,
    rounded corners=0.3cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(18,-8)$)}}]
    ($(current page.north west)+(18,-8)$) rectangle ++(15,0.6);

    \shade[
    left color=ForestGreen,
    rounded corners=0.4cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(19,-5.65)$)}}]
    ($(current page.north west)+(19,-5.65)$) rectangle ++(15,0.8);

    \shade[
    left color=OrangeRed,
    right color=red!80,
    rounded corners=0.6cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(20,-9)$)}}]
    ($(current page.north west)+(20,-9)$) rectangle ++(14,1.2);



    % Title
    \node[align=center] at ($(current page.center)+(0,-5)$)
    {
    {\fontsize{32}{1} \selectfont {{OOP Design, Specification, and Analysis}}}\\[0.5in]

    {\fontsize{14}{19.2} \selectfont \textcolor{ForestGreen}{ \bf ThanhVu (Vu) Nguyen}}\\[0.1in]
    \today{} (latest version available on  \href{https://nguyenthanhvuh.github.io/class-oo/oop.pdf}{nguyenthanhvuh.github.io/class-oo/oop.pdf})
    };
    \end{tikzpicture}


\chapter*{Preface}



\newpage
\tableofcontents


\chapter{Introduction}\label{sec:intro}

This book will show you the fundamentals of developing high-quality software using a modern \textbf{object-oriented programming} (OOP) approach.  The goal is to develop programs that are reliable, efficient, and easy to understand and maintain.  We will use \emph{Python} for demonstration, but the concepts can be applied to any object-oriented programming language. 


% \section{Decomposition}\label{sec:decomposition}

% As the size of a program increases, it becomes essential to \emph{decompose} the program into smaller, independent programs (or functions or modules). This decomposition process allows for easier management of the program, especially when multiple developers are involved.   This makes the program easier to understand and maintain.




% %\subsection{Decomposition}

% Decomposition is the process of breaking a complex program into smaller, independent, more manageable programs, i.e., ``divide and conquer''. It allows programmer to focus on one part of the problem at a time, without worrying about the rest of the program.

% \paragraph{Example} \autoref{ex:mergesort} shows a Python implementation of \emph{Merge Sort}, a classic example of problem decomposition. It breaks the problem of sorting a list into simpler problems of sorting smaller lists and merging them.

% \begin{figure}[t]
% \begin{lstlisting}[multicols=2]
% def merge_sort(lst):
%     if len(lst) <= 1:
%         return lst

%     mid = len(lst) // 2
%     left = merge_sort(lst[:mid])
%     right = merge_sort(lst[mid:])
%     return merge(left, right)







% def merge(left, right):
%     result = []
%     i = j = 0

%     while i < len(left) and j < len(right):
%         if left[i] < right[j]:
%             result.append(left[i])
%             i += 1
%         else:
%             result.append(right[j])
%             j += 1

%     result.extend(left[i:])
%     result.extend(right[j:])
%     return result
% \end{lstlisting}
%  \caption{Decomposition example: Mergesort}\label{ex:mergesort}
% \end{figure}


A large part of this book focuses on \emph{abstraction}, a key concept in OOP that allows programmers to hide the implementation details and focus on the essential features. By decoupling the \textbf{what} (the  behavior specification) from the \textbf{how} (the actual implementation), programmers could focus on higher-level design and reuse code more effectively.
% In an OOP language such as Python, you can abstract problems by creating functions, classes, and modules that hide the underlying implementation details.

\paragraph{Example} \autoref{ex:mammal} demonstrates an abstraction for different types of mammals. Mammals such as Dog and Cat share common behaviors such as making noise (speak). We can create a class \code{Mammal} that defines these common behaviors, and then subclasses \code{Dog} and \code{Cat} that inherit from \code{Mammal} and define their own unique behaviors.  These are abstract data types that allow us to work with mammals. Also notice the specification (e.g., \code{REQUIRES}) in the comments that describe what the method does, not how it does it.

\begin{figure}[t]
\begin{lstlisting}[multicols=2]
class Mammal:
    def __init__(self, name):
        self.name = name

    def speak(self): pass

class Dog(Mammal):
    def speak(self): 
        """
        EFFECTS: Return the sound of a dog.
        """
        return "Woof!"


class Cat(Mammal):
    def speak(self):
        """
        EFFECTS: Return the sound of a dog.
        """
        return "Meow!"
    

\end{lstlisting}
 \caption{Decomposition example: Mergesort}\label{ex:mammal}
\end{figure}

\chapter{Procedural Abstraction}\label{chap:procedural-abstraction}

\emph{Procedural abstraction} allows developers to create functions (methods) that hide program implementation details. For example, the user can just invoke a \code{sort} function without knowing (or caring) about its underlying sorting algorithm. 
By separating procedure definition and invocation, we make two important methods of abstraction: abstraction by parameterization and abstraction by specification.

\paragraph{Abstraction by Parameterization}

This uses \emph{parameters} to allow the function to be run with different input values, making it more versatile and reusable. \autoref{ex:abs-parameterization} shows an example of abstract parameterization. The \code{cal\_area} function calculates the area of a rectangle given its length and width, which are passed as parameters.

\begin{figure}[h]
    \begin{lstlisting}
    def cal_area(length, width):
        return length * width

    # can be used with different values for length and width.
    area1 = cal_area(5, 10)
    area2 = cal_area(7, 3)
\end{lstlisting}
\caption{Example: Abstract Parameterization}\label{ex:abs-parameterization}
\end{figure}



\paragraph{Abstraction by Specification} This specifies on what the function does (e.g., sorting), instead of how it does it (e.g., using quicksort or mergsort algorithms, implemented in C++). By defining a function's behavior through \emph{specifications}, developers can implement the function in different ways as long as it fulfills the specifications. Similarly, the user can use the function without knowing the implementation details.

\autoref{ex:abs-specification} shows an example of abstraction by specification. The \code{exists} method return true if the \code{target} item is found in a list of sorted \code{items}. The user only needs to provide a sorted list and a target, but does not need to know the underlying algorithm used.

\begin{figure}
\begin{lstlisting}
    def exists(items:List[int], target:int) -> bool:
        """
        Find an item in a list of sorted items.

        Pre: List of sorted items
        Post: True if the target is found, False otherwise.
        """
        ...

    # The user only needs to know that this function checks 
    # for the existence of an item in a sorted list. 
    # They don't need to know the search algorithm or implementation.
\end{lstlisting}
\caption{Abstraction by Specification}\label{ex:abs-specification}
\end{figure}

\section{Specifications}\label{sec:specifications}

We define abstractions through specifications, which describe what the abstraction is intended to do rather than how it should be implemented.  Specifications can be written in either \emph{formal} or \emph{informal languages}. Formal specifications have the advantage of being precise and unambiguous. However, in practice, we often use informal specifications, describing the behavior of the abstraction in plain English (e.g., the \code{sorting} example in \autoref{ex:abs-specification}).  Note that a specification is not a programming language or a program. Thus, our specifications won’t be written in code, e.g., in Python or Java.

\subsection{Specifications of a Function}\label{sec:spec-function}
%3.3 Liskov

The specification of a function consists of a \emph{header} and a \emph{description} of its behavior.
The header gives the signature of the function, including its name, parameters, and return type. The description describes the function's behavior, including its preconditions and postconditions.

\paragraph{Header} The header provides the \emph{name} of the function, the number, order, and types of its \emph{parameters} (inputs), and the type of its return value (output). For instance, the headers for the \code{sort\_items} function in \autoref{ex:abs-specification} and the \code{cal\_area} function in \autoref{ex:abs-parameterization} are as follows

\begin{lstlisting}
def exists(items: list) -> bool: ...
def calc_area(length: float, width: float) -> float: ...
\end{lstlisting}

Note that in a language like Java, the header also indicates \emph{exceptions} that the function may throw.

\paragraph{Preconditions and Postconditions}

A typical function specification in an OOP language such as Python includes: \emph{Preconditions} (also called the ``requires'' clause) and \emph{Postconditions} (also called the ``effects'' clause). Preconditions describe the conditions that must be true before the function is called. These state the constraints or assumptions about the input parameters. If there are no preconditions, the clause is written as \code{None}.

Postconditions, under the assumption that the preconditions are satisfied, describe the conditions that will be true after the function is called. These typically state the expected results or outcomes of the function. Moreover, they often describe the relationship between the inputs and outputs.


The clauses are usually written as \emph{comments} above the function definition, making them easily accessible within the code.


\begin{lstlisting}
def calc_area(length: float, width: float) -> float:
    """
    Calculates the area of a rectangle given its length and width.

    Pre: None
    Post: The area of the rectangle.
    """
    ...
\end{lstlisting}

For example, the specification of the \code{calc\_area} function in \autoref{ex:abs-parameterization} has (i) no preconditions and (ii) the postcondition that the function returns the area of a rectangle given its length and width.  Similarly, the \code{exists} function in \autoref{ex:abs-specification} has the specification that given a list of sorted items (precondition), it returns true if the item is found in the list, and false otherwise (postcondition).  Note how the specification is written in plain English, making it easy to understand for both developers and users of the function.


\paragraph{Modifies} Another common clause in a function specification is \emph{modifies}, which describes the inputs that the function modifies. This is particularly useful for functions that modify their input parameters.

\begin{lstlisting}
def add_to_list(input_list, value):
    """
    Adds a value to the input list.

    Pre: None
    Post: Value is added to the input list.
    Modifies: the input list
    """
    ...
\end{lstlisting}


\subsection{In-class Exercise: User Equality}
This exercise touches on some thorny issues with inheritance. There is a lot going on in this example, but it is a good exercise to understand the subtleties of inheritance. 

\begin{enumerate}
    \item First, look at the \href{https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-}{Javadoc} to understand the behaviors \code{equals()} (while the specification is for Java, the idea is the same in Python).
    \begin{itemize}
        \item Specifically, read carefully the \emph{symmetric}, \emph{reflexive}, and \emph{transitive} properties of \code{equals()}.
        \item Ignore \emph{consistency}, which requires that if two objects are equal, they remain equal.
    \end{itemize}    
    \item For the \code{User} class in \autoref{ex:user}, does \code{equals()} satisfy the three equivalence relation properties? If not, what is the problem?
    \begin{itemize}
        \item Come up with several concrete test cases (e.g., create various \code{User} instances) to check the properties.
        \item If there is a problem, show the test case that demonstrates the problem.
        \item Explain why the problem occurs and come up with a fix.
    \end{itemize}
    \item So the same analysis for the \code{SpecialUser} class in \autoref{ex:specialuser}.
    \end{enumerate}
    
    % 1. Is the given implementation of `equals()` in class `SpecialUser` satisfy the 3 equivalence relation properties? If not, what is the problem? Be concrete: find a specific object (test case!) that demonstrates the problem. How does *inheritance* makes `equals()` in class `SpecialUser` harder to get right?
    

\begin{figure}
\begin{lstlisting}
    class User:
        def __init__(self, name):
            self.name = name

        def __eq__(self, other):
            if not isinstance(other, User):
                return False
            return self.name == other.name
\end{lstlisting}
\caption{User class}\label{ex:user}
\end{figure}


\begin{figure}
\begin{lstlisting}
    class SpecialUser(User):
        """Don't do this until you've done with User"""

        def __init__(self, name, id):
            super().__init__(name)
            self.id = id

        def __eq__(self, other):
            if not isinstance(other, SpecialUser):
                return False
            return super().__eq__(other) and self.id == other.id
\end{lstlisting}
\caption{SpecialUser class}\label{ex:specialuser}
\end{figure}



\section{Designing Specifications}\label{sec:design-specifications}
%Liskov 3.5

When designing specifications, it is important to consider several factors to ensure that the function is well-defined. These factors include the \emph{strength} of the pre- and post-conditions, whether the function is \emph{total} or \emph{partial}, and the \emph{avoiding implementation details} in the specification.

\subsection{Weakest Pre-conditions}\label{sec:weakest-preconditions}
For pre-conditions, we want as weak a constraint as possible to make the function more versatile, allowing it to handle a larger class of inputs.
Logically, a condition $x$ is weaker than another if it is \emph{implied} by the other $y$, i.e.,  $y \implies x$, or that $x$'s constraints are a superset of $y$'s. For example, the condition $x \le 5$ is weaker than $x \le 10$ and the input list is not sorted is weaker than the list is sorted (which is weaker than the list that is both sorted and has no duplicates).
The \emph{weakest} precondition is \emph{True}, which indicates no constraints on the input.


\subsection{Strongest Post-conditions}\label{sec:strongest-postconditions}

In contrast, for post-conditions, we want as strong a condition as possible to ensure that the function behaves as expected. A condition $y$ is stronger than another condition $x$ if $y$ implies $x$, i.e., $y \implies x$, or that $y$'s constraints are a strict subset of $x$'s. For example, the condition $x \le 10$ is stronger than $x \le 5$ or that the input list is sorted is stronger than the list is not sorted.


\subsection{Total vs Partial Functions}\label{sec:total-partial-function}

A function is \emph{total} if it is defined for all legal inputs; otherwise, it is \emph{partial}. Thus a function with no precondition (weakest precondition) is total.  

Total functions are \emph{preferred} because they can be used in more situations, especially when the function is used publicly or in a library where the user may not know the input constraints. Partial functions can be used when the function is used internally, e.g., a helper or auxiliary function and the caller is knowledgeable and can ensure its preconditions are satisfied.

Functions \code{calc\_area} in \autoref{ex:abs-parameterization} and \code{add\_to\_list} in \autoref{ex:abs-specification} are total because they can be called with any input. The \code{exists} function in \autoref{ex:abs-specification} is partial because it only works with sorted lists.


\paragraph{Turning Partial Functions into Total Functions} We can often turn a partial function into a total function in two steps. 
\begin{enumerate}
\item Move preconditions into postconditions and specify the expected behavior when the precondition is not satisfied, e.g., throws an \code{Exception}
\item Modify the function to satisfy the new specification, i.e., handling the cases when the preconditions are not satisfied. 
\end{enumerate}

For example, the \code{exists} function in \autoref{ex:abs-specification} is turned into the total function shown in \autoref{ex:abs-total}.

\begin{figure}
\begin{lstlisting}
def exists(items: List[int], target: int) -> bool:
    """
    Find an item in a list of sorted items.

    Pre: True
    Post: If the input items are not sorted, raise an exception.
          Return True if the item is found, False otherwise.


    """

    if not is_sorted(items):
        raise Exception(...)
\end{lstlisting}
\caption{Total Specification for the program in \autoref{ex:abs-specification}}\label{ex:abs-total}
\end{figure}


\subsection{In-class Exercise: Partial and Total Specifications for \code{tail}}

Consider the following code:

\begin{lstlisting}
def tail(my_list):
     result = my_list.copy()
     result.pop(0)
     return result
\end{lstlisting}

\begin{itemize}
     \item What does the implementation of \code{tail} do in each of the following cases? You might want to see the \href{https://docs.python.org/3/tutorial/datastructures.html}{Python document} for \code{pop}.  How do you know: Running the code or reading Python document?
     \begin{itemize}
         \item \code{list = None}
         \item \code{list = []}
         \item \code{list = [1]}  
         \item \code{list = [1, 2, 3]}
     \end{itemize}
     \item Write a \emph{partial specification} for \code{tail}
     \item Rewrite the specification to be \emph{total}. Use \emph{exceptions} as needed.
    \end{itemize}

\subsection{No implementation details}
The specification should not include any implementation details, such as the algorithm used or the data structures employed. This improves flexibility as it allows the function to be implemented in different ways as long as it satisfies the specification. For example, the \code{exists} function in \autoref{ex:abs-specification} does not specify the search algorithm used to find the item in the list.

Some common examples to avoid include: the mentioning of specific data structures (e.g., arrays, indices), algorithms (e.g., quicksort or mergesort), and exceptions (e.g., related to IndexError). Also avoid specifications mentioning indices because this implies the use of arrays.




%\chapter{Exception}
%Liskov 4 ,  but won't follow this because it talks about checked vs unchecked exceptions, which are not really applicable in Python.
\section{Exercise}

\subsection{Specification for Sorting}
Write the specification for the generic \code{ascending\_sort} method below. The specification should include preconditions and postconditions.
\begin{lstlisting}
    def ascending_sort(my_list):
        # REQUIRES/PRE: 
        # EFFECTS/POST: 
        ...
\end{lstlisting}
    


\subsection{Specification of Binary Search}

Come up with the specification for a \emph{binary search} implementation whose header is given below. Remember for precondition you want something as \emph{weak} as possible and for postcondition as \emph{strong} as possible. Note that binary search returns the \emph{location} (an non-neg integer) of the \code{target} value if found, and returns -1 if \code{target} is not found. 

\begin{lstlisting}
def binary_search(arr: List[int], target: int) -> int:
    """
    PRE/REQUIRES: 
    POST/EFFECTS: 
    """
    ... 
\end{lstlisting}


\subsection{Loan Calculator}\label{ex:loan}    

Consider a function that calculates the number of months needed to pay off a loan of a given size at a fixed \emph{annual} interest rate and a fixed \emph{monthly} payment. For example, a \$100,000 loan at an 8\% annual rate would take 166 months to discharge at a monthly payment of \$1,000, and 141 months to discharge at a monthly payment of \$1,100. (In both cases, the final payment is smaller than the others; we round 165.34 up to 166 and 140.20 up to 141.) Continuing the example, the loan would never be paid off at a monthly payment of \$100, since the principal would grow rather than shrink.

\begin{itemize}


\item Define a function satisfying the following specification:

\begin{lstlisting}
def months(principal: int, rate: float, payment: int) -> int:
    """
    Calculate the number of months required to pay off a loan.
    
    param principal: Amount of the initial principal (in dollars)
    param rate: Annual interest rate (e.g., 0.08 for 8%)
    param payment: Amount of the monthly payment (in dollars)
    
    Requires/Pre: principal, rate, and payment all positive and 
    payment is sufficiently large to drive the principal to zero.
    Effects/Post: return the number of months required to pay off the principal
    """
\end{lstlisting}

\begin{itemize}
    \item The precondition is quite strong, which makes implementing the method easy. The key step in your calculation is to change the principal on each iteration with the following formula (which amounts to monthly compounding):
    \begin{lstlisting}
new_principal = old_principal * (1 + monthly_interest_rate) - payment
    \end{lstlisting}

    \item To make sure you understand the point about preconditions, your code is required to be \emph{minimal}. Specifically, if it is possible to delete parts of your implementation and still have it satisfy the requirements, you'll earn less than full credit.
\end{itemize}
\item \emph{Total} specification: Now change the specification to \emph{total} in which the postcondition handles violations of the preconditions using \emph{exceptions}. In addition, provide a new implementation \code{month} that satisfies the new specification.
\end{itemize}
\subsection{Partial and Total Functions}

\begin{enumerate}
    \item Write the \emph{partial} specifications for the below two functions.
    \item Modify the specifications to make the functions \emph{total}.
    \item Modify the implementations of the two functions to satisfy the total specification.
\end{enumerate}

Recall that specifications do not deal with types (which are taken care by the function signature and enforced by the type system of compiler/interpreter).  In other words, you do not need to worry about types here and can assume conditions about types are satisfied.

\begin{lstlisting}
def divide(a:float, b:float) -> float:
    """
    PRE:
    POST:
    """
    return a / b

def get_average(numbers: list[float]) -> float:
    """
    PRE:
    POST:
    """
    total = sum(numbers)
    return divide(total, len(numbers))
\end{lstlisting}



\sol{For \code{divide}, precond is \code{b} cannot be 0, postcond is the result is the division of \code{a} by \code{b}. For \code{get\_average}, precond is the list cannot be empty (which cause division by 0), postcond is the result is the average of the numbers in the list. To make them total, we throw an exception when the precond is violated.}

\chapter{Data Abstraction}\label{chap:adt}
%Liskov 5

%This chapter focuses on \emph{abstract data type} (ADT), a foundation of OOP and key concept in programming that allows developers to separate how data is implemented from how it behaves. Through ADT, programmers can create new data types relevant to their application. These ADTs consist of objects and associated operations.

In 1974, Barbara Liskov and Stephen N. Zilles introduced Abstract Data Types (\emph{ADTs}) in their influential paper ``Programming with Abstract Data Types'' as part of their work on the CLU programming language at MIT. ADTs changed software design by separating the specification of a data type from its implementation. This allows developers to define operations on a data structure without exposing the detailed implementation of data (e.g., calling \code{pop} to remove data from a \code{Stack} without knowing the internal details on how stack stores data). 

For her pioneering contributions to programming languages and system design, particularly on ADTs and CLU, Barbara Liskov was awarded the Turing Award in 2008. Today, ADTs are a cornerstone of all modern programming languages.

%The CLU language was the first to explicitly support ADTs using a construct called a cluster, which encapsulated both the data structure and the operations that acted on it. CLU also introduced several other innovative features like iterators, exceptions, and parameterized types, many of which influenced modern programming languages such as Java, Python, and C++. Though CLU never became widely used, the principles it introduced, especially ADTs, became foundational in software engineering, leading to more modular and reusable code.



%An ADT has two main components: \emph{parameterization} and \emph{specification}. Parameterization involves using parameters for flexibility, while specification means including operations as part of the data type, which abstracts away the underlying data representation. This ensures that even if the data structure changes, programs that rely on it remain unaffected, as they only interact with the operations rather than the data's internal structure.

%By abstracting data, developers can postpone decisions about data structures until they fully understand how the data will be used, leading to more efficient programs. ADT is also beneficial during program maintenance, as changes to the data structure affect only the type's implementation, not the modules using it.


\section{Specifications of an ADT}

The specification of ADT explains what the operations on the data type do, allowing users to interact with objects only via methods, rather than accessing the internal representation. 
As with functions (\autoref{chap:procedural-abstraction}), the specification for an ADT defines its behaviors without being tied to a specific implementation.


\paragraph{Structure of an ADT} In a modern OOP language such as Python or Java, data abstractions are defined using \emph{classes}. Each class defines a name for the data type, along with its constructors and methods.

\begin{figure}
    \begin{lstlisting}
class DataType:
    """
    Overview: A brief description of the data type and its objects.
    """

    def __init__(self, ...):
        """
        Constructor to initialize a new object.
        """

    def method1(self, ...):
        """
        Method to perform an operation on the object.
        """
    \end{lstlisting}
    \caption{Abstract Data Type template}\label{ex:adt-template}
\end{figure}


\autoref{ex:adt-template} shows an ADT class template in Python. It consists of three main parts. The \emph{Overview} describes the abstract data type in terms of well-understood concepts, like mathematical models or real-world entities. For example, a stack could be described using mathematical sequences.
The Overview can also indicate whether the objects of this type are \emph{mutable} (their state can change) or \emph{immutable}.
The \emph{Constructor} initializes a new object, setting up any initial state required for the instance.
Finally, \emph{methods} define operations users can perform on the objects. These methods allow users to interact with the object without needing to know its internal representation. In Python, \code{self} is used to refer to the object itself, similar to \code{this} in Java or C++.

Note that as with procedural specification (\autoref{chap:procedural-abstraction}), the specifications of constructors and methods of an ADT do not include implementation details. They only describe what the operation does, not how it is done. Moreover, they are written in plain English as code comment.


\subsection{Example: \code{IntSet} ADT}

\autoref{ex:intset} gives the specification for an \code{IntSet} ADT, which represents unbounded set of integers. \code{IntSet} includes a constructor to initialize an empty set, and methods to insert, remove, check membership, get the size, and choose an element from the set. \code{IntSet} is also mutable, as it allows elements to be added or removed. \emph{mutator} \code{insert} and \code{remmove} are mutator methods and have a \code{MODIFIES} clause.  In contrast, \code{is\_in}, \code{size}, and \code{choose} are \emph{observer} methods that do not modify the object.

\begin{figure}
    \begin{lstlisting}
class IntSet:
    """
    Overview: IntSets are unbounded, mutable sets of integers.
    This implementation uses a list to store the elements, ensuring no duplicates.

    """
    def __init__(self):
        """
        Constructor
        EFFECTS: Initializes this to be an empty set.
        """
        self.els = []  # the representation (list)

    def insert(self, x: int) -> None:
        """
        MODIFIES: self
        EFFECTS: Adds x to the elements of this set if not already present.
        """
        if not self.is_in(x): self.els.append(x)
            
    def remove(self, x: int) -> int:
        """
        MODIFIES: self
        EFFECTS: Removes x from this set if it exists. Also returns       
        the index of x in the list.
        """
        i = self.find_idx(x)
        if i != -1:
            # Remove the element at index i
            self.els = self.els[:i] + self.els[i+1:]  
        return i

    def is_in(self, x: int) -> (bool, int):
        """
        EFFECTS: If x is in this set, return True. Otherwise False.
        """
        return True if find_index(x) != -1 else False

    def find_idx(self, x:int)->int:
        """
        EFFECTS: If x is in this set, return its index. Otherwise returns -1.
        """
        for i, element in enumerate(self.els):
            if x == element:
                return i
        return -1

    def size(self) -> int:
        """
        EFFECTS: Returns the number of elements in this set (its cardinality).
        """
        return len(self.els)

    def choose(self) -> int:
        """
        EFFECTS: If this set is empty, raises an Exception. 
        Otherwise, returns an arbitrary element of this set.
        """
        if len(self.els) == 0:
            raise Exception(...)
        return self.els[-1]  # Returns the last element arbitrarily

    def __str__(self) -> str:
        """
        Abstract function (AF) that returns a string representation of this set.
        EFFECTS: Returns a string representation of this set.
        """
        return str(self.els)
\end{lstlisting}
\caption{The IntSet ADT}\label{ex:intset}
\end{figure}

%\subsection{Example: \code{Polynomial} ADT}

\section{Implementing ADT}\label{sec:implementing-adt}

To implement an ADT, we first choose a \emph{representation} (\textbf{rep}) for its objects, then design constructors to initialize it correctly, and methods to interact with and modify the rep. 
For example, we can use a \code{list} (or vector) as the rep of \code{IntSet} in \autoref{ex:intset}. We could use other data structures, such as a \code{set} or \code{dict}, as the rep, but a list is a simple choice for demonstration.


To aid understanding and reasoning of the rep of an ADT, we use two key concepts: \emph{representation invariant} and \emph{abstraction function}.

\subsection{Representation Invariant (Rep-Inv)} Because the rep might not be necessarily related to the ADT itself (e.g., the list has different properties compared to a set), we need to ensure that our use of the rep is consistent with the ADT's behavior. 
To do this, we use \emph{representation invariant} (\textbf{rep-inv}) to specify the constraints for the rep of the ADT to capture its behavior. 

For example, the rep-inv for a stack is that the last element added is the first to be removed and the rep-inv for a binary search tree is that the left child is less than the parent, and the right child is greater. 
The rep-inv for our \code{IntSet} ADT in \autoref{ex:intset} is that all elements in the list are unique. 
\begin{lstlisting}
    # Rep-inv:
    # els is not null, only contains integers and has no duplicates.
\end{lstlisting}

The rep-inv must be preserved by all methods (more precisely, \emph{mutator} methods). It must hold true before and after the method is called. The rep-inv might be violated temporarily during the method execution, but it must be restored before the method returns. For \code{IntSet} Notice that the mutator \code{insert} method ensures that the element is not already in the list before adding it. 

The rep-inv is decided by the designer and specified in the ADT documentation as part of the specification (just like pre/post conditions) so that it is ensured at the end of each method (like the postcondition). Moreover, because rep-inv is so important, it is not only documented in comments but also checked at runtime.  This is done by invoking a \code{repOK}, discussed later, method at the start and end of each method.

\subsection{In-Class Exercise: Checking Rep-Invs}

\begin{lstlisting}
class Members:
    """
    Overview: Members is a mutable record of organization membership.
    AF: Collect the list as a set.
    
    Rep-Inv:
        - rep-inv1: members != None
        - rep-inv2: members != None and no duplicates in members.
        For simplicity, assume None can be a member.
    """

    def __init__(self):
        """Constructor: Initializes the membership list."""
        self.members = []  # The representation

    def join(self, person):
        """
        MODIFIES: self
        EFFECTS: Adds a person to the membership list.
        """
        self.members.append(person)

    def leave(self, person):
        """
        MODIFIES: self
        EFFECTS: Removes a person from the membership list.
        """
        self.members.remove(person)
\end{lstlisting}

\begin{enumerate}
\item Analyze these four questions for \emph{rep-inv 1}.
\begin{itemize}
    \item Does \code{join()} maintain rep-inv?
    \item Does \code{join()} satisfy its specification?
    \item Does \code{leave()} maintain rep-inv?
    \item Does \code{leave()} satisfy its specification?
\end{itemize}
\item Repeat for \emph{rep-inv 2}.
\item Recode \code{join()} to make the verification go through. Which rep-invariant do you use?
\item Recode \code{leave()} to make the verification go through. Which rep-invariant do you use?
\end{enumerate}

\subsection{Abstraction Function (AF)} 

It can be difficult to understand the ADT by looking at the rep directly. For example, we might not be able to visualize or reason about a binary tree or a graph ADT when using list as the rep. To aid understanding, \emph{abstraction function} (\textbf{AF}) provides a mapping between the rep and the ADT. 
Specifically, the AF maps from a \emph{concrete state} (i.e., the \code{els} rep in \autoref{ex:intset}) to an \emph{abstract state} (i.e., the integer set). AF is also a \emph{many-to-one} mapping, as multiple concrete states can map to the same abstract state, e.g., the list \code{[1, 2, 3]} and \code{[3, 2, 1]} both map to the same set \code{\{1, 2, 3\}}. 

Just as with rep-inv, the AF is documented in the class specification. Modern OOP languages often provide methods implementing the AF, in particular developer overrides the \code{\_\_str\_\_} method in Python and \code{toString} in Java to return a string representation of the object. For example, the \code{\_\_str\_\_} method in \autoref{ex:intset} returns a string representation of the set.



\subsection{In-Class Exercise: Stack ADT}

In this exercise, you will implement a \code{Stack} ADT. A stack is a common data structure that follows the Last-In-First-Out (LIFO) principle. You will:
\begin{enumerate}
\item Choose a Representation (rep) for the stack.
\item Define a Representation invariant (rep-inv)
\item Write a \code{repOK} method
\item Provide the specifications of basic stack operations (\code{push}, \code{pop}, \code{is\_empty}) and implement these methods accordingly.
\item Define an Abstraction Function (AF)
\item Implement \code{\_\_str\_\_()} to return a string representation of the stack based on the AF
\end{enumerate}

\section{Mutability vs. Immutability}\label{sec:mutability-vs-immutability}

An ADT can be either mutable or immutable, depending on whether their objects' values can change over time. An ADT should be immutable if the objects it models naturally have unchanging values, such as mathematical objects like integers, polynomials (Polys), or complex numbers. On the other hand, an ADT should be mutable if it models real-world entities that undergo changes, such as an automobile in a simulation, which might be running or stopped, or contain passengers, or if the ADT models data storage, like arrays or sets.

Immutability is beneficial because it offers greater safety and allows sharing of subparts without the risk of unexpected changes. Moreover, immutability can simplify the design by ensuring the object’s state is fixed once created. However, immutable objects can be less efficient, as creating a new object for each change can be costly in terms of memory and time.

\paragraph{Converting from mutable to immutable} 
Given a mutable ADT, it is possible to convert it to an immutable one by ensuring that the rep is not modified by any method. This can be achieved by making the rep private and only allowing read-only access to it. In Python, this can be done by using the \code{@property} decorator to create read-only properties. For example, the \code{els} list in \autoref{ex:intset} can be made read-only by defining a property method \code{elements} that returns a copy of the list.

\begin{lstlisting}
    class IntSet:
        def __init__(self):
            self.__els = []   # Private rep
        @property
        def self.els(self):
            return self.__els
\end{lstlisting}

Moreover, we need to convert mutator methods into observer methods, which make a copy of the rep, modify it, and return the modified rep object.  
\begin{lstlisting}
    def insert_immutable(self, x: int) -> IntSet:
        new_set = self.els.copy()
        if not self.is_in(x):
            new_set = new_set.append(x)
        return new_set
\end{lstlisting}

If the mutator returns a value $v$, then our new method returns a tuple consisting of (i) the new rep object and the return the value $v$. 
\begin{lstlisting}
    def remove_immutable(self, x: int): -> (IntSet, int):
        i = self.find_idx(x)
        new_set = self.els.copy()
        if i != -1:
            # Remove the element at index i
            new_set = self.els[:i] + self.els[i+1:]  
        return (new_set, i)
\end{lstlisting}

If you do not want to return multiple values (e.g., like in Java), then you can create two methods, one for returning the value and the other for returning the new rep object.
For example, a mutator \code{pop} method of a \code{Stack} would result into two methods: \code{pop2} returns the top element and \code{pop3} returns the new stack with the top element removed.

Finally, it is important that while it is possible to convert a mutable ADT to an immutable one as shown, mutability or immutability should be the property of the ADT type itself, not its implementation. Thus, it should be decided at the design stage and documented in the ADT specification.

\subsection{In-class Exercise: Immutable Queue}\label{ic:immutable-queue}

\begin{figure}
    \begin{lstlisting}

class Queue:
    """
    A generic Queue implementation using a list.
    """

    def __init__(self):
        """
        Constructor
        Initializes an empty queue.
        """
        self.elements = []
        self.size = 0

    def enqueue(self, e):
        """
        MODIFIES: self
        EFFECTS: Adds element e to the end of the queue.
        """
        self.elements.append(e)
        self.size += 1

    def dequeue(self):
        """
        MODIFIES: self
        EFFECTS: Removes and returns the element at the front of the queue.
        If the queue is empty, raises an IllegalStateException.
        """
        if self.size == 0:
            raise Exception(...)

        result = self.elements.pop(0)  # Removes and returns the first element
        self.size -= 1
        return result

    def is_empty(self):
        """
        EFFECTS: Returns True if the queue is empty, False otherwise.
        """
        return self.size == 0

    \end{lstlisting}
    \caption{Mutable Queue}\label{ex:mutable-queue}
\end{figure}

Rewrite the mutable \code{Queue} implementation in \autoref{ex:mutable-queue} so that it becomes \emph{immutable}. Keep the \textbf{rep} variables \code{elements} and \code{size}.




% \subsection{Locality and Modifiability}\label{sec:locality-modifiability}

% \emph{Locality} (the ability to reason about an ADT indepepdently of other code) and \emph{modifiability} (the ability to change an implementation without affecting other parts of the code) are two important concepts in writing code. It applies to functions (we want the function to be independent of other functions) and certain to data abstractions. For ADT implementation, this requires that the rep should be modifiable only within the ADT implementation and not outside of the ADT. This is achieved by making the rep \emph{private} and providing methods to access and modify the rep.

% Modifiability goes further than locality. To achieve modifiability, not only must modifications be restricted to the ADT implementation, but all access to the internal representation—-even for reading immutable components--must also be confined to the implementation. If other modules can access the internal representation, then changing the representation may affect those modules, violating modifiability. To ensure modifiability, instance variables must be declared private and cannot be exposed outside the ADT.
% Thus, it is essential that access to the internal representation is restricted to the ADT implementation. %Programming languages like Python allow encapsulation, ensuring that the representation is hidden and protected. If access to the representation is unrestricted, it becomes an additional property that must be proven about the code manually.

\section{Exercise}

\subsection{Polynomial ADT}
\begin{figure}
\begin{lstlisting}
class Poly:
    def __init__(self, c=0, n=0):
        if n < 0:
            raise ValueError("Poly(int, int) constructor: n must be >= 0")
        self.trms = {}
        if c != 0:
            self.trms[n] = c

    def degree(self):
        if len(self.trms) > 0:
            return next(reversed(self.trms.keys()))
        return 0

    def coeff(self, d):
        if d < 0:
            raise ValueError("Poly.coeff: d must be >= 0")
        return self.trms.get(d, 0)

    def sub(self, q):
        if q is None:
            raise ValueError("Poly.sub: q is None")
        return self.add(q.minus())

    def minus(self):
        result = Poly()
        for n, c in self.trms.items():
            result.trms[n] = -c
        return result

    def add(self, q):
        if q is None:
            raise ValueError("Poly.add: q is None")
        
        non_zero = set(self.trms.keys()).union(q.trms.keys())
        result = Poly()
        for n in non_zero:
            new_coeff = self.coeff(n) + q.coeff(n)
            if new_coeff != 0:
                result.trms[n] = new_coeff
        return result

    def mul(self, q):
        if q is None:
            raise ValueError("Poly.mul: q is None")
        
        result = Poly()
        for n1, c1 in self.trms.items():
            for n2, c2 in q.trms.items():
                result = result.add(Poly(c1 * c2, n1 + n2))
        return result

    def __str__(self):
        r = "Poly:"
        if len(self.trms) == 0:
            r += " 0"
        for n, c in self.trms.items():
            if c < 0:
                r += f" - {-c}x^{n}"
            else:
                r += f" + {c}x^{n}"
        return r
\end{lstlisting}
\caption{Polynomial ADT}\label{ex:poly}
\end{figure}


Use the Poly ADT in \autoref{ex:poly} to answer the following questions. Use the \code{Stack} ADT in \autoref{ex:stack} as an example. 

\begin{enumerate}
        \item Part 1
\begin{enumerate}
\item Write an Overview that describes what \code{Poly} does. You must provide some examples to demonstrate (e.g., \code{Poly(2,3)} means what?).
\item Provide the specifications for all methods in the ADT. 
\item Write the \textbf{rep} used in this code.  Describe how this rep represents \code{Poly}.
\item Provide the \textbf{rep-inv} for the ADT. Note, this would be the constraints over the rep variable(s).
\item Write a \code{repOK} method that checks the rep-inv.
\item Describe the AF in this code. Use \code{\_\_str\_\_} to help.
\end{enumerate}

        \item Part 2
\begin{enumerate}
        \item Introduce a fault (i.e. "bug") that breaks the \textbf{rep-inv}. Try to do this with a small (conceptual) change to the code. Show that the rep-invariant is broken with a concrete test case.
        \item Analyzed your bug with respect to the method specifications of \code{Poly}. Are all/some/none of the specification violated?
        \item Do you think your fault is realistic? Why or why not?
\end{enumerate}
        
\end{enumerate}


\subsection{Immutability 1}\label{sec:immutability1}

The below class \code{Immutable} is supposed to be immutable. However, it is not. Identify the issues and fix them.  

\begin{enumerate}
\item Which of the lines (A--F) has a problem with immutability? Explain why by showing code example, i.e., show code involving problematic lines; show how that breaks immutability.

\sol{Only line F is problematic. It returns a reference to the internal list, which can be modified. Note that line C has no issue because it creates a copy of the list. If there was no copy, then this would cause a problem as \code{mlist} could be modified outside the class and affects \code{\_mlist}.}

\item For each line that has a problem.  Write code to fix it so that the class is immutable.

\sol{To fix line F, simply return copy, i.e., return self.\_mlist.copy().}
\end{enumerate}

Notes:
\begin{enumerate}
\item Python or Java, immutable types include \code{int}, \code{float}, \code{str}, \code{tuple}. and mutable types include \code{list} and \code{dict}. 
\item In Python, you can use \code{copy} method to create a copy of a list and \code{deepcopy} for more complicated data structures like \code{dict}.
\end{enumerate}    

\begin{lstlisting}
class Immutable:
    def __init__(self, mstr: str, mint: int, mlist: list[str]):
        self._mstr = mstr                       # Line A
        self._mint = mint                       # Line B
        self._mlist = mlist.copy()              # Line C

    
    def get_mstr(self) -> str: return self._mstr        # Line D
    def get_mint(self) -> int: return self._mint        # Line E
    def get_mlist(self) -> list[str]: return self._mlist # Line F
\end{lstlisting}


\subsection{Immutability 2}\label{sec:immutability2}
Do the same with the previous exercise (\autoref{sec:immutability1}) but now with the below class \code{Immutable2}.
\begin{lstlisting}
class Immutable2:
    def __init__(self, username: str, user_id: int, data1: list[str], data2: dict):
        self._username = username  # Line A
        self._user_id = user_id    # Line B
        self._data1 = data1        # Line C
        self._data2 = data2        # Line D
        
    def get_username(self) -> str: return self._username
    def get_user_id(self) -> int: return self._user_id
    def get_data1(self) -> list[str]: return self._data1  # Line E
    def get_data2(self) -> dict:  return self._data2      # Line F
\end{lstlisting}

% \chapter{Iterators and Generators}

% This chapter introduces the concept of \emph{iteration abstraction} through \emph{iterators}, which are a generalization of iteration mechanisms found in most programming languages. Iterators allow users to traverse arbitrary types of data efficiently and without the need for additional structures, such as arrays or list, that can consume extra memory or modify the collection being iterated over.


% \section{Iterators}

% \emph{Iterators} provide general-purpose iteration mechanism that is both efficient and preserves abstraction. An iterator is a special kind of object that allows us to access elements one at a time, without creating large intermediate structures or modifying the original collection, and can stop early if a certain condition is met (e.g., find a specific item). Thus, iterations avoid the space and time inefficiencies of other methods.

% Each iteration produces a new item that can then be used within the loop. Like with procedural and data abstraction, a key advantage of iterators is the separation of concerns: the iterator handles the production of items, while the code containing the loop handles the actions performed on those items. The iterator can be reused in different contexts without modification.

% \begin{figure}
% \begin{lstlisting}
% class IntSet:
%     def __init__(self):
%         self._elements = set()

%     def add(self, element):
%         self._elements.add(element)

%     def __iter__(self):
%         # Returns an iterator over the set
%         return iter(self._elements)

% # Now, we can efficiently compute the sum:
% def set_sum(s: IntSet) -> int:
%     return sum(s)

% \end{lstlisting}
% \caption{IntSet with Iterator}\label{ex:intset-iter}
% \end{figure}

% To motivate the needs for iteration, suppose that we want to compute the sum of an \code{IntSet} collection defined in \autoref{ex:intset}. To compute the sum, we need to iterate through each element in the set. One way to do this is to convert the set to a list and then iterate over the list. However, this approach is inefficient because it requires creating a new list, which consumes memory and time. Another approach is modifying \code{IntSet} to return its rep as a list so we can iterate over it. However, this approach violates the abstraction principle, as it exposes the internal representation of the set.

% Iterators provide a better solution by allowing us to iterate over the set without exposing its internal representation.
% The \code{IntSet} in \autoref{ex:intset-iter} defines an \code{\_\_iter\_\_} method, which returns an iterator over its elements. This allows us to directly iterate over \code{IntSet} instances using a \code{for} loop or other iteration constructs. For example, the \code{sum} function in \autoref{ex:intset-iter} computes the sum of the elements in the set without exposing the internal representation of the set.


% \section{Iterators and Generators}

% A modern OOP language such as Python provides support for iteration abstraction through its built-in iterator and generator mechanisms. In Python, an iterator returns a special kind of object called a \emph{generator}, which keeps track of the state of the iteration and produces elements one at a time. A Python generator is created using the \code{yield} keyword, and provides the \code{next} and \code{hasNext} methods to advance the iteration and check for the end of the sequence.

\chapter{Types}

In 1999, NASA's Mars Climate Orbiter mission ended in failure due to a simple yet catastrophic software error. The spacecraft, which cost \$125 million to build and launch, was launched on December 11, 1998 to study Mars. After a 9-month journey, the spacecraft approached Mars on September 23, 1999, and was supposed to enter a stable orbit around Mars at an altitude of about 226 kilometers (140 miles) above the planet’s surface. However, the spacecraft instead plunged much deeper into the Martian atmosphere, to an estimated altitude of 57 kilometers (35 miles), causing it to either burn up or crash on the surface and resulting in a complete loss of the mission.

The cause of the failure was a software error involving typing mismatch between imperial units (pounds-force) and metric units (newtons) in the software that controlled the spacecraft's thrusters. The software expected data in metric units, but the thruster data was provided in imperial units, leading to the incorrect trajectory calculations. This mismatch was not caught during testing. This failure not only cost NASA a significant financial investment but also set back the Mars exploration program. 


\section{Type Systems in OOP}

In OOP, the type system forms the foundation for defining how ADT (\autoref{chap:adt}) is represented and manipulated in a language. Type systems provide rules for assigning types to variables, expressions, functions, and objects, enabling the development of reliable and efficient software. A well-defined type system also enforces contracts between components, ensuring that data is used appropriately.

This chapter covers key concepts in the type system of OOP languages, particularly in the context of Python, where both static and dynamic typing coexist. We will explore topics like polymorphism, inheritance, dynamic dispatching, and more, discussing their motivation, core concepts. 



% We can enhance ADT (\autoref{chap:adt}) by defining families of related ADTs, where all members share similar behavior through common methods. These type families are structured in a hierarchy, with a base class (\emph{supertype}) defining the core behavior, and subclasses (\emph{subtypes}) extending or adding to this behavior. For example, Cars and Buses as subtypes of Vehicle, or program-specific hierarchies like a bufedReader as a subtype of Reader. 


% A key concept in typing is that the \emph{Liskov's principle of substitution}, which ensures that any subtype object can be substituted for a supertype object without breaking the program. This principle allows code written for the supertype (e.g., Reader) to work seamlessly with any subtype (e.g., bufedReader), enabling abstraction by focusing on commonalities while still supporting specific behaviors at different levels of the hierarchy.

\section{Polymorphism}

Polymorphism is a cornerstone of OOP that allows objects of different types to be treated as objects of a common supertype. This facilitates flexibility in programming by enabling the use of a unified interface for different types of objects, reducing redundancy and increasing code reuse.

\autoref{ex:polymorphism} shows an example of subtype polymorphism, where a \code{Mammal} class has two subclasses, \code{Dog} and \code{Cat}, each implementing the \code{speak} method differently. The \code{make\_mammal\_speak} function can then be used to make any mammal speak, regardless of its specific type.

\begin{figure}
\begin{lstlisting}

from abc import ABC, abstractmethod

class Mammal(ABC):
    """
    Abstract class
    """
    
    @abstractmethod
    def speak(self):
        raise NotImplementedError("Subclasses should implement this!")

class Dog(Mammal):
    def speak(self):
        return "Woof!"

    def bark(self):
        return "Bark!"

class Cat(Mammal):
    def speak(self): return "Meow!"
        
# Using polymorphism
def make_animal_speak(mammal: Mammal): return mammal.speak()

mammals = [Dog(), Cat()]
for m in mammals:
    print(make_animal_speak(m))
\end{lstlisting}
\caption{Polymorphism}\label{ex:polymorphism}
\end{figure}

\section{Inheritance}

Inheritance creates a hierarchical relationship between classes and allows a class to be a \emph{subclass} or \emph{subtype} of one other class (its \emph{superclass} or \emph{supertype}).
\autoref{ex:polymorphism} shows an example of inheritance.
\code{Mammal} is the superclass of \code{Dog} and \code{Cat}.
\code{Dog} and \code{Cat} are the subclasses of \code{Mammal}
They override \code{speak} to provide a specific implementation.
In addition to \emph{overriding} the \code{speak} method in \code{Mammal}, \code{Dog} defines a new method \code{bark} that is specific to dogs.


This is an example of single inheritance, where a subclass can inherit from only one superclass. Python also supports multiple inheritance, where a subclass can inherit from multiple superclasses. For example, an \code{HybridVehicle} class could inherit from both \code{Car} and \code{BatteryVehicle} classes. However, multiple inheritance can lead to complex hierarchies and potential conflicts, so it should be used judiciously.

\section{Abstract Class}
OOP has two types of classes: \emph{concrete} and \emph{abstract} classes. Concrete classes provide a full implementation of the type while abstract classes provide at most a partial implementation of the type. Abstract classes cannot be instantiated (no objects) since some of their methods are not yet implemented (abstract methods). Abstract classes can have both abstract (to be implemented by subclasses) and concrete methods (already implemented or partially implemented). 

In Python abstract classes are defined using the \code{abc} module, which provides the \code{ABC} class and the \code{abstractmethod} decorator. The \code{ABC} class is used as a base class for abstract classes, and the \code{abstractmethod} decorator is used to mark methods as abstract. In \autoref{ex:polymorphism},
\code{Mammal} is an abstract class and contains an abstract method \code{speak} that its subclasses must implement.
In Java, abstract classes and methods are defined using the \code{abstract} keyword, e.g., \code{public abstract class Mammal} and \code{public abstract void speak();}.

\section{Interface}

Interface is a special type of abstract classes that contains only abstract methods (no concrete methods). They define a specification that classes must adhere to, providing the methods that must be implemented by any class that implements the interface. Multiple classes can implement the same interface, allowing for polymorphism and flexibility in the design.

In Python, interfaces are not explicitly defined, but the concept can be implemented using abstract classes with only abstract methods. For example, the abstract class \code{Mammal} in \autoref{ex:polymorphism} acts as an interface that specifies the \code{speak} method that all mammals must implement.
In Java, interfaces are explicitly defined using the \code{interface} keyword, e.g., \code{interface Mammal}, and methods are declared without a body, e.g., \code{public void speak();}. A class can implement multiple interfaces, allowing for more flexibility in defining contracts between classes.


\paragraph{Comparable interface} A good example of an interface is \code{Comparable}, which defines a single method \code{compare\_to} that allows objects to be compared to each other. Any class that implements \code{Comparable} can be compared to other objects of the same type, enabling sorting and other operations that require comparison.

The code below demonstrates the use of the \code{Comparable} interface in Python. The \code{Number} class implements the \code{Comparable} interface by defining the \code{compare\_to} method, which compares two \code{Number} objects based on their values. The \code{sort} function uses the \code{compare\_to} method to sort a list of \code{Number} objects.

\begin{lstlisting}
    from abc import ABC, abstractmethod
from typing import List

# Define a Comparable interface using ABC
class Comparable(ABC):
    @abstractmethod
    def compare_to(self, other: "Comparable") -> int:
        """Compares this object with another."""
        pass

# Implement Comparable in a concrete class
class Number(Comparable):
    def __init__(self, value: int):
        self.value = value

    def compare_to(self, other: "Number") -> int:
        if self.value < other.value:
            return -1
        elif self.value > other.value:
            return 1
        else:
            return 0

# Polymorphic sorting function that relies on the compare_to method
def sort(items: List[Comparable]) -> List[Comparable]:
    return sorted(items, key=lambda x: x.value)

# Usage
numbers = [Number(3), Number(1), Number(4), Number(2)]
sorted_numbers = sort(numbers)
print(sorted_numbers)  # Output: [1, 2, 3, 4]
\end{lstlisting}    

\subsection{Element Subtype vs Related Subtype} There are two types of subtypes: \emph{element subtype} and \emph{related subtype}. Element subtype relies on a common interface or abstract class, e.g., \code{Number} is an element subtype of \code{Comparable}. While this common approach allows for polymorphism, it requires all potential types must be pre-planned to fit the hierarchy. 

On the other hand, a related subtype does not directly rely on a common interface or abstract class (which might be designed much later). Instead, this approach creates a related subtype that implement the desired interface and then adapts it to the existing hierarchy. The code below demonstrates the use of a related subtype, where \code{Price} is adapted to \code{PriceComparable}, which implements \code{Comparable}, to allow sorting of \code{Price} objects.

\begin{lstlisting}
class Price:
    def __init__(self, amount: float):
        self.amount = amount


class PriceComparable(Comparable):
    def __init__(self, price: Price):
        self.price = price
    def compare_to(self, other: "PriceComparable") -> int:
        if self.price.amount < other.price.amount:
            return -1
        elif self.price.amount > other.price.amount:
            return 1
        else:
            return 0

# sorting using related subtype            
prices = [Price(3.0), Price(1.0), Price(4.0), Price(2.0)]
price_comparators = [PriceComparable(p) for p in prices]
sorted_prices = sort(price_comparators)
\end{lstlisting}

\section{Dynamic Dispatching}

Dynamic dispatching refers to how a program selects which method to invoke when a method is called on an object.  It allows the correct method to be invoked based on the \emph{runtime type} of the object, even if the reference to the object is of a more general (superclass) type. This is particularly useful when working with inheritance and polymorphism, where subclasses override methods from a superclass.
The distinction between dynamic dispatching and static dispatching lies in when the decision about which method to invoke is made—either at runtime (dynamic) or compile-time (static).

In \autoref{ex:polymorphism} the \code{make\_mammal\_speak} method will invoke the \code{speak} method of the correct subclass based on the runtime type of the object. This is dynamic dispatching in action, where the method \code{speak} to be called is determined at runtime based on the actual type of the object.  However, if we explicitly create a \code{Dog} instance and call \code{speak} on it, the method is statically dispatched, as the compiler knows the type of the object at compile-time and can directly call the correct method.

The code below demonstrates the difference between static and dynamic dispatching. The \code{Dog} object \code{d} is statically dispatched, while the \code{Mammal} object \code{m} is dynamically dispatched.
\begin{lstlisting}
    Dog d = Dog();
    d.speak();  # Static dispatching

    Mammal m = Dog();
    m.speak();  # Dynamic dispatching
\end{lstlisting}    

\section{Liskov Substitution Principle (LSP)}
The Liskov Substitution Principle (LSP) is a fundamental concept of object-oriented design, which ensures that objects of a subclass should be able to replace objects of the superclass without altering the correctness of the program. LSP promotes proper design and enforces correct use of inheritance.
Violating LSP can lead to unexpected behavior and errors in the program, as the assumptions made about the superclass may no longer hold for the subclass. 

The main idea of LSP is that a subclass \emph{is-a} superclass and can do everything the superclass can do, and can also do more. For example, a \code{Dog} is a \code{Mammal} and can speak like any mammal, but it can also bark, which is specific to dogs.
This enables substitution of objects of the subclass for objects of the superclass, allowing for polymorphism and dynamic dispatching to work correctly. The \code{make\_animal\_speak} function in \autoref{ex:polymorphism} demonstrates LSP by accepting any \code{Mammal} object and making it speak, regardless of its specific type.


\subsection{Rules} 
If \code{S} is a subtype of \code{T}, then objects of type \code{T} may be replaced with objects of type \code{S} without altering any of the desirable properties of the program. This means whenever you use \code{T}, you can use \code{S} instead. To achieve this, we must follow the following rules:
\begin{itemize}
\item[\textbf{Signature Rule}] The signatures of methods of \code{S} must strengthen methods of \code{T}. In other words, the methods of \code{S} are a superset of the methods of \code{T}. Thus, if \code{T} has \code{n} methods, \code{S} also has \code{n} methods and additional ones (methods specific to \code{S}). 

\item[\textbf{Method Rule}] The specification of \code{f'} strengthens that of \code{f}. This means that the preconditions of \code{f'} must be weaker or equal to the preconditions of \code{f}, i.e.,  \code{f'} accepts more inputs than \code{f}.  The postconditions of \code{f} must be stronger or equal to that of \code{f}. This means that \code{f'} is more precise and specific than \code{f}.

\item[\textbf{Property Rule}] The subtype must preserve all properties of the supertype.  For example, the rep-invariant of the subtpe \code{S} must be stronger or equal to that of the supertype \code{T}. This means \code{S} should maintain or strengthen the properties (including rep invariants) of \code{T}
\end{itemize}

\subsection{In-Class Exercise: Bank Account}

%\autoref{ex:bankaccount}

\begin{figure}
    \begin{lstlisting}
class BankAccount:
    def __init__(self, balance: float):
        self._balance = balance if balance >= 0 else 0  
        
    def repOK(self):
        return self._balance >= 0

    def deposit(self, amount: float) -> bool:
        """
        REQUIRES: amount must be positive
        EFFECTS: balance is the original balance plus deposited amount
        """
        if amount <= 0:
            return False
        self._balance += amount
        # check_repOK()
        return True

    def withdraw(self, amount: float) -> bool:
        # REQUIRES: amount must be positive and less than or equal to balance
        # EFFECTS: balance is the original balance minus withdrawn amount

        if amount <= 0 or amount > self._balance:
            return False
        self._balance -= amount
        self.check_repOK()
        # check_repOK()
        return True

class BonusBankAccount(BankAccount):
    def __init__(self, balance: float, bonus_interest: float):
        super().__init__(balance)
        self._bonus_interest = bonus_interest

    def deposit(self, amount: float) -> str:
        # REQUIRES: (same) amount must be positive
        # EFFECTS: (stronger) deposit and also add bonus interest

        stats = super().deposit(amount)
        if stats:
            # deposit successful, add interest
            self._balance += self._bonus_interest * amount
        
        # check_repOK()
        return stats


    def withdraw(self, amount: float) -> bool:
        """
        REQUIRES: (weaker) allow zero withdrawals, which are ignored
        EFFECTS: (same) balance is the original balance minus withdrawn amount
        """
        if amount == 0:
            return True  # Zero withdrawal is considered a no-op
        ret =  super().withdraw(amount)
        # check_repOK()
        return ret
    
    
    def repOK(self):
        """
        Stronger Rep-inv: balance and bonus interest must be non-negative
        """
        return super().repOK() and self._bonus_interest >= 0
        
    \end{lstlisting}
\caption{Liskov Substitution Principle demonstration}\label{ex:bankaccount}
\end{figure}

\section{Encapsulation}
Encapsulation is a fundamental concept in OOP that combines data and methods into a single unit called a class. Encapsulation allows the class to control access to its data and methods, ensuring that they are used correctly and consistently. This helps to prevent misuse and errors, and promotes good design practices such as information hiding and modularity.

Encapsulation is achieved through the use of access modifiers, which specify the level of access to class members. In Java, access modifiers are enforced by the language, and there are four levels of access: \emph{private}, \emph{protected}, \emph{package-private} (default), and \emph{public}.  In Python, access modifiers are not enforced by the language, but conventions are used to indicate the intended level of access. For example, underscore (\_) is used to indicate private or protected attribute (variable). %, and a double underscore (\_\_) is used to indicate a private attribute. 

Encapsulation avoids direct access to the internal representation of a class, e.g., rep-invariants, which can lead to unintended side effects and break the class's invariants. Instead, access to the class's data should be controlled through methods, such as \code{getters} and \code{setters} methods.

In the \code{BankAccount} class in \autoref{ex:bankaccount}, the \code{\_balance} attribute is a private member, and access to it is controlled through the \code{deposit} and \code{withdraw} methods. This ensures that the balance is updated correctly and that the rep-invariant is maintained (\code{repOK}). The \code{BonusBankAccount} class extends \code{BankAccount} and adds a \code{\_bonus\_interest} attribute, which is also a private member that is not exposed directly. 



\subsection{In-class: Polymorphism concepts: Vehicle}

You will design a system that models different types of vehicles (e.g., cars, bicycles). Each vehicle has the ability to start, stop, and display its details. Vehicles should differ in their implementation of these behaviors. You will use abstract classes and interfaces to define the basic structure and ensure that your system adheres to OOP principles.

\begin{enumerate}
    \item Create an abstract class \code{Vehicle} that has
    \begin{enumerate}
        \item An encapsulated attribute for \code{speed}.
        \item Abstract methods: \code{start()}, \code{stop()}, and \code{display()}.
    \end{enumerate}
    \item Define an interface called \code{Refuelable}, with a method \code{refuel(amount:int)}
    \item Create concrete subclasses
    \begin{enumerate}
	    \item Create \code{Car} and \code{Bicycle} classes that inherit from \code{Vehicle}.
	    \item Car also implements the \code{Refuelable} interface (because it uses fuel).
	    \item Implement methods to \code{start}, \code{stop}, \code{display}, and \code{refuel} if applicable.
	    \item Ensure each class encapsulates its specific properties (e.g., \code{fuel\_level} for cars).
    \end{enumerate}
    \item Demonstrate Polymorphism and other OOP principles
    \begin{enumerate}
        \item Create a function \code{operate\_vehicle(vehicle:Vehicle)} that accepts any vehicle type and calls its \code{start}, \code{stop}, and \code{display} methods. This function demonstrates polymorphism and dynamic dispatching.
        \item Create test cases to demonstrate LSP by substituting instances of \code{Car} and \code{Bicycle} for \code{Vehicle} in the \code{operate\_vehicle} function. 
        \item Protect rep data and other attributes and access them through setters and getters methods.
    \item Provide proper document and specifications for your code (e.g., class Overview, rep-invs, method specifications, AF, \code{repOK}).
    \end{enumerate}

\end{enumerate}

\section{Exercise}

\subsection{LSP: Market subtype}

Determine whether the below \code{LowBidMarket} and \code{LowOfferMarket} classes are proper subtypes of \code{Market}. Specifically, for each method, list whether the precondition is weaker, the postcondition is stronger, and conclude whether LSP holds.

Note that this is purely a ``paper and pencil'' exercise. No code is required. Write your answer so that it is easily understandable by someone with only a passing knowledge of LSP.


\begin{lstlisting}
class Market:
    def __init__(self):
        self.wanted = set()  # items for which prices are of interest
        self.offers = {}     # offers to sell items at specific prices

    def offer(self, item, price):
        """
        Requires: item is an element of wanted.
        Effects: Adds (item, price) to offers.
        """
        if item in self.wanted:
            if item not in self.offers:
                self.offers[item] = []
            self.offers[item].append(price)

    def buy(self, item):
        """
        Requires: item is an element of the domain of offers.
        Effects: Chooses and removes some (arbitrary) pair (item, price) from
                    offers and returns the chosen price.
        """
        if item in self.offers and self.offers[item]:
            return self.offers[item].pop(0)  # Removes and returns the first price
        return None

class LowBidMarket(Market):
    def offer(self, item, price):
        """
        Requires: item is an element of wanted.
        Effects: If (item, price) is not cheaper than any existing pair
                    (item, existing_price) in offers, do nothing.
                    Else add (item, price) to offers.
        """
        if item in self.wanted:
            if item not in self.offers:
                self.offers[item] = []
            # Only add if price is lower than existing prices
            if not self.offers[item] or price < min(self.offers[item]):
                self.offers[item].append(price)

class LowOfferMarket(Market):
    def buy(self, item):
        """
        Requires: item is an element of the domain of offers.
        Effects: Chooses and removes the pair (item, price) with the 
                    lowest price from offers and returns the chosen price.
        """
        if item in self.offers and self.offers[item]:
            # Find and remove the lowest price from the list
            lowest_price = min(self.offers[item])
            self.offers[item].remove(lowest_price)
            return lowest_price
        return None                
\end{lstlisting}

\subsection{LSP: Reducer}
\begin{figure}
\begin{lstlisting}
class A:
    def reduce(self, x):
        """
        Effects: if x is None, raise ValueError;
                 if x is not appropriate, raise TypeError;
                 else, reduce this by x.
        """

class B:
    def reduce(self, x):
        """
        Requires: x is not None.
        Effects: if x is not appropriate, raise TypeError;
                 else, reduce this by x.
        """

class C:
    def reduce(self, x):
        """
        Effects: if x is None, return normally with no change;
                 if x is not appropriate, raise TypeError;
                 else, reduce this by x.
        """
\end{lstlisting}
\caption{LSP Exercise}\label{ex:lsp-exercise}
\end{figure}

For the classes \code{A}, \code{B}, and \code{C} in \autoref{ex:lsp-exercise}, determine whether LSP holds in the following cases. Specifically, for each case, list whether the precondition is weaker, the postcondition is stronger, and conclude whether LSP holds.
\begin{enumerate}
    \item \code{B} extends \code{A}.
    \sol{B's pre is stronger than A's because it requires that $x$ is not None while A's has no pre. \textbf{LSP does not hold}. The posts of \code{A} and \code{B} are the same}
    \item \code{C} extends \code{A}
    \sol{Pre's are the same (both are total methods). C's post is stronger than A's because it allows $x$ to be None while A's does not. \textbf{LSP holds}.}
    \item \code{A} extends \code{B}
    \sol{A's pre is weaker than B's because A has no pre. The posts for both are essentially the same because B's pre explicitly requires $x$ to be not None. \textbf{LSP holds}. Note that you might argue A's post is stronger, which is also fine and also means LSP holds.}
    \item \code{C} extends \code{B}
    \sol{C's pre is weaker than B's because C allows $x$ to be None while B does not. The posts are the same. \textbf{LSP does not hold}.}
    \item \code{A} extends \code{C}
\end{enumerate}

\subsection{LSP Analysis}

Consider the following classes with their specifications for the \code{update()} method:

\begin{lstlisting}
class A:
    def update(self, value):
        """
        Effects/Post: If value is not valid, do nothing;
                 otherwise, update this with value.
        """

class B:
    def update(self, value):
        """
        Requires/Pre: value must be an integer.
        Effects/Post: If value is valid, update this with value;
                 otherwise, do nothing.
        """

class C:
    def update(self, value):
        """
        Effects/Post: If value is invalid, set default update;
                 otherwise, update this with value.
        """
\end{lstlisting}    

For each case below, determine if LSP holds by checking whether the preconditions are weaker and the postconditions are stronger, and conclude whether LSP holds. Note that as soon as one rule is violated, LSP does not hold.

\begin{enumerate}
    \item \code{B} extends \code{A}
    \item \code{C} extends \code{A}
    \item \code{A} extends \code{B}
    \item \code{C} extends \code{B}
    \item \code{A} extends \code{C}
\end{enumerate}
	% 1.	B extends A
	% •	Precondition Comparison:
	% •	Class B requires value to be an integer, which is a stricter requirement than A’s flexible acceptance of any value.
	% •	Postcondition Comparison:
	% •	The postconditions are similar; however, B may limit behavior compared to A by failing to handle non-integer values.
	% •	LSP Conclusion:
	% •	LSP does not hold because B’s preconditions are stricter, which violates the principle of substitutability.
	% 2.	C extends A
	% •	Precondition Comparison:
	% •	C has the same preconditions as A; it allows any value input without specific requirements, maintaining or weakening the base class preconditions.
	% •	Postcondition Comparison:
	% •	C has a stronger postcondition since it provides a default update when the value is invalid rather than doing nothing as A does.
	% •	LSP Conclusion:
	% •	LSP holds because C maintains weaker preconditions and provides a stronger postcondition compared to A.
	% 3.	A extends B
	% •	Precondition Comparison:
	% •	A’s precondition is weaker because it accepts all types of values, whereas B strictly requires integers.
	% •	Postcondition Comparison:
	% •	A does nothing when a value is not valid, which can be seen as weaker compared to B’s update rule for valid integers.
	% •	LSP Conclusion:
	% •	LSP does not hold because A’s postconditions are weaker and do not provide the expected behavior of the subclass B.
	% 4.	C extends B
	% •	Precondition Comparison:
	% •	C allows a broader range of inputs compared to B, which requires integers.
	% •	Postcondition Comparison:
	% •	C’s stronger postcondition of setting a default update when values are invalid provides additional functionality over B’s more limited action.
	% •	LSP Conclusion:
	% •	LSP holds because C has weaker preconditions and stronger postconditions compared to B.
	% 5.	A extends C
	% •	Precondition Comparison:
	% •	A and C share the same precondition of accepting any value without specific requirements.
	% •	Postcondition Comparison:
	% •	A’s postcondition is weaker because it does nothing when value is invalid, while C still performs a default update.
	% •	LSP Conclusion:
	% •	LSP does not hold because A provides weaker behavior than C and fails to maintain the expected outcome set by C.






\chapter{Iterators}
Iterators and generators are powerful concepts in OOP that enable efficient traversal and on-the-fly computation of sequences of data. They allow developers to handle large datasets, abstract complex data traversal patterns, and create custom iterators for any type of object. 

\begin{historybox}[History]
    The idea of iterators in OOP was pioneered by the CLU language in the 1970s, developed by Barbara Liskov. CLU introduced iterators as a core language feature, allowing traversal of collections without exposing internal structures. This innovation laid the foundation for modern iterator designs and showed how encapsulating traversal could lead to cleaner, more maintainable code. C++ in the 1980s introduces iterators through its STL. Iterators was further solidified by the Design Patterns book by the Gang of Four (GoF) in 1994, which formalized iterator patterns, emphasizing the separation of traversal from data structure.\\
    
    Java, released in 1995, built on these ideas through its Iterator interface, standardizing the way collections were traversed across the language. Java's approach unified data traversal, promoting encapsulation and abstraction in OO. Python introduces generators in 2001 and allowed functions to produce values lazily, one at a time, without storing the entire sequence in memory.  This enables efficient data processing for large or infinite sequences and emphasizes efficient iteration over data in modern languages.
\end{historybox}
\section{Motivation}
Let’s consider a scenario where you need to generate Fibonacci numbers. A common but inefficient approach is to generate Fibonacci numbers up to a certain limit and store all them in a list, which consumes a lot of memory.

\begin{lstlisting}
def generate_fib_list(n: int) -> list[int]:
    fib_sequence = [0, 1]
    for _ in range(2, n):
        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])
    return fib_sequence

# Create the first 100K Fibs; consume lots of memory for storing all numbers
fib_numbers = generate_fib_list(10**6)  
print(fib_numbers[:10])  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] # only use first 10
\end{lstlisting}

This approach is inefficient because it generates all Fibonacci numbers up to a certain limit and stores them in a list, which consumes a lot of memory, especially for large sequences. Also, this approach is wasteful because it generates all Fibonacci numbers at once, even if only a few are needed.
A more efficient approach is to use an iterator or generator to produce Fibonacci numbers on the fly, only when needed.

\begin{lstlisting}
# Efficient generator function that yields Fibonacci numbers on demand
def fib_generator(n: int):
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

print(list(fib_generator(10))) # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
\end{lstlisting}

Using generator functions, we can efficiently generate Fibonacci numbers on demand, reducing memory consumption and improving performance. Generators produce values one at a time, only when needed, making them ideal for large datasets or infinite sequences.


\section{Iterators}

An iterator is an ADT that allows you to traverse through all the elements of a collection, such as a list, tuple, or custom data structure, without exposing the underlying details of the collection (i.e., encapsulation). 

Key Concepts of Iterators:
\begin{itemize}
\item Iteration Methods: An iterator object implements two key methods: \code{\_\_iter\_\_()} and \code{\_\_next\_\_()}.
\begin{itemize}
    \item \code{\_\_iter\_\_()}: Returns the iterator object itself and is implicitly called at the start of loops.
	\item \code{\_\_next\_\_()}: Returns the next element in the sequence and raises a StopIteration exception when there are no more elements.
\end{itemize}
\item State Management: Iterators manage their own state, allowing them to keep track of the current position in the collection.
\end{itemize}

\begin{lstlisting}[multicols=2]
class Countdown:
    def __init__(self, start: int):
        self.current = start

    def __iter__(self): 
        return self

    def __next__(self):
        if self.current <= 0:
            raise StopIteration 
        else:
            current_value = self.current
            self.current -= 1
            return current_value

# Usage of the custom iterator
countdown = Countdown(5)
for number in countdown:
    print(number)

# Output: 5, 4, 3, 2, 1
\end{lstlisting}

In the example above, the \code{Countdown} class implements iteration by defining the \code{\_\_iter\_\_()} and \code{\_\_next\_\_()} methods. The \code{\_\_iter\_\_()} method returns the iterator object itself, while \code{\_\_next\_\_()} manages the countdown state by returning the next element in the countdown sequence and stopping the iteration by raising the \code{StopIteration} exception when the countdown reaches zero.


\paragraph{Benefits of Iterators}
\begin{itemize}
\item Memory Efficiency: Iterators retrieve elements one at a time, reducing memory usage compared to loading all elements at once.
\item Encapsulation: Iterators hide the internal structure of the collection, providing a clean, consistent interface for traversal.
\item Flexibility: Custom iterators can be defined for any object, making them adaptable to a wide range of data structures.
\end{itemize}


\section{Generator}
A generator is a special iterator that uses the \code{yield} keyword. Generators allow you to turn a method into one that behaves like an iterator, without having to create a separate iterator class. Generator thus has the same benefits as iterators, such as memory efficiency and encapsulation, and does not require the explicit implementation of the \code{\_\_iter\_\_()} and \code{\_\_next\_\_()} methods.

\begin{lstlisting}
# Generator function for a countdown
def countdown(start: int):
    while start > 0:
        yield start
        start -= 1

# Usage of the generator
for number in countdown(5):
    print(number)
# Output: 5, 4, 3, 2, 1
\end{lstlisting}

Instead of defining the \code{Countdown} class as an iterator, the \code{countdown} function is defined as a generator that yields the countdown sequence.
Each call to \code{yield} returns the current value of \code{start} and saves the function's state, allowing it to resume where it left off when called again.

\paragraph{Benefits of Generators}
\begin{itemize}
    \item Conciseness: Generators provide a more straightforward syntax for creating iterators.
	\item Performance: They generate values on demand, reducing memory consumption compared to traditional lists.
	\item Enhanced Readability: Generator functions are typically easier to understand and maintain compared to an iterator class.    
\end{itemize}   

\section{In-Class Exercise: Prime Number}\label{ex:prime-number}

A \emph{prime number} is a natural number greater than 1 that has no positive divisors other than 1 and itself. In this exercise, you will implement three different approaches to generate prime numbers: a non-iterator method, a custom iterator class, and a generator function. You will compare the performance of these approaches and observe the benefits of using iterators and generators.

\begin{enumerate}
    
    \item Write a non-iterator and non-generator method \code{gen\_prime} that generates prime numbers up to a specified limit.
    \begin{enumerate}
    \item Test the iterator by printing all prime numbers that is less than 50.
    \item Measure the performance of the iterator by generating all prime numbers that your computer can handle (in Python, use \code{time(...)}).  Try various limits and measure the time.
    \end{enumerate}

\item Write a custom iterator called \code{PrimeNumberIterator} that generates prime numbers up to a specified limit.
\begin{enumerate}
    \item The class needs to have \code{\_\_iter\_\_()} and \code{\_\_next\_\_()} methods.
    \item Use a helper function to check for prime numbers (reuse the code in \code{gen\_prime}).
    \item Raise \code{StopIteration} when the current number exceeds the limit.
    \item Test the iterator by printing all prime numbers that is less than 50.
    \item Measure the performance of the iterator by generating all prime numbers that your computer can handle like before.  Try various limits and measure the time.
\end{enumerate}
\item Write a generator function called \code{gen\_prime\_generator} that yields prime numbers up to a specified limit (this means using the \code{yield} keyword).
\begin{enumerate}
    \item Test the generator by printing all prime numbers that is less than 50.
    \item Measure the performance of the generator by generating all prime numbers that your computer can handle like before.  Try various limits and measure the time.
\end{enumerate}
\end{enumerate}

% class PrimeNumberIterator:
%     def __init__(self, limit):
%         self.limit = limit
%         self.current = 2

%     def __iter__(self):
%         return self

%     def __next__(self):
%         while self.current <= self.limit:
%             if self.is_prime(self.current):
%                 prime = self.current
%                 self.current += 1
%                 return prime
%             self.current += 1
%         raise StopIteration

%     @staticmethod
%     def is_prime(n):
%         if n < 2:
%             return False
%         for i in range(2, int(n**0.5) + 1):
%             if n % i == 0:
%                 return False
%         return True

\section{Exercise}
\subsection{Perfect Number Generation}

A \emph{perfect number} is a positive integer that is equal to the sum of its proper divisors, excluding itself (e.g., 6, 28). You will implement three different approaches to find perfect numbers up to a given limit, comparing their performance and resource usage.  

For this exercise, you can use either Python or Java. You need to submit your code with \emph{clear documentation} on how to run and test your code. That is, you must explicitly state the commands to run your code and the expected output. You will also need to provide screenshots or logs of the execution results, including the time taken and memory usage.  

If you do not provide clear documentation, you will not receive credit. If we cannot run your code, you will not receive credit. If we do not see the results you claim, you will not receive credit. 

\begin{enumerate}
\item Part 1: Generate Perfect Numbers Without Iterators or Generators.  Write a method \code{gen\_perfect} that generates perfect numbers up to a given positive value \code{n}, i.e., generate perfect numbers less than or equal to \code{n}.  You will not use iterators or generators and store all perfect numbers in a list.
\begin{enumerate}
    \item Play around with different \code{n} (e.g., 10,000, 100,000) to see how the program performs. Aim for about 20 seconds of execution time.
    \item Print out the first 5 perfect numbers generated. Note that if this takes too long, print out the first \code{n} numbers that seems to take reasonable time.  Be sure to document and explain your choice of \code{n}.
    \item Measure execution time and memory usage, which should be relatively high due to high computational demands and storage of all perfect numbers.  For Python, use \code{timeit} and \code{tracemalloc} modules to measure time and memory usage.
\end{enumerate}

\item Part 2: Implement a custom iterator called \code{PowerNumberIterator} for perfect numbers. You can reuse the code from part 1.  After that, do exactly the analysis that you did in Part 1, i.e., play with different \code{n} values, print out the first 5 numbers generated, and measure the performance of the iterator.  You should see a significant improvement in memory usage and execution time compared to the non-iterator approach.
\item Part 3: Use a generator function \code{gen\_power\_generator} to yield perfect numbers.  Reuse the code from part 1 and make changes to it to use generator.  Then do the same analysis as in Part 1 and Part 2.
\item Part 4: Write a short report comparing the performance of the three approaches.  Include the time taken, memory usage, and ease of implementation.  Discuss the benefits of using iterators and generators over the non-iterator approach.
\end{enumerate}

\subsection{Iterators and Generators Multiple Choice}


\begin{enumerate}
\item What does this class represent?
\begin{lstlisting}
    class Counter:
        def __init__(self, start, end):
            self.current = start
            self.end = end
    
        def __iter__(self):
            return self
    
        def __next__(self):
            if self.current > self.end:
                raise StopIteration
            else:
                self.current += 1
                return self.current - 1
    \end{lstlisting}
\begin{enumerate}
    \item A list that can be iterated through once.
    \item An infinite loop.
    \item An iterator that generates numbers between \texttt{start} and \texttt{end}, inclusive.
    \item A generator that yields values on demand.
\end{enumerate}

%\textbf{Correct Answer:} C



\item What is main advantage of using a generator in this example?
\begin{lstlisting}
    def count_down(n):
        while n > 0:
            yield n
            n -= 1
    \end{lstlisting}

\begin{enumerate}
    \item It stores all the countdown numbers in mem at once.
    \item It allows for lazy evaluation, producing numbers one at a time without storing in memory.
\end{enumerate}


\item What is returned by \texttt{fibonacci}?

\begin{lstlisting}
    def fibonacci(n):
        a, b = 0, 1
        for _ in range(n):
            yield a
            a, b = b, a + b
\end{lstlisting}

\begin{enumerate}
    \item The sum of all Fib numbers up to \texttt{n}.
    \item Fib numbers up to \texttt{n}, one by one, using lazy evaluation.
    \item The first \texttt{n} Fib numbers.
    \item The Fibonacci sequence stored as a tuple.
\end{enumerate}

%\textbf{Correct Answer:} B

\item What happens if you try to convert the generator \texttt{generate\_squares} to a list?

\begin{lstlisting}
    def generate_squares(limit):
        for i in range(limit):
            yield i ** 2
    \end{lstlisting}

\begin{enumerate}
    \item It yields values 1-by-1 instead of storing in memory.
    \item It returns an error.
    \item It gets exhausted and returns an empty list.
    \item It will create a list of square numbers up to \code{limit - 1}.
\end{enumerate}

%\textbf{Correct Answer:} D


\item What is the purpose of this generator?
\begin{lstlisting}
    def infinite_numbers():
        num = 0
        while True:
            yield num
            num += 1
    \end{lstlisting}
\begin{enumerate}
    \item It generates numbers up to a fixed limit.
    \item It produces numbers starting from 0, but stops after a certain point.
    \item It generates an infinite sequence of numbers, one at a time.
    \item It returns numbers in ascending order.
\end{enumerate}

%\textbf{Correct Answer:} C
\end{enumerate}



\chapter{First-Class Functions}

In modern OOP, functions are treated as \emph{first-class} citizens, meaning they can be assigned to variables, passed as arguments, and returned from other functions.


\begin{lstlisting}
    def greet(name):
        return f"Hello, {name}!"

    # Assigning the function to a variable
    greeting = greet

    # `greeting` can now be used like the function `greet`
    print(greeting("Alice"))  # Output: Hello, Alice!
\end{lstlisting}

In this example, the \code{greet} function is assigned to a variable \code{greeting}, which can then be called like a regular function. 

\begin{lstlisting}
    def apply(op, a:int, b:int) -> int: return op(a, b)        
    def add(x:int, y:int) -> int: return x + y        
    def subtract(x:int, y:int) -> int: return x - y        

    # Passing functions as arguments
    result_add = apply_op(add, 10, 5)       # Output: 15
    result_subtract = apply_op(subtract, 10, 5)  # Output: 5
\end{lstlisting}

For this example, \code{apply\_op} takes another function \code{op} as an argument and applies it to the given arguments. This allows for dynamic behavior based on the function passed to \code{apply\_op}.

\begin{historybox}[History]
Lisp, developed by John McCarthy in the late 1950s, was one of the first languages to treat functions as first-class citizens. Lisp's approach to functions was heavily influenced by \emph{lambda calculus}, developed by Alonzo Church in the 1930s, which formalized functions as mathematical expressions. Lisp's support for first-class functions allows for powerful programming techniques, such as higher-order functions (\autoref{sec:higher-order}).  Modern programming languages including Python, JavaScript, and Ruby all treat functions as first-class citizens. 
\end{historybox}

\section{Anonymous and Lambda Functions}\label{sec:lambda}
A popular use for first-class functions is to create \emph{anonymous} or \emph{lambda} functions, which are unnamed functions defined on the fly. Lambda functions are useful for short, simple operations that do not require a full function definition. 
\begin{lstlisting}
# Lambda function to square a number
square = lambda x: x ** 2
print(square(5))  # Output: 25
\end{lstlisting}

In the example above, a lambda function is used to define a function that squares a number. The lambda function is assigned to the variable \code{square} and can be called like a regular function.
Lambda functions are often used in conjunction with higher-order functions like \code{map}, \code{filter}, and \code{reduce}, described in \autoref{sec:higher-order}, to perform operations on collections of data.

\section{Higher-Order Functions}\label{sec:higher-order}

In the world of first-class functions, functions that operate on other functions are called \emph{higher-order functions}. More specifically, a higher-order function is a function that takes one or more functions as arguments or returns a function as its result.

\begin{lstlisting}
    def square(x):
        return x * x

    def cube(x):
        return x * x * x

    def apply_to_list(func, numbers):
        return [func(number) for number in numbers]

    numbers = [1, 2, 3, 4, 5]
    print(apply_to_list(square, numbers))  # Output: [1, 4, 9, 16, 25]
    print(apply_to_list(cube, numbers))    # Output: [1, 8, 27, 64, 125]

\end{lstlisting}

In this example, the higher-order function \code{apply\_to\_list} takes a function and a list of numbers as inputs and applies the function to each number in the list, returning a new list with the results. 


\subsection{Popular Higher-Order Functions}

Higher-order functions are commonly used in functional programming and are available in many programming languages. Three popular higher-order functions include:

\begin{itemize}
    \item \code{map(f, iterable)}: Applies a function \code{f} to each item in an iterable (e.g., list, tuple) and returns a new iterable with the results.\\
    Example: \code{list(map(square, [1,2,3,4,5]))} returns \code{[1, 4, 9, 16, 25]}.
    \item \code{filter(f, iterable)}: Filters elements in an iterable based on a predicate \code{f} (i.e., a function that returns a boolean value).\\
    Example: \code{list(filter(lambda x: x \% 2 == 0, [1,2,3,4,5]))} returns \code{[2, 4]}. Lambda functions are discussed in the next section (\autoref{sec:lambda}).
    \item \code{reduce(f, iterable)}: Applies a binary function \code{f} to the first two items of an iterable, then to the result and the next item, and so on. It returns a single value.\\
    Example: \code{reduce(lambda x, y: x + y, [1,2,3,4,5])} returns \code{15}. 
\end{itemize}

\begin{historybox}[Fun Fact] 
    While \code{reduce} is well-known in functional languages such as Haskell and Ocaml, the Python community believes that list comprehensions and generator expressions made the code more readable than \code{reduce}. Thus, in Python 3, \code{reduce} was moved to the \code{functools} module to emphasize its specialized use case.

    For example, compare the following code snippets that calculate the sum of a list of numbers using \code{reduce} and list comprehension:
    \begin{lstlisting}
    # Calculate the sum of a list of numbers using reduce
    numbers = [1, 2, 3, 4, 5]
    total = reduce(lambda x, y: x + y, numbers)
    print(total)  # Output: 15
    
    # using list comprehension
    total = sum(numbers)
    print(total)  # Output: 15
    
    # using generator expression
    total = sum(x for x in numbers)
    print(total)  # Output: 15
    \end{lstlisting}    
\end{historybox}


\begin{historybox}[Fun Fact]
The MapReduce framework, introduced by Google in 2004, was inspired by \code{map} and \code{reduce} (``map'' distributes work across multiple nodes and the ``reduce'' aggregates the results).  It revolutionizes large-scale data processing and allows Google to index the web efficiently. It influences current web technologies such as Apache Hadoop and Apache Spark.
\end{historybox}

\section{Closures}
Closures are a higher-order function that returns a function. It is a powerful feature of first-class functions and allows functions to retain access to variables from their enclosing scope even after the scope has finished executing.

\begin{historybox}[Fun fact] 
    Closures are used extensively in Javascript, introduced in the Netscape browser in 1995 by Bredan Eich. Javascript supports closures and first-class functions and enables the development of dynamic and interactive web applications, leading to its widespread adoption and popularity.
\end{historybox}
\paragraph{Examples}
\begin{figure}
\begin{lstlisting}
def make_multiplier(factor):
    def multiplier(x):   # a closure
        return x * factor
    return multiplier  # Return the closure

# Create a function that multiplies by 3
times_three = make_multiplier(3)
print(times_three(5))  # Output: 15

# Use with higher-order functions
numbers = [1, 2, 3, 4, 5]
multiplied_numbers = list(map(make_multiplier(2), numbers))
print(multiplied_numbers)  # Output: [2, 4, 6, 8, 10]
\end{lstlisting}
\caption{Closure example. Note that this example also illustrate curry, a form of closure (\autoref{sec:curry})}\label{ex:closure-example}
\end{figure}

The above example demonstrates a closure where the \code{make\_multiplier} function returns the \emph{closure} inner function \code{multiplier} that multiplies a number by a given factor. The \code{times\_three} function is created by calling \code{make\_multiplier(3)}, which returns a function that multiplies by 3. The closure allows the \code{multiplier} function to retain access to the \code{factor} variable even after \code{make\_multiplier} has finished executing.

\begin{lstlisting}
    def make_averager():
        series = []

        def averager(new_value):
            series.append(new_value)
            total = sum(series)
            return total / len(series)

        return averager

    avg = make_averager()
    print(avg(10))  # Output: 10.0
    print(avg(11))  # Output: 10.5
    print(avg(12))  # Output: 11.0
    print(avg(13))  # Output: 11.5
\end{lstlisting}

In the example above, the \code{make\_averager} function creates a closure that calculates the average of a series of numbers. The \code{averager} function retains access to the \code{series} list, allowing it to accumulate values and calculate the average over time.
\section{In-Class Exercise: Functions First}
In this exercise you will demonstrate the concepts of higher-order functions, lambda functions, and closure. Example code are written in Python but you can use Python or any other language that supports these features.

\begin{enumerate}
\item Part 1: Create a \emph{higher-order} function that applies different operations (addition, subtraction, multiplication) to two numbers.
\begin{enumerate}
\item Create a function called \code{operate\_on\_numbers (operation: function, a: int, b: int) -> int} that takes another function (operation) as an argument and applies that function to two numbers.
\item Create multiple simple functions \code{add}, \code{subtract}, \code{multiply} that can be passed as arguments to \code{operate\_on\_numbers}.
\item Test the function by applying each operation to two numbers and printing the results.
\begin{lstlisting}
    print(operate_on_numbers(add, 5, 3))        # Output: 8
    print(operate_on_numbers(subtract, 5, 3))   # Output: 2
    print(operate_on_numbers(multiply, 5, 3))   # Output: 15
\end{lstlisting}

\end{enumerate}

\item Part 2: Modify the code from Part 1 to use \emph{lambda functions} 
\begin{enumerate}
\item Replace \code{add}, \code{subtract}, and \code{multiply} with lambda expressions.
\item Test the function by applying each operation to two numbers and printing the results.
\item Discuss when you would want to use lambda functions? When would you want to use a name function?
\end{enumerate}

\item Part 3: Using higher-order functions
\begin{enumerate}
\item For each higher-order function \code{map}, \code{filter}, and \code{reduce}, create some code to apply each to a list of \code{str}.
\item Clearly explain what each function does and print several examples to demonstrate each function.
\item \code{reduce} also takes a third input called an \emph{accumulator}.  Explain how \code{reduce} works with the accumulator ? e.g., \code{reduce(f,[1,2,3,...,n],acc)} does what?
\item Create some code to demonstrate the use of the accumulator in \code{reduce}. DO NOT use the example in the lectures (eg.., sum, product, subtract).
\end{enumerate}

\item Part 4: Write a function \code{make\_max\_tracker()} that returns a closure that tracks and returns the highest number seen so far. In Python, to access a variable that is not in scope, you might need to use the \code{nonlocal} keyword, e.g., \code{nonlocal var\_name}.
\begin{lstlisting}
    def make_max_tracker():
        ...
        def tracker(v):
           ...
        
        return tracker

    max_tracker = make_max_tracker()

    # Test closer, notice how it "memorizes" what it has seen so far.
    print(max_tracker(5))  # Output: 5
    print(max_tracker(3))  # Output: 5
    print(max_tracker(8))  # Output: 8
    print(max_tracker(7))  # Output: 8
\end{lstlisting} 

\end{enumerate}

% **Example Code**:

% ```python
% def create_custom_multiplier(n, func):
%     def multiplier(x):
%         return func(x * n)  # The closure captures `n` and applies `func` to the result
%     return multiplier


% ```



\section{Currying}\label{sec:curry}

Currying is a special form of closure. The curried function takes one argument at a time and returns a new function that takes the next argument. In other words, it transforms a function of arity $n$ to $n$ functions of arity $1$.

The \code{make\_multiplier} function in \autoref{ex:closure-example} is an example of currying. The function needs 2 arguments, but it is transformed into a series of 2 function calls where each take 1 argument. For example, \code{make\_multiplier(2)(3)} is equivalent to \code{2*3}.


\begin{historybox}[History] 
    Currying was introduced by Haskell Curry in the 1930s. Currying and higher-order functions (\autoref{sec:higher-order}) are widely-used in functional programming languages such as Ocaml and Haskell (named after Haskell Curry).
\end{historybox}

\section{Exercise}

\subsection{E1}
\begin{enumerate}
    \item Explain the difference between a \emph{higher-order} function and a \emph{closure}. Provide an example of each.
    \item When would you use a \emph{lambda function} over a regular function? Provide an example.
    \item Write a function \code{make\_min\_tracker()} that returns a closure which tracks and returns the lowest number seen so far.
    \begin{lstlisting}
    def make_min_tracker():
        ...
        def tracker(v):
           ...
        
        return tracker

    min_tracker = make_min_tracker()
    print(min_tracker(5))  #  5
    print(min_tracker(3))  #  3
    print(min_tracker(8))  #  3
    print(min_tracker(-1)) # -1
    print(min_tracker(0))  # -1
    \end{lstlisting}
\end{enumerate}

\chapter{Testing}\label{chapter:testing}

%Liskov 10

The terms \emph{validation}, \emph{verification}, and \emph{testing} are commonly used in software development for quality assurance. \textbf{Validation} is a process typically achieved by verification and validation to ensure the program behaves as expected. \textbf{Verification} ensures that the program works on \emph{all possible inputs}. Verification provides better guarantee but is expensive or impossible for large programs.

In contrast, \textbf{testing} checks that the program behaves as expected over \emph{some inputs}. Testing only shows the program works on the test inputs, but it is usually cheaper to do (comparing to verification). Software developers are often more familiar with testing, e.g., by running the program with various inputs. We focus on testing in this chapter.  

%While many testing techniques exist (popular ones will be discussed below), they typically have the same purpose of finding bugs that trigger undesirable behavior in the program (e.g., causing crashes, revealing security vulnerabilities, producing unexpected/incorrect outputs, etc). More specifically, a major goal of testing is to find \textbf{counterexample inputs} (or \emph{cex} for short) that violate the program's specifications or requirements. This field of \textbf{input generation} is an active area of research in software engineering and related fields.

\section{Black-box Testing}\label{sec:blackbox}

Black-box approach tests the program using its specifications (e.g., type of inputs, expected outputs) \emph{without} any knowledge of its internal implementation. In fact, blackbox testing does not even require the program code (hence the name black-box).  The approach is efficient and easy to use, but can miss certain bugs.

\begin{lstlisting}
class MathStuff:
    def square(self, x:int) -> int:
        if x == 123:
            return -1 # bug
        else:
            return x*x
    
    def div(self, x:int, y:int) -> int:
        if y == 0:
            raise ValueError("Cannot divide by 0")
        else:
            return x // y


""" Only test on integer inputs and check that the outputs are as expected"""
ms = MathStuff()
assert ms.square(0) == 0   
assert ms.square(1) == 1
...
assert ms.square(12) == 144
assert ms.square(-5) == 25

assert ms.div(10, 2) == 5
assert ms.div(10, 3) == 3

try:
    ms.div(10, 0)
except ValueError:
    # raise an exception is expected
    pass
else:
    print "Error: Should have raised an exception"

\end{lstlisting}

For these functions (\code{square, div}) we simply test them with various numbers as inputs and check that the outputs are as expected. We do not need to know how the functions (e.g., \code{square}) were implemented. Observe that because of this, we do not know about the special ``buggy'' case of \code{123} in \code{square} and thus do not test for it. This is a limitation of blackbox testing.

\subsection{Unit Testing}\label{sec:unit-testing}

Modern OOP languages often have built-in capability or library to help with testing. \emph{Unit testing} is a popular and supported by most languages to test individual \emph{units} (e.g., functions, classes) of the program. Below is a small example of using Python's \code{unittest} library to test the \code{MathStuff} class (\autoref{sec:blackbox}).

\begin{lstlisting}

    import unittest
    class TestCalculator(unittest.TestCase):
        ## setup unit tests. This is run before each test    
        def setUp(self):
            self.ms = MathStuff()
    
        # Basic Unit Tests
        def test_square(self):
            self.assertEqual(self.ms.square(0), 0)
            self.assertEqual(self.ms.square(1), 1)
            self.assertEqual(self.ms.square(12), 144)
            self.assertEqual(self.ms.square(-5), 25)
    

    
        def test_div(self):
            self.assertEqual(self.ms.div(10, 2), 5)
            self.assertEqual(self.ms.div(10, 3), 3)

            with self.assertRaises(ValueError):
                self.ms.div(10, 0)
    
    if __name__ == "__main__":
        unittest.main()
\end{lstlisting}


\subsection{Special/Edge Cases Testing}\label{sec:special-case-testing}

This testing runs the program on special or edge cases to find bugs that are not caught by regular inputs.


For example, a program like \code{MathStuff.square} in \autoref{sec:unit-testing} should be tested with negative numbers, zero, and positive numbers. Similarly, for a program that takes a list of numbers as input, special cases could include an empty list, with one element, with all 0's, with all negative numbers, etc.


\subsection{Fuzz Testing}
This testing generates random and \emph{invalid} inputs to test the program. For example, a program expects a number is tested with a string or a dict.  It has the similar purpose as special cases testing (\autoref{sec:special-case-testing}), but instead of using specific valid inputs, it generates many random and invalid inputs. Fuzz testing is often used to find security vulnerabilities. Many advanced fuzzing techniques generate new inputs from existing or \emph{seed} inputs, e.g., by flipping bits or changing values slightly.

\begin{lstlisting}
#generate 100 random numbers
for i in range(100):
    x = random.randint(-1000, 1000)
    assert square(x) == x*x

#invalid inputs
for x in [["hello", [1,2,3], {"a":1}]]:
    try:
        square(x)
        assert False, "Should have raised an exception"
    except:
        # raise an exception is expected
        pass
    
#generate inputs from existing ones
for x in [1,2,3]:
    x2 = x + random.randint(-10, 10)
    assert square(x) == square(x2)
\end{lstlisting}

%\paragraph{Fun fact} Fuzz testing was popularized by Barton Miller in the 1980s. 



\subsection{Combinatorial Testing}\label{sec:combinatorial-testing}
This technique combines different inputs to generate tests.  The combination is typically done using \emph{Cartesian} products, i.e., all possible combinations of inputs are tested. Combinatorial testing is useful for finding issues that occur when combining different inputs. For example, a program that takes two numbers as input could be tested with all combinations of positive, negative, and 0 numbers. 

\begin{lstlisting}
    from parameterized import parameterized
    ...

    xs = [11, 12, -11, -12, 0]
    ys = [1, 2, -1, -2, 0]

    @parameterized.expand(product(xs, ys))
    def test_div(self, x, y):
        if y == 0:
            with self.assertRaises(ValueError):
                self.ms.div(x, y)
        else:
            expect = x // y            
            self.assertEqual(self.ms.div(x, y), expect)
\end{lstlisting}

For the example above, the \code{test\_div} function is run with all combinations numbers in \code{xs} and \code{ys}. The \code{product} function generates all 25 combinations of the numbers in the lists \code{xs, ys} (Cartesian product). The \code{@parameterized.expand} runs the test with each input. Note that while this is illustrated using Python, the concept of combinatorial testing is used in other languages and testing frameworks.

\subsection{Property-Based Testing}\label{sec:property-based-testing}
Property-based testing generates random inputs to check specific \emph{properties} of the program. For example, square of a negative number is positive and addition and multiplication being commutative (e.g., $x + y \equiv y + x$). Property-based testing is a convenient way to generate and test desirable behaviors with many inputs.

\paragraph{Assertions} Property-based tests often use \emph{assertions} to check the properties. Most languages have the function \code{assert(c)} or similar that raises an exception if the condition \code{c} is false.


\begin{lstlisting}
    from hypothesis import given
    from hypothesis.strategies import integers

    @given(integers(), integers()) # create random integers
    def test_square(x, y):
        assert square(x) == x*x
        assert square(y) == y*y
        assert square(x) == square(-x) # square of neg is positive

    @given(integers(), integers()) # create random integers
    def test_add(x, y):
        assert add(x, y) == add(y, x) # commutative
\end{lstlisting}

This example tests various properties of \code{square} and \code{add} with randomly generated integers \code{x, y}. In Python, you can use the \code{hypothesis} library, which generates random inputs and runs the tests with them. In Java, you can use the \code{jqwik} library for property-based testing.


\section{In-class Exercise: GCD}
You are given two implementations computing the GCD (Greatest Common Divisor) of two numbers. One of them is correct and the other has a bug.  You will write combinatorial and property tests to find the bug. Recall that the GCD of two numbers is the largest number that divides both of them. For example, \code{gcd(8,12)=4}. 


\begin{lstlisting}[multicols=2]
def gcd_correct(a, b):
    while b != 0:
        a, b = b, a % b
    return abs(a)

def gcd_buggy(a, b):
    while b != 0:
        a, b = b, a % b
    return a
\end{lstlisting}

\paragraph{Part 1: Using Combinatorial Testing to Find Bugs}
\begin{itemize} 
    \item Write code to perform combinatorial testing on \code{gcd\_correct} and \code{gcd\_buggy}. In Python, these would be done by importing the \code{parameterized} module (\autoref{sec:combinatorial-testing})
    \item Create tests with several positive, negative, and zero numbers.
    \item Run the tests and show the bug in \code{gcd\_buggy}.  
    \item Explain how combinatorial testing helped find the bug.
\end{itemize}

\paragraph{Part 2: Using Property Testing to Find Bugs}
\begin{itemize}
\item Identify several properties of GCD (use Wikipedia if you have to). One of these properties should help you detect the bug in \code{gcd\_buggy}.
\item Write code to perform property-based testing on \code{gcd\_correct} and \code{gcd\_buggy}. In Python, these would be done by importing the \code{hypothesis} module (\autoref{sec:property-based-testing})
\item Run the tests and show the bug in \code{gcd\_buggy}.
\item Explain how property-based testing helped find the bug.
\end{itemize}


\subsection{Search-Based Software Testing (SBST)}
SBST searches for inputs to optimize some objective. Examples include maximizing code coverage, causing a crash, or satisfying a specific property.
\subsection{Genetic Algorithm}\label{sec:ga}

Genetic Algorithm (GA) is an SBST technique that uses biological evolution (Darwin's theory of evolution) to generate test inputs.
GA starts with an initial set or \emph{population} of random inputs (\emph{individuals}) and iteratively evolves them to find the best one that achieves some objective. GA uses a \emph{fitness function} to evaluate the quality of the individuals and \emph{selects} the best ones to survive and reproduce (i.e., survival of the fittest). GA then applies genetic operators to create individuals representing the new population in the next \emph{generation}. This process continues until a \emph{stopping criterion} is met.

The main genetic operators in a GA are
\begin{enumerate}
    \item \emph{Crossover (xover)}: combines two individuals or \emph{parents} to create new ones. Common xover methods include single-point, two-point, and uniform crossover. xover rate is the probability of applying xover, and typically is high (e.g., 0.8 or 80\% chance).
    \item \emph{Mutation}: randomly changes some elements of an individual. Common mutation methods include creating a random element, swapping two element, and flipping (e.g., negative to positive, 0 to 1, etc). Mutation rate is the probability of doing mutation, and typically is low (e.g., lower than 0.1 or 10\% chance).
\end{enumerate}

\paragraph{GA Tempalte} The following is a template for GA:
\begin{lstlisting}

    def ga(...):
        # Initialize the population
        pop = gen_pop(...) # generate a random population

        # Evaluate the fitness of each individual
        fitness = eval_fitness(...)

        # Repeat until stopping criterion is met
        while not stopping_criterion(...):
            # Select the best individuals
            parents = select(...)
            
            # Apply genetic operators to create new individuals
            offspring = crossover(...)
            offspring = mutate(...)
            
            # Replace the old population with the new one
            pop = offspring

            # Evaluate the fitness of the new population
            fitness = eval_fitness(...)
            
        # Return the best individual
        best = select_best(...)
        return best
\end{lstlisting}

\section{In-class Exercise: GA list sum}
In this assignment you have two tasks. First, you will \emph{implement a GA} that evolves a population of lists of integers to find a list whose sum is a given target sum. Next, you will write a \emph{short report} that explains your GA and how you tested it.

\paragraph{Task 1: GA implementation}

 You can use the GA template in \autoref{sec:ga} for this task. You can also use the following \href{https://nguyenthanhvuh.github.io/class-oo/ga-example.py}{GA code for counting 0's} as example. You will likely need to modify this code to fit your needs as the problem and objective are very different.
 
 
 Specifically, you will implement the following GA components. The \emph{signatures} below for the functions are just suggestions. You can modify them as needed.


\begin{enumerate}
    \item \emph{Generate} an initial, random population of lists of integers. The length of the popular and individual lists are given as input.  The integers in the list should be between a specified range (e.g., -100,100)\\
    \code{gen\_pop(pop\_size:int, indv\_size:int, min\_val:int, max\_val:int) -> list[list[int]]}
    \item Write a \emph{fitness function} that computes the fitness score based on how close the sum of the list is to the target sum. Closer is better (e.g., if the target is 99, then a list whose sum is 99 should have the ``perfect score'' while a list whose sum is 90 has a better score than a list whose sum is 50). Note that you must also take account of negative numbers and sums.  \\
    \code{get\_fitness(indiv:list[int], target\_sum:int)}
    \item Write a \emph{selection function} that selects the best individuals based on their fitness scores. You can use any selection method you like (e.g., roulette wheel, tournament selection). You should look these up to understand how they work.\\
    \code{select(pop:list[list[int]], fitness:list[int], pop\_size:int) -> list[list[int]]}
    \item Write a \emph{crossover} function that takes two parents and creates two offsprings using \emph{single-point} crossover (i.e., pick a random point and swap).\\
    \code{def crossover(parent1: list[int], parent2: list[int], rate:float) -> tuple(list[int], list[int])}
    \item Write a \emph{mutation} function that randomly changes a few elements of an individual based on a mutation rate.\\
    \code{def mutate(indiv:list[int], rate:float, min\_val:int, max\_val:int) -> list[int]}
    \item Write a \emph{stopping criterion} function that stops the GA when it found an individual whose sum is the target number.\\
    \code{def stopping\_criterion(best\_fitness) -> bool}
    \item Write the \emph{main} genetic algorithm that uses all the above functions and returns the best individual and its fitness.\\
    \code{def ga(pop\_size:int, indv\_size:int, xover\_rate:float, mut\_rate:float, min\_val:int, max\_val:int, target:int): -> (list[int], float)}
    \item Your GA should print out the best individual, its sum, and its fitness score at each generation (iteration).
    \item Your GA has the various parameters (e.g., inputs to the \code{ga}). You should play with them to find values that work best.  You can start with these values: \code{pop\_size=100, indv\_size=10, xover\_rate=0.8, mut\_rate=0.1, min\_val=-100, max\_val=100, target=1000}.
    \item Time your GA. You can use Python's \code{time} module for this.
    \item Submit your code with a clear \code{README} instruction on how to run your GA and test it. You should also submit screenshots of your GA running (you don't need to show all the generations, just a few to show that it is working).
\end{enumerate}

\paragraph{Task 2: Write and submit a short report}
\begin{enumerate}
\item Write a report explaining your GA. More specifically for each of the above task, explain that you did (e.g., how do you generate the population, how do you compute the fitness, etc).

\item Explain the parameters you used and how they affect the performance of the GA (e.g., the time it took).  For example, how does the population size affect the performance? crossover and mutation rates? etc.

\end{enumerate}




%\section{Regression Testing}
%\section{Integration Testing}
%\section{System Testing}



\section{Whitebox Testing with Symbolic Execution}\label{sec:symbolic-execution}

In contrast to black-box testing (\autoref{sec:blackbox}) that does not look at the code, \emph{white-box testing} reasons about the program using its source code, allowing it to find bugs that escape black-box testing.  For example, in the \code{square} function in \autoref{sec:blackbox}, by analyzing the code we can see that the program has a bug on input $123$ because it returns $-1$ instead of ${123}^2$. 


\emph{Symbolic execution} is a white-box testing technique to find inputs causing the program to take some interesting paths (e.g., that result in a bug). Symbolic execution runs the program with \emph{symbolic inputs} instead of concrete ones (e.g., $x$ instead of $5$) and tracks program's state. It uses constraints or logical formulae to represent the program's \emph{path conditions} (PCs) reaching the interesting paths. It then uses a constraint solver, e.g., a SAT or SMT solver, to find the concrete input that satisfies the path condition. 

\paragraph{Example 1}
\begin{lstlisting}[language=c]
void foo(int a, int b, int c){    
    // l0
    int x=0, y=0, z=0;
    // l1
    if(a) {        
        x = -2;
        // l2
    }
    // l3
    if (b < 5) {
        // l4 
        if (!a && c) {            
            y = 1; 
            // l5
        }        
        z = 2;
        // l6 
    }
    // l7
    assert(x + y + z != 3);
}
\end{lstlisting}

\paragraph{Example} We execute this program with symbolic inputs $a, b, c$.  At each location $l$,  we keep track of two things: the path condition (PC) to reach $l$ and the program state (PS), consisting values of variables at $l$.

At $l0$, the PC is always true (i.e., $T$) and the PS is $\{\}
$, i.e., nothing yet. At $l1$, PC is $T$ and $PS$ is $\{x\mapsto 0, y\mapsto 0, z\mapsto 0\}$. The PC for $l2$ is $a$ with PS $\{x\mapsto -2,y\mapsto 0,z\mapsto 0\}$.  

At $l3$ we have two paths reaching it.  The PC for the first path is $a$ with PS $\{x\mapsto -2,y\mapsto 0,z\mapsto 0\}$. The PC for the second path is $\lnot a$ with PS $\{x\mapsto 0,y\mapsto 0,z\mapsto 0\}$.
At $l4$ we have two paths: 1st path has PC $a \land b < 5$ with PS $\{x\mapsto -2,y\mapsto 0,z\mapsto 0\}$, and 2nd path has PC $\lnot a \land b < 5$ with PS $\{x\mapsto 0,y\mapsto0,z\mapsto 0\}$. At $l5$ we have 2 paths, at $l6$ we have 4 paths, and so on as shown in \autoref{tab:symbolic-execution}

\begin{table}
    \centering
    \caption{Symbolic Execution Example}\label{tab:symbolic-execution}
    \begin{tabular}{c|l|l}
\toprule
\textbf{Loc ($l$)} & \textbf{Path Condition} (PC) & \textbf{Program State} (PS) \\
\midrule
$l0$ & $T$ & $\{\}$ \\
$l1$ & $T$ & $\{x\mapsto0, y\mapsto0, z\mapsto0\}$ \\
$l2$ & $a$ & $\{x\mapsto-2, y\mapsto0, z\mapsto0\}$ \\
\midrule
$l3$ & $a$ & $\{x\mapsto-2, y\mapsto0, z\mapsto0\}$ \\
$l3$ & $\lnot a$ & $\{x\mapsto0, y\mapsto0, z\mapsto0\}$ \\
\midrule
$l4$ & $a \land b < 5$ & $\{x\mapsto-2, y\mapsto0, z\mapsto0\}$ \\
$l4$ & $\lnot a \land b < 5$ & $\{x\mapsto0, y\mapsto0, z\mapsto0\}$ \\
\midrule
$l5$ & $a \land b < 5 \land \lnot a \land c$ & $\{x\mapsto-2, y\mapsto1, z\mapsto0\}$ \\
$l5$ & $\lnot a \land b < 5 \land \lnot a \land c$ & $\{x\mapsto0, y\mapsto1, z\mapsto0\}$ \\
\midrule
$l6$ & $a \land b < 5 \land \lnot a \land c$ & $\{x\mapsto-2, y\mapsto1, z\mapsto2\}$ \\
$l6$ & $a \land b < 5 \land (a \lor \lnot c)$ & $\{x\mapsto-2, y\mapsto0, z\mapsto2\}$ \\
$l6$ & $\lnot a \land b < 5 \land \lnot a \land c$ & $\{x\mapsto0, y\mapsto1, z\mapsto2\}$ \\
$l6$ & $\lnot a \land b < 5 \land (a \lor \lnot c)$ & $\{x\mapsto0, y\mapsto0, z\mapsto2\}$ \\
\midrule
$l7$ & $a \land b < 5 \land \lnot a \land c$ & $\{x\mapsto-2, y\mapsto1, z\mapsto2\}$ \\
$l7$ & $a \land b < 5 \land (a \lor \lnot c)$ & $\{x\mapsto-2, y\mapsto0, z\mapsto2\}$ \\
$l7$ & $\lnot a \land b < 5 \land \lnot a \land c$ & $\{x\mapsto0, y\mapsto1, z\mapsto2\}$ \\
$l7$ & $\lnot a \land b < 5 \land (a \lor \lnot c)$ & $\{x\mapsto0, y\mapsto0, z\mapsto2\}$ \\

$l7$ & $a \land b \ge 5$ & $\{x\mapsto-2, y\mapsto0, z\mapsto0\}$ \\
$l7$ & $\lnot a \land b \ge 5 $ & $\{x\mapsto0, y\mapsto0, z\mapsto0\}$ \\
\bottomrule
\end{tabular}
\end{table}

\paragraph{Constraint Solving} 
After obtaining the PCs, we can use a constraint solver like Microsoft Z3 solver to find the concrete inputs reaching to a specific location by solving the corresponding PC. For example, a solution to the PC $a \land b < 5$ of $l4$ is $a=1, b=3$, which means the program reaches $l4$ with $a=1, b=3$.

\paragraph{Assertions} Assertions indicate what the programmer believes to be true at a certain point in the program. If an assertion fails, it indicates a bug in the program. For example, the assertion in this example would fail when we have $x + y + z = 3$.

To make the reasoning easier, we can convert the statement \code{assert(c)} to 
\begin{lstlisting}
if(!c){
    // failure loc
    assert(0);
}
\end{lstlisting}

This allows us to use symbolic execution as usual compute the PC to reach the failure location. 

\paragraph{None-Symbolic Values} Observe our assertion here involves the non-symbolic values $x, y, z$, which we keep track in the program state. It is common in symbolic execution where we have to reason both symbolic and non-symbolic values (hence we keep track of both PC and PS).

Thus we essentially want to check if any of the paths can reach the assertion location has $x + y + z = 3$. In this example, according to \autoref{tab:symbolic-execution}, we see that the path reaching $l7$ with PC $\lnot a \land b < 5 \land (\lnot a \land c)$ with PS $\{x\mapsto 0, y \mapsto 1, z \mapsto2\}$ would satisfy $x + y + z = 3$. Using a constraint solver, we can find the a concrete input $(a=0, b=3, c = 1)$ that would reach this path and fail the assertion.





\section{Fault Localization}\label{sec:debugging}

Fault localization is a debugging process of isolating the bug in the program. It is crucial for developers to understand and fix the bug. Programmers use various techniques, including \code{printf} debugging where they output variable values to analyze the bug. Professional developers use built-in debugger tools in IDEs to step through and pause code execution to inspect variables and program states.  

Here we will discuss two popular fault localization techniques: \emph{statistical debugging} and \emph{delta debugging} to localize code and inputs that likely contain the bug.


\subsection{Statistical Debugging}\label{sec:statistical-debugging}
Statistical debugging is a white-box technique that uses statistics to find bugs in code, i.e., \emph{fault localization}. It collects program execution traces, e.g., which lines of code were executed, how many times, etc, and uses this data to find the lines that likely contain the bug. For example, if a line $l$ is executed many times when the program fails but not when it runs correctly, then $l$ is likely the bug.

\emph{Tarantula} is a popular statistical debugging technique that computes a suspicious score for each line of code based on the number of times it was executed when the program failed and when it passes (gives expected behavior). The formula is:

\begin{centerdisplay}
\[
\text{Suspiciousness}(l) = \frac{\text{Failed}(l) / \text{TotalFailed}}{\text{Failed}(l) / \text{TotalFailed} + \text{Passed}(l) / \text{TotalPassed}},
\] 
\end{centerdisplay}
\noindent where $\text{Failed}(l)$ is the number of times line $l$ was executed when the program failed, $\text{Passed}(l)$ is the number of times line $l$ was executed.  

Consider the following code:
\begin{lstlisting}
    def median(x, y, z):
        print("input ", x, y, z)    # line 1
        m = z                       # line 2
        if y < z:                   # line 3
            if x < y:               # line 4
                m = y               # line 5
            else if x < z:          # line 6
                m = y               # line 7, %bug, should be z
        else:                       # line 8
            if x > y:               # line 9
                m = z               # line 10, %bug, should be y
            else if (x > z):        # line 11
                m = x               # line 12 
        print("median is ", m)      # line 13
\end{lstlisting}


We now run the program on tests and collect the number of times each line was executed when the program failed and when it passed. 
For example, for a test \code{t1} with input \code{(3,3,5)}, the program passes (shows median is 3) and hits lines 1, 2, 3, 4, 6, 7, 13 and skips lines 5, 8, 9, 10, 11, 12. For a test \code{t9} with input \code{(5,4,2)}, the program fails (shows median is 2 instead of 4) and hits lines 1, 2, 3, 8, 9, 10, 13 and skips lines 4, 5, 6, 7, 11, 12. It is easy to see that every test will hit lines 1 and 13.  

After we do this for all tests (e.g., 10 tests \code{t1, t2, ..., t10}), we can compute the suspiciousness score for each line using the Tarantula formula. The higher the score, the more likely the line contains the bug.  The following table shows the number of times each line was executed when the program failed and when it ran correctly over several test runs. 
\begin{table}
    \caption{Statistical Debugging with Tarantula scoring metrics. `x` means the line was hit (executed) and `-` means it was skipped (not executed).}\label{tab:sd}
    \centering
    \scriptsize
    \begin{tabular}{c|c|c|c|c|c|c|c|c|c|c|c|c|c|c}
    \toprule
    line & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & Pass/Fail\\
    \midrule
    t1 (3,3,5)  & x & x & x & x & - & x & x & - & - & - & - & - & x & P\\
    t2 (1,2,3)  & x & x & x & x & x & - & - & - & - & - & - & - & x & P\\
    t3 (3,2,2)  & x & x & x & - & - & - & - & x & x & x & - & - & x & P\\
    t4 (5,5,5)  & x & x & x & - & - & - & - & x & x & - & x & - & x & P\\
    t5 (1,1,4)  & x & x & x & x & - & x & x & - & - & - & - & - & x & P\\
    t6 (5,3,4)  & x & x & x & x & - & x & - & - & - & - & - & - & x & P\\
    t7 (3,2,1)  & x & x & x & - & - & - & - & x & x & x & - & - & x & F\\
    t8 (2,1,3)  & x & x & x & x & - & x & x & - & - & - & - & - & x & F\\
    t9 (5,4,2)  & x & x & x & - & - & - & - & x & x & x & - & - & x & F\\
    t10 (5,2,6) & x & x & x & x & - & x & x & - & - & - & - & - & x & F\\
    \midrule
    Score (Tara)       & 0.5 & 0.5 & 0.5 & 0.42 & 0. & 0.5 & 0.6 & 0.6 & 0.6 & 0.75 & 0. & 0. & 0.5\\
    %Score (Ochi)  & 0.71 & 0.71 & 0.71 & 0.46 & 0. & 0.5 & 0.55 & 0.55 & 0.55 & 0.61 & 0. & 0. & 0.71\\
    \bottomrule
    \end{tabular}
\end{table}

We can now compute the suspiciousness score for each line using the Tarantula formula. Here we have 10 tests with 6 passing and 4 failing. 
For example, the suspiciousness score for line 4 is: $2/4 / (2/4 + 4/6) = 0.42$. The score for line 5 is $0/4 / (0/4 + 1/6) = 0$, i.e., this line is definitely not buggy. The score for line 7 is $2/4 / (2/4 + 2/6) = 0.6$, line 10 is $2/4 / (2/4 + 1/6) = 0.75$. 
Note that scores for lines 1 and line 13, which are always executed, are $4/4 / (4/4 + 6/6) = 0.5$. The score for line 12, which was not executed in any test runs, is 0. (if it never runs, it should not be responsible for any issue).


\subsection{In-class Exercise: Tarantula vs. Ochiai}

\emph{Ochiai} is another popular metrics for statistical debugging. Its formula is

\begin{centerdisplay}
\[
\text{Suspiciousness}(l) = \frac{\text{Failed}(l) / \text{TotalFailed}}{\sqrt{\text{Failed}(l) / \text{TotalFailed} + \text{Passed}(l) / \text{TotalPassed}}}
\]
\end{centerdisplay}


\begin{enumerate}
    \item Compute the Ochiai score for the lines in the table above.
    \item Explain the differences between Tarantula and Ochiai scores. Which one do you think is better? Why?
\end{enumerate}


\subsection{Delta Debugging (DD)}
While statistical debugging (\autoref{sec:statistical-debugging}) aims to localize faults in the code,  DD focuses on finding the smallest input that triggers the issue. DD aims to \emph{minimize} a \emph{failing} input  (e.g., causing the program to crash or producing some interesting behavior). It is useful for debugging and finding a simpler input that is still interesting. DD works by repeatedly splitting the input into smaller parts and checking if they still trigger the issue. When using DD, you will need to provide an \emph{oracle} that checks if the input $P$ is interesting (e.g., causing a crash). 

\paragraph{Example 1} \emph{Oracle}: program fails (is interesting) whenever input contains an asterisk (*). 
% \begin{enumerate}
% \item Input = abcdef*h (fails)
% \item Split into 2 parts: abcd/ef*h. Remove 1st: fails; remove 1st (abcd).
% \item Input = ef*h. (fails)
% \item Split into 2 parts: ef/*h.  Remove 1st part: fails; remove 1st (ef).
% \item Input = *h. (fails)
% \item Split into 2 parts: */h.  Remove 1st part: pass; remove 2nd:  fails; remove 2nd (h).
% \item Input = * (fails)
% \item Can no longer split input. Smallest failing input is *.
% \end{enumerate}

\begin{table}
    \caption{Delta Debugging Example 1.}\label{tab:dd1}
    \centering
    \small
    \begin{tabular}{|c|c|c|c|}
    \toprule
    &&\multicolumn{2}{c|}{Remove} \\
    Failing Input & Split & 1st & 2nd \\
    \midrule
    abcdef*h & abcd/ef*h & abcd: F & - \\
    ef*h & ef/*h & ef: F & - \\
    *h & */h & *: P & h: F \\
    * & - & - & - \\
    \bottomrule
    \end{tabular}
\end{table}

\autoref{tab:dd1} shows the steps of DD. First, we start with the original input \code{abcdef*h} and split it into two parts \code{abcd/ef*h}. Removing the first part \code{abcd} still fails, so we remove it. We then repeat DD on the new input \code{ef*h} and split it into two parts \code{ef/*h}. Removing \code{ef} still fails, so we remove it and have the new input \code{*h}, which is then split into \code{*/h}. Removing the first part \code{*} passes, so we keep it and remove the second part \code{h}, which fails and is removed. The new input is now \code{*}, which cannot be split further and is the smallest failing input.

This example does not show the case when the split results in all parts passing. In that case, DD would increase the split size (e.g., split into 4 parts instead of 2) and repeat the process.

\paragraph{Example 2} \emph{Oracle}: program fails whenever input contains two asterisks (**).

\begin{table}
    \caption{Delta Debugging Example 2.}\label{tab:dd2}
    \centering
    \small    
    \begin{tabular}{|c|c|c|c|}
        \toprule
        &&\multicolumn{2}{c|}{Remove} \\
        Failing Input & Split & 1st & 2nd\\
        \midrule
        *abcdef* & *abc / def* & *abc: P& def*: P\\
        *abcdef* & *a / bc / de / f* & *a: P& bc: F\\
        *adef* &  *ad / ef* & *a: P& ef*: P\\
        *adef* &  *a / de / f / * & *a: P& de: F\\
        *af* &  *a / f* & *a: P& f*: P\\
        *af* &  * / a / f / * & *: P& a: F\\
        *f* &  *f / * & *f: P& *: P\\
        *f* &  * / f / * & *: P& f: F\\
        ** &  * / * & *: P& *: P\\
        ** &  - &  - & - \\
        \bottomrule
    \end{tabular}
\end{table}

\autoref{tab:dd2} shows the steps. We first split the input \code{*abcdef*} into 2 parts, which both pass. Thus, we increase the granularity and split the input into 4 parts  \code{*a}, \code{bc}, \code{de}, \code{f*}.  Removing the 1st part result in a pass and so we keep it and try removing the 2nd part \code{bc}, which fails and thus we can remove \code{bc} to get the new input \code{*adef*}. This keeps going until we find the smallest failing input \code{**}. Note even when our failing input is \code{**}, we still continue applying DD to it as we did not know that it would be the smallest failing input.




% \begin{enumerate}
% \item Input = *abcdef* (fails)
% \item Split into 2 parts: *abc/def*. Remove 1st: passes; remove 2nd: passes. Cannot remove anything.
% \item Split into 4 parts: *a/bc/de/f*.  Remove 1st: passes; remove 2nd: fails; remove 2nd (bc).
% \item Input = *adef* (fails)
% \item Split into 2 parts: *ad/ef*. Remove 1st: passes; remove 2nd: passes. Cannot remove anything.
% \item Split into 4 parts: *a/de/f/*.  Remove 1st: passes; remove 2nd: fails; remove 2nd (de).
% \item Input = *af* (fails)
% \item Split into 2 parts: *a/f*. Remove 1st: passes; remove 2nd: passes. Cannot remove anything.
% \item Split into 4 parts: */a/f/*.  Remove 1st: passes; remove 2nd: fails; remove 2nd (a).
% \item Input = *f* (fails)
% \item Split into 2 parts: *f/*. Remove 1st: passes; remove 2nd: passes. Cannot remove anything.
% \item Split into 4 parts: */f/*.  Remove 1st: passes; remove 2nd: fails; remove 2nd (f).
% \item Input = ** (fails)
% \item Split into 2 parts: */*. Remove 1st part: passes; remove 2nd part: passes. Cannot remove anything.
% \item Cannot split further. Smallest failing input is **.
% \end{enumerate}

%\begin{table}
%    \caption{Delta Debugging (DD) Example 2.}
%    \centering
%    \begin{tabular}{c|c|c|c|c}
%    \toprule
%    Input & Split & 1st & 2nd & Result\\
%    \midrule
%    *abcdef* & *abc/def* & *abc & def* & P\\
%    *adef* & *ad/ef* & *ad & ef* & P\\
%    *af* & *a/f* & *a & f* & P\\
%    ** & */* & * & * & F\\
%    \bottomrule
%    \end{tabular}
%\end{table}

\subsection{In-class Exercise: Delta Debugging}
\begin{itemize}
    \item Apply DD to the input string \code{"*hello*world*"} to find the smallest failing input. The oracle is that the input fails whenever it contains \code{"oo"}.
    \item What is best-case complexity of DD? Give an example of an input that would take the most steps to find the smallest failing input.
    \item What is the worst-case complexity of DD? Give an example of an input that would take the most steps to find the smallest failing input.
\end{itemize}

\section{Exercises}

\subsection{Statistical Debugging: M Metrics}

The \textbf{M} metrics to compute the suspiciousness of a line $l$ is calculated as follows:
\begin{centerdisplay}
\[
\text{Suspiciousness}(l) = \frac{\text{Failed}(l)}{\text{Failed}(l) + \text{Passed}(l)}
\]
\end{centerdisplay}

Apply this metrics to compute the suspiciousness scores for the lines in \autoref{tab:sd}.

\subsection{Delta Debugging (DD) Implementation}
In this exercise you will implement the DD technique. Your DD will take an input string and an \emph \code{oracle} that decides if the input is interesting (e.g., has a bug) or not.
More specifically, \code{oracle(s:str)->bool} takes in a string \code{s} and returns T (\code{s} has a bug) or F (\code{s} has no bug).  The goal of your DD is to reduce the original input to become \emph{minimal} but is still \emph{interesting} (i.e., a minimal input that still has the bug).

\begin{itemize}
    \item You can be as creative as you want with your DD, however it must not run for too long (e.g., try to split the input in to parts that are power of 2 as discussed in class to reduce the input).
    \item You must provide \emph{two} examples (inputs) to demonstrate your DD:  1 example where the DD takes a reasonably short time (few iterations) and 1 example where the DD takes a long time (e.g., 50 or more iterations).  
    \item At each iteration, your DD should output the current input, its size, and whether it is interesting or not. You can also output the split number and parts, etc (the same way we did in class).
    \item \textbf{Code submission}: submit your DD code along with the examples you provided with a clear instructions and \emph{screenshots} on how to run your DD and expected output.
    \item \textbf{Short Report}: write a short report describing your DD implementation. Explain how it works, how you tested it, and the results. Also briefly explain the examples you provided and why some take longer than others.
\end{itemize}


\subsection{Hello SWE419}
\begin{itemize}
    \item Assume you're given a simple \code{hello SWE419} program in C
    \begin{lstlisting}[language=C]
    #include <stdio.h>
    int main() {
        printf("Hello SWE419!\n");
        return 0;
    }
    \end{lstlisting}
    and an \emph{oracle} that checks if the input C program is valid (compiles) and contains the word \code{SWE419}. If so, the oracle returns 0 (Fail) and 1 otherwise (Pass).
    \item Describe \emph{in words} how you would apply DD to obtain the minimal C program that fails the oracle.
    \begin{itemize}
        \item Show what you get at the end. That is, show the minimal C code that DD would return.  
        \item You \textbf{do not need} to show step by step like we did in class. Instead, just describe the steps you (the DD algorithm) would take to reduce the input,  e.g., \emph{``in the first step you split the program into two parts, then you remove the first part, run the oracle which fails/passes because ..., etc''}.
        \item Pay attention to the additional requirement of being a \emph{valid} C program (e.g., needs the \code{\#include <stdio.h>}, \code{int main()...} and \code{return 0} statements). 
    \end{itemize}    
\end{itemize}

\subsection{Symbolic Execution}\label{exercise:symbolic-execution}

Consider a simple function \code{f} below 

\begin{lstlisting}[language=C]
int f(int y) {
  ...
  z = y * 2;
  if (z == 12) {
    // L
    fail();
  } else {
    printf(``OK'');
  }
}
\end{lstlisting}

Use symbolic execution to compute the path condition (PC) and program state (PS) at location \code{L} (where the program fails). Then give an input that causes the program to fail at \code{L}.


%{tab:symbolic-execution}
%The DD algorithm is as follows:

% \begin{algorithm}[H]
%     \SetAlgoNlRelativeSize{-1}
%     \KwData{Input str $inp$}
%     \KwResult{Reduced input}
    
%     \SetKwFunction{Test}{oracle}
%     \SetKwFunction{Reset}{reset}
%     \SetKwFunction{Break}{break}
    
%     \Begin{
%         \If{\Test(inp)}{
%             \Return{inp} \;
%         }

%         $n \gets 2$ \;  % Initial granularity
%         \While{length(inp) $\geq 2$}{
%             $start \gets 0.0$ \;
%             $subset\_length \gets \frac{\text{length(inp)}}{n}$ \;
%             $some\_complement\_is\_failing \gets \text{False}$ \;
            
%             \While{start $<$ \text{length(inp)}}{
%                 $complement \gets inp[0:int(start)] + inp[int(start + subset\_length):]$ \;
    
%                 \If{! \Test(complement)}{
%                     $inp \gets complement$ \;
%                     $n \gets \max(n - 1, 2)$ \;
%                     $some\_complement\_is\_failing \gets \text{True}$ \;
%                     \Break \;
%                 }
    
%                 $start \gets start + subset\_length$ \;
%             }
    
%             \If{not $some\_complement\_is\_failing$}{
%                 \If{$n == \text{length(inp)}$}{
%                     \Break \;  % Stop if no reduction can be made
%                 }
%                 $n \gets \min(n \times 2, \text{length(inp)})$ \;
%             }
%         }
%         \Return{inp} \;
%     }
%     \caption{Delta Debugging Algorithm}
%     \end{algorithm}

% DD reduces an input but still preserves its /interestingness/ as specified by an
% /oracle/ (e.g., it crashes, or does something interesting). For example,
% your DD program can take as input a C program (e.g., \code{myfile.c}) and an
% oracle in a form of a test script that defines interestingness (e.g., a
% \code{test.sh} that takes as input a C file, compiles and runs it, and
% returns =0= if it is interesting and =1= if it is not). Your program
% will apply DD to obtain a minimal version of =myfile.c= that is still
% interesting.

% As with the previous assignment, you can use any language for this
% assignment, but your program must run on the CSE machine (where I will
% evaluate your submission). So do not use external libraries or any extra
% tools etc. You are also strongly encouraged to use Python as it makes
% various string manipulation tasks easy.

% For this assignment, you must /work alone/. However, you are allowed to
% talk to others (e.g., discussing problems, work on the ideas together),
% but the implementation and submission must be done individually. If you
% are stuck, you can post your question as a discussion on Canvas or
% approach me.

% ** Specification
%    :PROPERTIES:
%    :CUSTOM_ID: specification
%    :END:
% *High level algorithm:* You will implement a DD algorithm that we
% discussed in class. Recall that a DD works something like below



% You can be as creative as you want, but your DD must not run for too
% long and, most importantly, must show progress (e.g., after each
% splitting, either you decide that an individual part does help (and
% further split that part) or no part helps and further split) and must
% not take up too much space (e.g., do not generate over 50MB of files).

% ** Example 1
%    :PROPERTIES:
%    :CUSTOM_ID: example-1
%    :END:
% \paragraph{Example}
% We consider the following C program, which modifies the integer $a$, \emph{interesting} as long as the value of $a$ is $\ge 3$ at the end (outputs ``correct''). The below \code{testscript.sh} oracle checks if the output contains the word \code{correct} and returns 0 if it does and 1 otherwise.
% We will use DD to remove unnecessary statements so that we have a minimal program that is smaller and easier to understand but still preserves the condition $a \ge 3$.

% \begin{lstlisting}[language=C]
%   // a simple program to be reduced
%   #include <stdio.h>
%   int main(int argc, char **argv) {
%       int a = 0;
%       printf("Hello, World!\n");
%       a++;
%       a--;
%       a+=2;
%       a++;
%       a--;
%       a++;
%       if (a >= 3){
%         printf("correct\n");
%       }
%       return 0;
% \end{lstlisting}
% \begin{lstlisting}[language=script]
%   # hello1.test
%   oracle/testscript defining interestingness

%   #!/bin/bash
%   # -*-sh-*-
%   if gcc -o a.out $1 \&> cmp_out; then
%       if ./a.out \&> run_out; then
%           if grep "correct" run_out; then
%               echo "0"              \# interesting
%               exit 0;
%           fi
%       fi
%   fi
%   echo "1"                         \# not interesting
%   exit 1;
% \end{lstlisting}
% - This is a simple oracle or test scripts =hello1.sh= that takes as
%   input a C program, compiles, and runs it. Then the test script checks
%   if the result contains the word ="correct"= and if so returns =0= to
%   indicate interesting (and returns =1= otherwise).

% #+begin_example

% #+end_example

% #+begin_src shell
%   # running DD
%   $ > python vdd.py  hello1.c -test hello1.test
%   preprocessing .. rm 1 idxs: [16]
%   can delete 2 chunks containing 2 idxs: [0, 1]
%   can delete 1 chunks containing 1 idxs: [2]
%   can delete 1 chunks containing 1 idxs: [5]
%   can delete 2 chunks containing 2 idxs: [6, 7]
%   can delete 2 chunks containing 2 idxs: [10, 11]
%   can delete 1 chunks containing 1 idxs: [15]
%   can delete 6 chunks containing 9 idxs: [0, 1, 2, 5, 6, 7, 10, 11, 15]
%   can delete 1 chunks containing 9 idxs: [0, 1, 2, 5, 6, 7, 10, 11, 15]
%   done: '/Users/tnguyen/git/projects/vdd/src/min.c' (lines: total 8 rem 9, 29 created variants)
% #+end_src

% #+begin_src C
%   // min.c: reduced program
%   int main(int argc, char **argv) {
%       int a = 0;
%       a+=2;
%       a++;
%       if (a >= 3){
%         printf("correct\n");
%       }
%   }
% #+end_src

% ** Example 2
%    :PROPERTIES:
%    :CUSTOM_ID: example-2
%    :END:

% - DD is useful for various tasks. We just need to provide an oracle to
%   decide if the input is interesting or not. Below is another example
%   where interestingness is defined if the input text file contains a
%   line that has the word =redo=

% - Input: [[file:file.txt]]

% - Oracle:

% #+begin_example
%   #!/bin/bash
%   # -*-sh-*-
%   if grep "redo" $1; then
%       echo "0"                 # Success.
%       exit 0;
%   fi
%   echo "1"                      # Failure.
%   exit 1;
% #+end_example

% #+begin_example
%   > python vdd.py  file.txt -test test.sh
%   preprocessing .. rm 21 idxs: [6 18 23 25 26 28 59 61 65 67 71 73 88 90 104 106 108 112 113 114 118]
%   can delete 25 chunks containing 25 idxs: [0, 1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20, 21, 22, 24, 27, 29, 30]
%   can delete 12 chunks containing 12 idxs: [31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42]
%   can delete 6 chunks containing 6 idxs: [43, 44, 45, 46, 47, 48]
%   can delete 3 chunks containing 3 idxs: [49, 50, 51]
%   can delete 2 chunks containing 2 idxs: [52, 53]
%   can delete 1 chunks containing 1 idxs: [54]
%   can delete 50 chunks containing 50 idxs: [56, 57, 58, 60, 62, 63, 64, 66, 68, 69, 70, 72, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 89, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 105, 107, 109, 110, 111, 115, 116, 117, 119, 120]
%   can delete 7 chunks containing 99 idxs: [0, 1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20, 21, 22, 24, 27, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 56, 57, 58, 60, 62, 63, 64, 66, 68, 69, 70, 72, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 89, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 105, 107, 109, 110, 111, 115, 116, 117, 119, 120]
%   can delete 1 chunks containing 99 idxs: [0, 1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20, 21, 22, 24, 27, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 56, 57, 58, 60, 62, 63, 64, 66, 68, 69, 70, 72, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 89, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 105, 107, 109, 110, 111, 115, 116, 117, 119, 120]
%   done: '/Users/tnguyen/git/projects/vdd/src/min.txt' (lines: total 1 rem 99, 17 created variants)
% #+end_example

% ** Output
%    :PROPERTIES:
%    :CUSTOM_ID: output
%    :END:
% As shown in the examples, at the end, the program will output

% 1. =done:=, follows by
% 2. the location of the resulting file =rfile=
% 3. total number of lines of =rfile= (note, it doesn't have to be exact)
% 4. the lines removed (i.e., how many lines were you able to remove from
%    the original file)
% 5. any additional information you find interesting (but don't output too
%    much)
% 6. the total runtime in seconds

% Also, the program will output some information whenever it makes
% progress (i.e., able to reduce/delete parts of code, how much was
% deleted, etc). Examples are given above, but you do not need to print
% the exact information shown in the examples (e.g., =chunks=, =idxs= etc)

% As usual, use the =README= to tell me exactly how to compile/run your
% program, e.g., =python3 dd.exe file.C test.sh= or =gcc dd.c -o dd.exe=
% and =./dd.exe file.c test.sh=. Again, make sure that your code works on
% the CSE machine and do not hard code anything specific to your account.

\begin{lstlisting}

\end{lstlisting}

% \section{Defensive Programming}
% \section{Error Handling}



\chapter{Concurrency}\label{chap:concurrency}


\begin{table}
    \caption{Threads vs. Processes}\label{tab:threads-vs-processes}
    \small
    \centering
    \begin{tabular}{l|l|l}
    \toprule
    &\textbf{Threads} & \textbf{Processes} \\
    \midrule
    Memory & Sharing memory & Not sharing memory\\
    Communication & Easier, since sharing memory & Harder, because running in isolation \\
    Concurrency Type & Interleaved & Parallel \\
    Overhead & Lightweight & Heavyweight\\
    Use & For lightweight tasks & For heavy, isolated tasks \\
    \bottomrule
    \end{tabular}
\end{table}


\section{Processes}\label{sec:processes}
A process is an independent instance of a program and does not share memory and data with other processes. While incurring higher overhead, processes do not have synchronization issues such as race conditions and makes parallelism safer. In a multicore system, processes would achieve true parallelism as they can run on different cores. 

In Python we use \code{multiprocessing} to create and manage processes. The following demonstrates using \code{multiprocessing.Processes} to run two functions in parallel. It also uses \code{multiprocessing.Queue} to simulate a shared variable.

\begin{lstlisting}[multicols=2]
from multiprocessing import Process, Queue
import time


def square(numbers:list, queue:Queue):
    ct = 0
    for n in numbers:
        time.sleep(1)
        print(f"Square of {n}: {n*n}")
        ct += 1
    queue.put(ct)


def cube(numbers:list, queue: Queue):
    ct = 0
    for n in numbers:
        time.sleep(1)
        print(f"Cube of {n}: {n*n*n}")
        ct += 1
    queue.put(ct)

if __name__ == "__main__":
    numbers = [2, 3, 4, 5]

    queue = Queue()
    # Create processes
    process1 = Process(
        target=square,args=(numbers,queue))
    process2 = Process(
        target=cube,args=(numbers,queue))

    # Run processes (in parallel)
    process1.start(); process2.start()

    # Wait for both processes to finish
    process1.join(); process2.join()

    # Combine the counts from both processes
    total_ct = 0
    while not queue.empty():
        total_ct += queue.get()

    print("Count : ", total_ct)
\end{lstlisting}

\section{Threading}\label{sec:threads}

%TODO: explain about daemon, thread join, example here  https://realpython.com/intro-to-python-threading/
%TODO: show example of deadlock
%TODO: easier to just use a single example with Producer Consumer,  



A thread runs within a process and shares memory and data as other threads in the process. Thus threads are lightweight with low overhead, but can face synchronization issues like race conditions when multiple threads access shared data.

In Python we use the \code{threading} module to create and manage threads. The following demonstrates the use of \code{threading.Thread} to run tasks in parallel. 

This example also uses \code{threading.lock} for mutual exclusion to ensure only one thread can access and modify the shared variable at a time.

%\lstinputlisting[firstline=300,lastline=500]{file.cc}
\lstinputlisting[multicols=2]{code/thread1.py}

\subsection{Join}
The \code{join()} method, which appears in Python, Java, and many other languages, is used to wait for a thread to complete. Calling \code{t.join()} blocks the parent (calling) thread until the thread \code{t} is terminated. 

The example above uses \code{thread1.join()} and \code{thread2.join()} to wait for both threads to complete before printing the final count.
If we do not use \code{join()}, the calling thread may print the count before the threads are done, leading to incorrect count.

\subsection{Daemon Threads}

When a program create (regular) threads, the program will wait for them to complete before exiting. (Note not to be confused with \code{join()} which blocks the calling thread until the target thread completes). However, if we want the program to exit even if the threads are not finished, we can use \emph{daemon threads}. This type of threads run in the background and do not block the program from exiting. Instead, when the program exits, daemon threads are automatically terminated or killed.

\lstinputlisting[multicols=2]{code/daemon.py}

This example demonstrates the difference between daemon and non-daemon (regular) threads. The program will wait for the regular thread to finish (i.e., print 0 to 4) before printing \code{"Done"}. However, the daemon thread will run indefinitely in the background but will be terminated immediately the program exits.

\section{Locks, Semaphores, and Monitors}

Locks, semaphores, and monitors are key synchronization concepts in multithreading. They help manage shared resources and prevent synchronization issues such as race conditions and deadlocks. 

% \begin{table}
%     \caption{Locks, Semaphores, and Monitors}\label{tab:sync}
%     \footnotesize
%     \centering
% \begin{tabular}{l|l|l|l}
% \toprule
% & \textbf{Locks} & \textbf{Semaphores} & \textbf{Monitors} \\
% \midrule
% \textbf{Purpose} & Protect critical sections & Control access to resources & Combine data and synchronization \\
% \textbf{Operations} & Acquire and release & Wait and signal & Encapsulate data and synchronization \\
% \textbf{Mutual Exclusion} & One thread & Multiple threads (using a counter) & One thread \\
% \end{tabular}
% \end{table}

\subsection{Locks}\label{sec:locks}
A \emph{race condition} occurs when two or more threads try to change a shared resource at the same time, leading to unpredictable results (e.g., consider a shared counter and two threads incrementing it at the same time like the example in \autoref{sec:threads}).
\emph{Locking} the shared resource is a simple mechanism to avoid race condition. It works by allowing a thread $t$ to acquire the \emph{lock} and proceed if the lock is available; otherwise, $t$ waits until the lock is released.  After $t$ is done, it releases the lock. The code that needs to be protected (between lock acquire and release) is called a \emph{critical section}.
The example in \autoref{sec:threads} uses a lock to protect the critical section modifying \code{shared\_ct}. 

Thus, locks are ideal \emph{when only one} thread should access a shared resource at a time. Because of this limitation, locks are efficient and simple to use. However, improper use of locks can lead to \emph{deadlocks} and \emph{live locks} describe below.

\subsubsection{Deadlock} 

Deadlock occurs when two threads are stuck waiting for each other to release a lock. This happens when a thread acquires a lock and waits for another lock, while another thread acquires the second lock and waits for the first lock. 

\begin{lstlisting}[multicols=2]
from threading import Thread, Lock
import time

lock1 = Lock(); lock2 = Lock()

def t1_job():
    print("T1: Want Lock 1...")
    with lock1:
        print("T1: Got Lock 1.")
        time.sleep(1) 
        print("T1: Want Lock 2...")
        with lock2:
            print("T 1: Got Lock 2.")

def t2_job():
    print("T2: Want Lock 2...")
    with lock2:
        print("T2: Got Lock 2.")
        time.sleep(1)  # Simulate some work

        print("T2: Want Lock 1...")
        with lock1:
            print("T 2: Got Lock 1.")

if __name__ == "__main__":
    t1 = Thread(target=t1_job)
    t2 = Thread(target=t2_job)
    t1.start(); t2.start()
    t1.join(); t2.join()
    print("Done.")
\end{lstlisting}

This example demonstrates a deadlock. Thread 1 acquires lock 1 and waits for lock 2, while thread 2 acquires lock 2 and waits for lock 1. This leads to a deadlock because both threads are stuck waiting for each other to release the lock.

\subsubsection{Live Lock}
In live lock,  threads are not blocked but cannot make progress. In constrast to a deadlock, which each thread is greedy and does not release the lock, a \emph{live lock} occurs when threads are too \emph{polite} and keep releasing the lock. Imagine two pedestrians trying to pass each other in a narrow corridor. If both keep stepping aside to let the other pass, they will keep stepping aside and never pass each other.

\begin{lstlisting}[multicols=2]
from threading import Thread, Lock
import time

lock1 = Lock(); lock2 = Lock()

def t1_job():
    while True:
        print("T1: Want Lock 1...")
        with lock1:
            print("T1: Got Lock 1.")
            time.sleep(1) 
            print("T1: Want Lock 2...")
            if not lock2.acquire(timeout=1):
                print("T1: Released Lock 1.")
                continue # release lock 1 and try again

            print("T1: Got Lock 2.")
            break # got both lock

def t2_job():
    while True:
        print("T2: Want Lock 2...")
        with lock2:
            print("T2: Got Lock 2.")
            time.sleep(1)  # Simulate some work
            print("T2: Want Lock 1...")
            if not lock1.acquire(timeout=1):
                print("T2: Released Lock 2.")
                continue # release lock 2 and try again
            
            print("T2: Got Lock 1.")
            break # got both lock

if __name__ == "__main__":
    t1 = Thread(target=t1_job)
    t2 = Thread(target=t2_job)
    t1.start(); t2.start()
    t1.join(); t2.join()
    print("Done.")
\end{lstlisting}

This example demonstrates live lock. Similar to the deadlock example above, both threads want to get both locks. However, here if a thread cannot acquire a lock, it releases the lock it's holding and tries again. This leads to a live lock where both threads keep releasing the lock and trying again, but neither can get both locks to make progress.


\subsubsection{Starvation} 

This occurs when a thread $t$ cannot access a shared resource $r$ because other threads are continuously accessing it. This can happen when $t$ has lower priority or much faster than other threads. This is different than deadlock and live lock as other (non-starving) threads are still making progress.

% \lstinputlisting[multicols=2]{code/starvation.py}
% hard to find a good example
% In this example, the \code{higher\_priority} thread hogs the lock and starves the \code{lower\_priority} thread from accessing the lock. 

\subsection{Semaphores}\label{sec:semaphores}

Semaphores are more flexible than locks as they allow \emph{multiple} threads to simulateously access a shared resource.  Semaphores maintain a \emph{counter} to track the number of threads that can access the resource.  When a thread $t$ wants to access a resource $r$, it checks the counter $n$. If $n > 0$, $t$ decrements $n$ and proceeds to \emph{acquire} $r$. If $n=0$, $t$ waits until $n$ is incremented. When $t$ is done, it increments $n$ to indicate that it \emph{releases} $r$. Note that when $n>1$, we have a \emph{counting semaphore}, and when $n=1$, we have a \emph{binary semaphore}, which behaves like a lock.

Semaphores are thus useful when multiple threads need to  access a shared resource. However, they too can lead to deadlocks when threads are waiting for each other to release a semaphore.

In Python, we use \code{Semaphore} in \code{threading} for semaphores. For the example in \autoref{sec:threads}, we can replace \code{lock = Lock()} with a binary semaphore: \code{sem = Semaphore(1)}. Observe that the semaphore is initialized with 1 to behave like a lock and ensure proper mutual exclusion. If we initialized with 2 then race condition could occur as both threads can access and modify \code{shared\_ct} simultaneously.


\subsection{Monitors}\label{sec:monitors}

This synchronization mechanism combines lock with communication capability.  It allows threads to wait for a condition to be true and notify other threads when the condition changes. Java implements monitors natively. Python however does not have built-in monitors, but we can use \code{threading.Condition} to simulate monitors as follows. 

As shown in \autoref{ex:producer-consumer-lock} the classical ``producer-consumer'' problem has an issue with the consumer trying to consume from an empty buffer using a \code{lock}. This can be solved using a monitor (\code{lock = threading.Condition()}), as shown in \autoref{ex:producer-consumer-monitor}, which ensures that the consumer stops consuming and waits when the buf is empty, and producer notifies consumer when it adds an item to the buf.


\begin{figure}
\begin{lstlisting}[multicols=2]
import threading
import time
import random


queue = []
lock = threading.Lock()    
class ProducerThread(threading.Thread):
    def run(self):
        global queue
        while True:
            num = random.choice(range(10)) 
            lock.acquire()
            queue.append(num)
            print("Produced", num)
            lock.release()
            time.sleep(random.random())


class ConsumerThread(threading.Thread):
    def run(self):
        global queue
        while True:
            lock.acquire()
            if not queue:
                print("Nothing in queue, "
                    "consumer fails")
            num = queue.pop(0)
            print("Consumed", num)
            lock.release()
            time.sleep(random.random())

if __name__ == "__main__":
    # start the threads
    ProducerThread().start()
    ConsumerThread().start()
\end{lstlisting}
\caption{Producer-Consumer Problem using Lock (has issue)}\label{ex:producer-consumer-lock}
\end{figure}


\begin{figure}
\begin{lstlisting}[multicols=2]
import threading
import time
import random


queue = []
lock = threading.Condition()    
class ProducerThread(threading.Thread):
    def run(self):
        global queue
        while True:
            num = random.choice(range(10)) 
            lock.acquire()
            queue.append(num)
            print("Produced", num)
            lock.notify()
            lock.release()
            time.sleep(random.random())


class ConsumerThread(threading.Thread):
    def run(self):
        global queue
        while True:
            lock.acquire()
            if not queue:
                print("Nothing in queue, "
                    "consumer waits (instead of fail)")
                lock.wait()
                print("Producer added to queue,"
                      "consumer continues")
            num = queue.pop(0)
            print("Consumed", num)
            lock.release()
            time.sleep(random.random())

if __name__ == "__main__":
    # start the threads
    ProducerThread().start()
    ConsumerThread().start()
\end{lstlisting}
\caption{Producer-Consumer Problem using Monitors (fix issue)}\label{ex:producer-consumer-monitor}
\end{figure}


\paragraph{History} The concept of semaphore was due to \emph{Edsger Dijkstra} in the early 60s when he was working on the THE multiprogramming system. The name \emph{``semaphore''} might have been inspired by the railway signals that control the traffic of trains.



%\section{Asynchronous Programming}\label{sec:async}
%Asynchronous programming is a way to run multiple tasks concurrently without blocking the main thread. It is useful for I/O-bound tasks (e.g., reading files, network requests) where the main thread can continue to do other work while waiting for the I/O tasks to complete. 

%In Python, we use the \code{asyncio} module to create and manage asynchronous tasks. The following demonstrates how to use \code{asyncio} to read multiple files concurrently.

\section{Exercises}
\subsection{Benefits of Threads and Processes over Sequential Execution}\label{ex:threads-and-processes-vs-sequential}

This assignment introduces you to threads and processes and their benefits over sequential execution.  Assuming you have a long-running task (e.g., a function that sleeps for 1 second) as follows: 

\begin{lstlisting}
def do_something(n):
    time.sleep(1)  # Simulate a long-running task
    print(f"Processed {n}")
\end{lstlisting}

Now create 3 methods to process a list of numbers (e.g., \code{[1, 2, 3, 4, 5]}) by invoking \code{do\_something} for each number. 
\begin{enumerate}
    \item A regular approach that processes each number sequentially.
    \item A multithreaded approach using the \code{threading} module, i.e., create a thread for every \code{do\_something} call.
    \item A multiprocessing approach using the \code{multiprocessing} module, i.e., create a process for every \code{do\_something} call.
\end{enumerate}
Time each method and compare them. You should see that the multithread and multiprocess versions run a lot faster than the regular one.
Note that in this exercise there is no shared resource so you do not need to worry about race conditions or having to use locks. 

% You will implement the following task 
% Task Description

% You will implement a program that defines a function called do_something, which simulates a long-running computation. You will then create three versions of a function to process a list of numbers using:

% 	1.	A regular synchronous approach.
% 	2.	A multithreaded approach using the threading module.
% 	3.	A multiprocessing approach using the multiprocessing module.

% Instructions

% 	1.	Define the do_something Function:
% 	•	Create a function do_something(n) that simulates a long-running task by sleeping for a fixed duration (e.g., 1 second) and then prints a message indicating the number being processed.

\subsection{Threads and Processes: Election Simulation}
We will simulate the election process with threads and processes. We have multiple voters (threads) casting their votes for candidates, and election officials (processes) tallying the votes. We will use locks to manage access to the vote count and semaphores to limit the number of people that can vote simultaneously.

More specifically, we will implement the following: 
\begin{enumerate}
\item \code{Election} class: manage the voting and maintain the vote count:
\begin{itemize}
    \item var \code{votes:dict}: store the vote count for each candidate (e.g., \code{votes} = \{`Alice': 1, `Bob': 2, `Charlie': 5\}).
    \item var \code{lock:threading.Lock}: protect access to the vote count
    \item method \code{cast(who:str)}: cast a vote for a candidate, e.g., \code{cast(`John')} will increment \code{votes[`John']}.
    \item method \code{tally()}: to display the current vote count. 
    \item Both \code{cast} and \code{tally} need to lock \code{votes} before accessing it
\end{itemize}
\item \code{Voter(threading.Thread)} class: represent a voter who can vote for a candidate:
\begin{itemize}
    \item Constructor method \code{\_\_init\_\_(name:str, election:Election)}: initialize the voter's name and the election.
    \item var \code{semmaphore:threading.Semaphore}: control the number of voters that can vote simultaneously (e.g., 3 at a time).
    \item Method \code{vote()}: pick a candidate (\code{random.choice(election.votes.keys())}) and call \code{election.cast(candidate)}. Note that before casting the vote, you will need to acquire (\code{semaphore.acquire()}) the semaphore and release it after voting (\code{semaphore.release()}).
\end{itemize}
\item \code{Officials(threading.Thread)} class: represent an election official who will periodically tally and display the votes.
\begin{itemize}
    \item Constructor method \code{\_\_init\_\_(election:Election)}: storing the election object.
    \item Method \code{tally()}: call \code{election.tally()} to display the current vote count.
\end{itemize}
\item \code{\_\_main\_\_}: the main/driver code to run the simulation.
    \begin{itemize}
        \item Create a semaphore that allows 3 voters to vote simultaneously.
        \item Create 20 voters and 4 officials.
        \item Start the voters and officials using \code{start()} and wait for them to finish using \code{join()}.
    \end{itemize}
\end{enumerate}

\subsection{Main Concepts of Concurrency}\label{sec:concurrency-concepts}

Short questions or Compare and contrast (if applicable also discuss the benefits and drawbacks of each) 
\begin{itemize}
    \item Threads and processes. When would you use one over the other?
    \item Locks, Semaphores, and Monitors
    \item Deadlock and Live lock
    \item What is a race condition? How to prevent it?
\end{itemize}
\chapter{Program Verification}\label{chap:verification}

In chapter \autoref{chapter:testing} we focus on testing to find bugs. Here we look at \emph{verification} techniques to prove the absense of bugs. Like whitebox approaches (\autoref{sec:symbolic-execution}), verification techniques analyze program source code to reason about its behaviors. 

%verification techniques complement testing and can do more thorough analysis.

\section{Hoare Logic}
%a display box in latex showing hoare tripple 
\subsection{Hoare Tripple}

A formal way to specify and verify program $S$ with respect to its specification consisting of the precondition $P$ and postcondition $Q$ is using \emph{Hoare logic}. The main idea in this logic is its \emph{Hoare Tripple}:

\begin{center}
\begin{tcolorbox}[colframe=green!50!black, colback=gray!5!white, boxrule=0.5mm, width=0.5\textwidth, sharp corners]
    \[
    \{ P \} \; \text{S} \; \{ Q \}, 
    \]
\end{tcolorbox}
\end{center}

\noindent which reads: assuming $P$ holds before executing $S$, and $S$ is executed successfully, then $Q$  holds.  If this is true, we say that the Hoare Tripple is \emph{valid}, indicating $S$ satisfies the specification $P, Q$. 
Note that $S$ is represented as a single statement or a sequence of statements, and $P, Q$ are logical expressions or formulae.      

For example, the Hoare Triple 
      \texttt{\{x\ =\ 5\ and\ y\ \textgreater{}\ 2\}\ z\ :=\ x\ +\ y;\ z\ :=\ z\ +\ 2\ \{z\ \textgreater{}\ 9\}} is valid because 
      assuming \texttt{x=5\ and\ y\ \textgreater{}\ 2}, if
      \texttt{z:x\ +y;\ z\ :=\ z\ +\ 2} runs successfully, then we do have
      \texttt{z\ \textgreater{}\ 9}.



\paragraph{Partial and Total Correctness} Observe that a Hoare Tripple specifies the program post condition behaviors \emph{only when} it terminates successfully. This is known as \emph{partial correctness}, which requires the program to satisfy the postcondition \emph{assuming} it terminates. In contrast, \emph{total correctness} \emph{requires} the program to terminate and satisfy the postcondition. 
For Hoare logic, we focus on partial correctness as it is easier to prove.  Total correctness would require showing program termination, an undecidable problem in general.  


    
\paragraph{Examples}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Consider a program \texttt{S} with a single assignment statement
  \texttt{x:=5}.

  The Hoare tripple
  \texttt{\{True\}\ x\ :=\ 5\ \{x\ \textgreater{}\ 6\}} is \emph{not} a
  valid tripple, but these ones are:

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \texttt{\{True\}\ x\ :=\ 5\ \{x=5\ or\ x=\ 6\ or\ x\ \textgreater{}\ 6\}}
  \item
    \texttt{\{True\}\ x\ :=\ 5\ \{x\ \textgreater{}\ 1\}}
  \item
    \texttt{\{True\}\ x\ :=\ 5\ \{x\ =\ 5\}}
  \end{enumerate}

  Moreover, the postcondition in \texttt{x=5} is \textbf{strongest}
  because it is more precise than \texttt{x\ \textgreater{}\ 1} and
  \texttt{(x=5\ or\ x=6\ or\ x\ \textgreater{}\ 6)}. In general we want the strongest (most precise) postcondition (\autoref{sec:strongest-postconditions}).
\item
  Consider another program \texttt{z:=\ x/y}.

  These are valid Hoare tripples:

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \item
    \texttt{\{x\ =\ 1\ \&\ y\ =\ 2\}\ z:=\ x/y\ \ \{z\ \textless{}\ 1\}}
  \item
    \texttt{\{x\ =\ 2\ \&\ y\ =\ 4\}\ z:=\ x/y\ \{z\ \textless{}1\}}
  \item
    \texttt{\{0\ \textless{}\ x\ \textless{}\ y\ \&\ y\ !=\ 0\}\ z:=\ x/y\ \{z\ \textless{}1\}}
  \end{enumerate}

  Moreover, the precondition
  \texttt{0\ \textless{}\ x\ \textless{}\ y\ \&\ y\ !=\ 0} is the
  \textbf{weakest} precondition (i.e., it is the least constraint precondition). In general we want the weakest precondition (\autoref{sec:weakest-preconditions}).

  \item Below are all invalid:

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  
  \item
    \texttt{\{x\ \textless{}\ y\}\ z:=\ x/y\ \ \{z\ \textless{}\ 1\}}
    (counterexample input x=-1, y=0, after executing z:=x/y, we do not
    have z \textless{} 1 and instead got a div-by-0 exception)
  \item
    \texttt{\{x\ =\ 0\}\ z:=\ x/y\ \ \{z\ \textless{}\ 1\}}
    (counterexample input x=0, y=0)
  \item
    \texttt{\{y\ !=\ 0\}\ z:=\ x/y\ \ \{z\ \textless{}\ 1\}}
    (counterexample input x=2 , y=1)
  \item
    \texttt{\{x\ \textless{}\ y\ \&\ y\ !=\ 0\}\ z:=\ x/y\ \{z\ \textless{}1\}}
    (counterexample input x=-2, y=-1)
  \end{enumerate}
\end{enumerate}


\subsection{Verifying Programs using Hoare Logic}\label{sec:verification-hoare}

We can automatically verify (partial) program correctness by computing the \emph{weakest precondition} (WP), which is the least restrictive condition that ensures the postcondition after executing the program. Mores specifically, to prove the Hoare Tripple \texttt{\{P\}\ S\ \{Q\}} is
valid, i.e., to prove the program \texttt{S} is correct wrt to the
precondition \texttt{P} and postcondition \texttt{Q}, we form a
\textbf{verification condition} \texttt{P\ =\textgreater{}\ wp(S,\ Q)}
and check that it is valid. Here, the function \textbf{wp} returns the
\textbf{weakest precondition} (WP) allowing the program \texttt{S} to
achieve the postcondition \texttt{Q}. Thus, to show the validity of
\texttt{\{P\}\ S\ \{Q\}}, we show that \texttt{P} implies
(\texttt{=\textgreater{}}) the WP of \texttt{S} wrt to $Q$.

\subsection{Computing Weakest Preconditions}\label{computing-weakest-preconditions}

The WP is computed by working backwards from the postcondition $Q$ to the precondition $P$ using the program $S$. \autoref{tab:wp} defines 
the rules for computing the WP of common program statements (e.g., assignment, sequence, conditional, and while loop).
\begin{table}
    \caption{Weakest Precondition Rules.}\label{tab:wp}
    \centering
    \small
\begin{tabular}{l|l|l|l}
\textbf{Statement} & \texttt{S} & $\texttt{wp}(S,Q)$ & Notes\\
\midrule
Assignment & \texttt{x:=E} & \texttt{Q[E/x]} & Replace all \texttt{x}'s with \texttt{E} in \texttt{Q} \\
\midrule
Sequence & \texttt{S1; S2} & $\texttt{wp}(S1, \texttt{wp}(S2, Q))$ & Recursively compute wp\\
\midrule
Conditional & \texttt{if b then S1 else S2} & $b \implies \texttt{wp}(S1,Q)~\land$ & Produce disjunction\\
  & & $\overline{b} \implies \texttt{wp}(S2,Q)$ &\\
\midrule
While & \texttt{while b do S} & $I ~\land $ & User supplied loop inv $I$\\
&& $I \land b \implies \texttt{wp}(S, I) ~\land$ &\\ 
&& $I \land \overline{b} \implies Q$ &\\ 
\bottomrule
\end{tabular}
\end{table}

\paragraph{Assignment} The popular \emph{assignment} \texttt{x\ :=\ $E$} statement assigns the expression
$E$ to a variable \texttt{x}. The WP of an assignment \texttt{wp(x:=E,Q)} is obtained by substituting all occurrences of
\texttt{x} in \texttt{Q} with the expression \texttt{E}. 

\begin{equation}\label{eq:wp-assign}
    \texttt{wp(x:=E, Q)} = Q[x/E]
\end{equation}

\paragraph{Examples}
\begin{enumerate}
\item      
\begin{equation*}
    \begin{split}
        \texttt{WP}(x:=3, x + y = 10) &= 3 + y = 10\\ 
        &= y = 7
    \end{split}
\end{equation*}

Thus, we have $\{y=7\} ~x := 3~ \{x + y = 10\}$

\item 
\begin{equation*}
    \begin{split}
 \texttt{WP}(x:=3, x + y > 0) &= 3 + y > 0  \\
 &= y > -3\\
    \end{split}
\end{equation*}


Thus, we have $\{y > -3\}  ~x := 3~ \{x + y> 0\}$

\item 
\begin{equation*}
    \begin{split}
        \texttt{WP}(x:=3, y > 0) &= y > 0 \text{ \# no x in y > 0, so result is just y > 0}\\
    \end{split}    
\end{equation*}

Thus, we have $\{y > 0\}  x := 3 \{y > 0\}$
\end{enumerate}


\paragraph{List of Statements}\label{list-of-statements}

The WP for a list (sequence or block) of statements is defined \emph{recursively} as the WP of the first statement followed by the WP of the rest of the statements.  

\begin{align}\label{eq:wp-sequence}
    \texttt{wp}(S1; S2, Q) &= \texttt{wp}(S1, \texttt{wp}(S2, Q))\\
    \texttt{wp}([], Q) &= Q
\end{align}

%
\paragraph{Examples}

\begin{equation*}
\begin{split}
    \texttt{wp}([x:=x+1; y:=y*x], y=2*z) &= \texttt{wp}  (x:=x+1, \texttt{wp}([y:=y*x], y=2*z))\\
    &= \texttt{wp}(x:=x+1, y*x=2*z)\\
    &= y*(x+1)=2*z
\end{split}
\end{equation*}


Thus, we have $\{y*(x+1)=2*z\} ~ x:=x+1; y:=y*x ~ \{y=2*z\}$

\subsubsection{Conditional}\label{conditional}

The WP of a conditional statement combines the WPs of the two branches using the implication operator $\implies$. 

\begin{equation}\label{eq:wp-conditional}
\texttt{wp}(\texttt{if}~b~\texttt{then}~S1~\texttt{else}~S2, Q)  =  (b \implies \texttt{wp}(S1,Q))  \land  (\neg b \implies \texttt{wp}(S2, Q))
\end{equation}

\paragraph{Examples}

\begin{itemize}
    \item 
\begin{equation*}
\begin{split}
& \texttt{wp}(\text{if} ~x > 0~ \texttt{then} ~y := x + 2 ~\texttt{else} ~y := y + 1,  y > x)  \\
& = (x > 0 \implies \text{wp}(y := x + 2, y > x) ~\land~ (x\le 0 \implies \texttt{wp}(y := y + 1, y > x))\\
& = (x > 0 \implies x + 2 > x)  ~\land~  (x \le 0 \implies y + 1 > x)\\
& = (x > 0 \implies 2 > 0)      ~\land~  (x \le 0 \implies y + 1 > x)\\
& =     \texttt{True}           ~\land~  (x \le 0 \implies y + 1 > x)\\
& =            x \le 0 \implies y + 1 > x
\end{split}
\end{equation*}

    \item 
\begin{equation*}
\begin{split}
&\texttt{wp}(\texttt{if} ~x > 0~ \texttt{then} ~y := x~  \texttt{else} ~y:= 0,  y > 0)\\
&= (x>0 \implies \texttt{wp}(y:=x, y >0)) \land (x<=0 \implies \texttt{wp}(y:=0, y>0))\\
&= (x > 0 \implies x > 0)      \land  (x <= 0  \implies  0 > 0)\\
&= !(x > 0) \lor (x > 0)   \land  !(x <= 0) \lor \texttt{False}\\
&=       \texttt{True}         \land         x > 0   \\
&=                    x > 0\\  
\end{split}
\end{equation*}
\end{itemize}


Instead of using implication $\implies$, which might be confusing to some, we can use $\neg$ and $\lor$. This is because $a \implies b$ is equivalent to $\neg a \lor b$. Thus, the above can be written as:

\begin{equation}\label{eq:wp-conditional2}
    \begin{split}
        \texttt{wp}(\texttt{if}~b~\texttt{then}~S1~\texttt{else}~S2, Q)  &=  (\neg b \lor \texttt{wp}(S1,Q))  ~\land~  (b \lor \texttt{wp}(S2, Q))    
    \end{split}
\end{equation}

\paragraph{Loop}

Unlike other statements where we have rules to compute WP \emph{automatically},
to obtain the WP of loop, we need to \emph{manually} supply a \textbf{loop invariant}
\texttt{I}. Moreover, the loop invariant \texttt{I} must be strong enough to ensure the postcondition \texttt{Q} holds when the loop terminates.

Assume that a loop invariant $I$ is given, the WP of a while loop is as follows:

\begin{equation}
    \begin{split}
    & \texttt{wp}(\texttt{while} ~[I]~ ~b~ \texttt{do} ~S, Q) \\
    &=    I  ~\land~   (I \land b) \implies \texttt{wp}(S,I)  ~\land~ (I \land \neg b)  \implies Q
    \end{split}   
\end{equation}

Thus, the WP for loop consists of 3 conjuncts:

\begin{enumerate}
\item
  $I$ : the loop invariant (should hold when entering the loop)
\item
  \texttt{(I\ \&\ b)\ \ =\textgreater{}\ \ \ I} : (entering the loop
  because \texttt{b} is true) \texttt{I} is preserved after each loop
  body execution
\item
  \texttt{(I\ \&\ !b)\ =\textgreater{}\ \ Q} (exiting the loop because
  \texttt{b} is false), when exiting the loop, the post condition holds
\end{enumerate}


\subsection{Verification Condition}\label{verification-condition} 
Now that we know how to do WP, we can continue with \textbf{verifiation
condition} (VC). Recall that to verify that the program \texttt{S}
satisfies the precondition \texttt{P} and postcondition \texttt{Q}
(i.e., the Hoare triple \texttt{\{P\}\ S\ \{Q\}} is valid), we create
the VC \texttt{P\ =\textgreater{}\ WP(S,\ Q)} and check its validity,
i.e., if the \texttt{VC} becomes \texttt{True}. If the \texttt{VC} is
valid, we have proved the program (i.e., it's correct wrt to the specs);
otherwise, we cannot say anything about the program, i.e., we don't know
if it's correct or not.


\section{Exercises}

\subsection{Using the Z3 SMT Solver}
Z3 is a theorem prover or SMT constraint solver developed at Microsoft.  It has been employed in various software testing and reasoning tasks. Major tech companies including MS, Google, Amazon (AWS), NASA, etc use Z3 for a wide-range of projects to solve problems in software, security, and AI. For example, Amazon AWS runs \emph{billions} of Z3 queries \emph{everyday}\footnote{https://www.amazon.science/blog/a-billion-smt-queries-a-day}.  In this exercise you will be introduced to Z3 and use it for various reasoning tasks.

\paragraph{Installation and Setup}

To have Z3 to work with Python, you can install it various methods including \texttt{pip} or \texttt{homebrew} (Mac) or \texttt{apt-get} (Linux). You can search online for the installation method that works best for your system.

To ensure Z3 is installed correctly, you can try to \texttt{import z3} in Python. If you do not get an error, then Z3 is installed correctly.

\paragraph{Your Tasks} You write Python code using Z3 for various problems below. You can use the Z3 API or use Google to find the relevant information like Z3's method names, e.g., \code{z3.solve(...)} for satisfiability checking and \code{z3.prove(...)} for proving or validy checking.

\begin{enumerate}

    \item Boolean Logic
    \begin{enumerate}
    \item Create boolean variables \texttt{p, q, r}
    \item Check if the formula $p \lor q$ is \emph{satisfiable}.
    \item Prove transitivity, i.e., show that $(p = q ~\land ~q =r) \implies p = r$.
    \item Show that $(p \land q) \implies p$ is a \emph{tautology} (valid).
    \item Prove that $p \implies q$ is equivalent to $\neg p \lor  q$.
    \end{enumerate}


    \item First-Order Logic over the Integers 
    \begin{enumerate}
    \item Create integer variables \texttt{x, y, z}.
    \item Show that $x > 3 \implies x > 2$
    \item Prove that $x > 3 \land y > 3 \implies x + y > 6$
    \item Solve for $x, y$ such that $x + y = 10$ and $x < 0$
    \item Show the transitive $x > y \land y > z \implies x > z$
    \item Confirm that $x > 2$ and $x < 2$ is \emph{unsatisfiable}.
    \item Prove that $x \le y$ and $x \ge y$ is equivalent to $x = y$.
    \end{enumerate}
    \item Using symbolic execution with Z3 to find inputs leading to each location in the program below.  For this you will do 2 things: (i) create a table like \autoref{tab:symbolic-execution} to show the path conditions and program states, and (ii) provide the Python Z3 code to solve for the inputs (e.g., if the PC is $x > 0$ and $y < 0$, you can just use \code{z3.solve(PC)} to get the inputs and show the values of $x, y$ leading to that location.
    
    \begin{lstlisting}
    void bar(int x, int y) {
    int a = 0, b = 0;  
    int z = x + y + a; 
    
    // L1
    if (x > 5) {
        int w = z - x + b;  
        // Location 2
        if (w < 3) {
            // L3
        } else {
            // L4
        }
    } else {
        int v = z + 2;  
        // L5
        if (v > y) {
            // L6
        } else {
            // L7
        }
    }
}
    \end{lstlisting}

\end{enumerate}

\paragraph{What to submit} You will submit a Python file with the Z3 code for the above problems. As usual be sure to include instructions (could be comments in the Python code) and screenshots on how to run the code.

You will also submit a text (or doc or pdf) file showing the symbolic execution table and the inputs leading to each location in the program.


\subsection{Hoare Triples}\label{exercise:hoare-tripples}

Fill in \texttt{P,S,Q} to make the following Hoare Triples valid. Remember that we want the strongest postcondition \code{Q} and weakest precondition \code{P}.
%todo: make more problems esp. with weakest/strongest pre/post

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{\{P\}\ x:=3\ \{x\ =\ 8\}}
\item
  \texttt{\{P\}\ x:=\ y\ -\ 3\ \{x\ =\ 8\}}
\item
  \texttt{\{x\ =\ y\}\ S\ \{x\ =\ y\}}
\item
  \texttt{\{x\ \textless{}\ 0\}\ while(x!=0)\ do\ x\ :=\ x\ -\ 1\ \{Q\}}
\end{enumerate}


    
\chapter{Design Patterns}

\section{Creational Patterns}
These patterns focuses on creating objects depending on their uses. 

\subsection{Singleton}
Each class has only one instance. Examples of singletons include logging (for logging messages) and configuration (for reading configuration files). 

\lstinputlisting{code/singleton.py}

\subsection{Factory Method}


\lstinputlisting[multicols=2]{code/factory.py}


\subsection{Abstract Factory}

\subsection{Builder}

\subsection{Prototype}

\section{Structural Patterns}
These focus on how objects are composed or structured.

\subsection{Adapter}


\section{Behavioral Patterns}

\section{Composition over Inheritance}

\chapter{Specification}

\section{Specifications and Specificand Sets}

The purpose of a specification is to define the behavior of an abstraction. Users will rely on this behavior, while implementers must provide it. An implementation that provides the described behavior is said to satisfy the specification. The purpose of a specification is to define the behavior of an abstraction. An implementation is said to satisfy a specification if it provides the described behavior. The meaning of a specification is the set of program modules that satisfy it, which are called the specifcand set.

For example, the following specification is satisfied by any function where y is greater than 0 and a value greater than y is returned. An infinite number of programs can be included in this specificand set.
\begin{lstlisting}
    def specification(y):
        """
        REQUIRES: y > 0
        EFFECTS: Returns x such that x > y
        """
        return y + 1

    
\end{lstlisting}


\section{Some Criteria for Specifications}
Restrictiveness, generality, and clarity are three important attributes for developing good specifications.

\subsection{Restrictiveness}
The specification should be restrictive enough to eliminate any implementations that the user does not want. The requirements should be included in the REQUIRES clause, or else the specifications may not be restrictive enough.

For example, the code below gives three specifications for an elems iterator for a bag (multiset) of integers. A multiset stores unordered values that may be duplicate.

\begin{lstlisting}
    def elems():
        """
        EFFECTS: Returns a generator that produces every element of this (as 
        Integers).
        """
\end{lstlisting}
This first specification doesn’t address what happens if changes are made to the bag while the iterator is in use.
\begin{lstlisting}
    def elems():
        """
        EFFECTS: Returns a generator that produces every element of this
        (as Integers).
        REQUIRES: this not be modified while the generator is in use.
        """
\end{lstlisting}
The second specification solves this by adding a requirement that the bag does not change while the iterator is in use. However, it still fails to specify the order that elements are returned in, what is done when duplicate elements are present, and that only elements in the bag are returned.
\begin{lstlisting}
    def elems():
        """
        EFFECTS: Returns a generator that produces every element of this
        (asIntegers), in arbitrary order. Each element is
        produced exactly the number of times it occurs in this.
        REQUIRES: this not be modified while the generator is in use.
        """

\end{lstlisting}
The third specification addresses all these matters, but fails to identify when exceptions should be signaled and does not identify behavior at boundary cases. Figure 9.2 is restrictive enough.

\subsection{Generality}
A specification should avoid precluding acceptable implementations. The goal is to make the most general possible specification. For example, the specification below only returns approximations that are greater than or equal to the square root itself, which can be inefficient.

\begin{lstlisting}
    def sqrt (sq: float, e: float)
        """
        REQUIRES: sq >= 0 && e > .001
        EFFECTS: Returns rt such that 0 <= (rt*rt - sq) <= e.
        """
\end{lstlisting}
The \textbf{definitional} style of specification explicitly describes properties that specificand members should exhibit. The specification below is shorter and more open ended in its explanation of how to implement the function. For example, the implementor can choose to examine the array elements in any order, not just first to last.

\textbf{Operational} specification styles provide instructions to construct the properties. They are easily constructed because their construction is similar to programming. However, they are usually longer than definitional specifications and can lead to over-specification. For example, the following program specifies which index to return when x is a duplicate, which might be too restrictive.
\begin{lstlisting}
    def search (array, x: int)
        """
        EFFECTS: If a is null throws NullPointerException else examines
        each element in turn and returns the index of the first one
        that is equal to x. Signals NotFoundException if none equals x.
        """

\end{lstlisting}

Definitional specifications often support more generality than operational specifications.

\subsection{Clarity}
A specification should be clear and easy for users to understand. On top of being restrictive and general, specifications should be well modularized, nicely commented, and easy-to-read. The most dangerous issue with unclear specifications is misinterpretation.

For example, the implementer of \code{elems} may decide to produce each element the number of times it occurs in the bag, while the user expects each element to be produced only once.

Two important factors in making clear specifications are \textbf{conciseness} and \textbf{redundancy}. The longer a specification is, the more likely it is to contain errors, so it is best to avoid pointless verbosity. When making a local change to a program, try to consolidate the relevant information with the existing specification rather than just adding to it. 

While redundancy is less concise, it should be used to reduce the likelihood of misinterpretation and to catch errors. Examples are a form of redundancy. A good way to indicate that information is redundant is to preface it with "i.e." or "e.g.". Consider the following.
\begin{lstlisting}
    def subset (s1: IntSet, s2: IntSet):
        """
        EFFECTS: If s1 or s2 is null throws NullPointerException else
        returns true if s1 is a subset of s2 else returns false.
        """

\end{lstlisting}
This first specification can cause confusion about whether the author meant to say subset or proper subset. 
\begin{lstlisting}
    def subset (s1: IntSet, s2: IntSet):
        """
        EFFECTS: If s1 or s2 is null throws NullPointerException else
        returns true if s1 is a subset of s1 is an element of s2 else returns
        false.
        """
\end{lstlisting}
The second specification leaves no doubt about the first specification issue, but is a little harder to read. However, it does not explicitly state that the function should be a subset test.
\begin{lstlisting}
    def subset (s1: IntSet, s2: IntSet):
        """
        EFFECTS: If s1 or s2 is null throws NullPointerException else
        returns true if s1 is a subset of s2 else returns false, i.e.,
        returns true if every element of s1 is an element of s2 else returns
        false.
        """
\end{lstlisting}
The third specification is sufficiently clear.

Redundancy makes mistakes in a specification more evident and provides the reader with the opportunity to notice them. It also provides clarity when informal specifications might lead to different interpretations.

\section{Why Specifications?}
Abstraction decomposes a program into modules, and those modules require some description through specifications. A specification describes an agreement between providers and users of a service, which makes it possible to separate consideration of the implementation from the use of a program unit.

Furthermore, they emphasize the abstraction being defined, encouraging users and implementers alike to pay attention to its intended use.

Specifications are useful for program documentation. The goal is to write specifications that are both restrictive enough and general enough. Writing them also encourages prompt attention to inconsistencies, incompleteness, and ambiguities.

Since specifications become irrelevant only when their abstraction is obsolete, they should continue to evolve as long as the program evolves.

Finally, a specification can be a helpful maintenance tool. The existence of clear and accurate documentation is a prerequisite for efficient and effective maintenance. They define the constraints that must be observed in correcting any error, which helps us avoid introducing new errors while correcting old ones.

\section{Exercises}
\subsection{IntBag Abstraction}
Provide a specification for an IntBag abstraction that is sufficiently restrictive, general, and clear.
\begin{enumerate}
\item Include the following functions:
\begin{itemize}
    \item create an empty bag
    \item insert and remove and element
    \item test if the bag contains an element
    \item get the size of the bag
    \item get the number of times an element occurs
    \item display the elements in the bag
\end{itemize}
\item Discuss the restrictiveness, generality, and clarity of one of the above specifications.
\end{enumerate}

\appendix



\chapter{Miscs}


\bibliographystyle{abbrv}

\chapter{More Examples}
\section{ADT}
\subsection{Stack ADT}
\begin{figure}
    \begin{lstlisting}
        class Stack:
        """
        Overview: Stack is a mutable ADT that represents a collection of elements in LIFO.
        AF(c) = the sequence of elements in the stack in sorted order from bottom to top.
        rep-inv: 
            1. elements is a list (could be empty list, which represents and empty stack).
            2. The top of the stack is always the last element in the list.
        """
    
        def __init__(self):
            """
            Constructor
            EFFECTS: Initializes an empty stack.
            MODIFIES: self
            """
            self.elements = []
    
        def repOK(self):
            """
            EFFECTS: Returns True if the rep-invariant holds, otherwise False.
            The invariant checks:
            1. elements is a list.
            2. If the stack is non-empty, the top of the stack is the last element in the list.
            """
            # Check that elements is a list
            if not isinstance(self.elements, list):
                return False
            
            # If the stack is not empty, ensure that the top is the last element in the list.
            # This is implicitly guaranteed by the use of `list.append` for push and `list.pop` for pop,
            # so no further explicit check is needed for the "top as last element."
            return True
    
        def push(self, value):
            """
            MODIFIES: self
            EFFECTS: Adds value to the top of the stack.
            """
            self.elements.append(value)
    
        def pop(self):
            """
            MODIFIES: self
            EFFECTS: Removes and returns the top element from the stack. 
            Raises an exception if the stack is empty.
            """
            if self.is_empty():
                raise Exception("Stack is empty")
            return self.elements.pop()
    
        def is_empty(self):
            """
            EFFECTS: Returns True if the stack is empty, otherwise False.
            """
            return len(self.elements) == 0
    
        def __str__(self):
            """
            EFFECTS: Returns a string representation of the stack,
                     showing the elements from bottom to top.
            """
            # The abstraction function maps the list of elements to a stack view
            return f"Stack({self.elements})"
    \end{lstlisting}
    \caption{Stack ADT}\label{ex:stack}
\end{figure}
    

\end{document}


%repr-inv:https://ocw.mit.edu/courses/6-170-laboratory-in-software-engineering-fall-2005/1a1f80fa85176ed3cae09ccd74f902d3_lec8.pdf



