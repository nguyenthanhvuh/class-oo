\documentclass[oneside,11pt,dvipsnames]{book}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[margin=1.5in]{geometry}
\usepackage{soul}
% \usepackage[small,compact]{titlesec} %very powerful
\usepackage[most]{tcolorbox}
% \setsecnumdepth{subsection}
% \setcounter{tocdepth}{3}
\usepackage{multicol}
\usepackage{enumitem}
\usepackage{epigraph}
\usepackage{cite}
\usepackage{caption}
\captionsetup{font=small}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{hyperref}
\usepackage{wrapfig}
\setlength\intextsep{0pt} % remove extra space above and below in-line float
\usepackage{hyperref}
\hypersetup{
  colorlinks,
  citecolor=black,
  filecolor=black,
  linkcolor=blue,
  urlcolor=blue,
}
\usepackage{booktabs}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\scriptsize,
  language=python,
  morekeywords={assert},
  keywordstyle=\color{blue},
  commentstyle=\color{magenta},
  numbers=none,
  mathescape,
  stepnumber=1,
  numbersep=8pt,
  tabsize=4,
  showspaces=false,
  showstringspaces=false,
  emph={},
  emphstyle=\color{red}\bfseries
}

\usepackage{tikz}
\usetikzlibrary{calc}
\usepackage{xcolor}

\usepackage{anyfontsize}
\usepackage{sectsty}

\usepackage{etoolbox}

\newtoggle{usesol}
\settoggle{usesol}{false} % not sol version
\newcommand{\sol}[1]{\iftoggle{usesol}{\textbf{Sol:} #1}{}}
\newcommand{\notsol}[1]{\nottoggle{usesol}{#1}{}}
\newcommand{\solite}[2]{\iftoggle{usesol}{#1}{#2}}

\usepackage[makeroom]{cancel}

\newtcolorbox{mybox}{
  enhanced,
  boxrule=0pt,frame hidden,
  borderline west={2pt}{0pt}{green!75!black},
  colback=green!10!white,
  sharp corners
}

\newenvironment{commentbox}[1][]{
  \small
  \begin{mybox}
    {\small \textbf{#1}}
  }{
  \end{mybox}
}

\newtcolorbox{mydomesticbox}{
  enhanced,
  boxrule=0pt,frame hidden,
  borderline west={2pt}{0pt}{red!75!black},
  colback=blue!10!white,
  sharp corners
}

\newenvironment{domesticbox}[1][]{
  \small
  \begin{mydomesticbox}
    {\small \textbf{#1}}
  }{
  \end{mydomesticbox}
}

\renewcommand{\figurename}{Fig.}
\renewcommand{\tablename}{Tab.}
\def\Section{\S}
\renewcommand{\figureautorefname}{Fig.}
\renewcommand{\tableautorefname}{Tab.}
\makeatletter
\renewcommand{\chapterautorefname}{\S\@gobble}
\renewcommand{\sectionautorefname}{\S\@gobble}
\renewcommand{\subsectionautorefname}{\S\@gobble}
\renewcommand{\appendixautorefname}{\S\@gobble}
\makeatother

\newcommand{\mycomment}[3][\color{blue}]{{#1{{#2}: {#3}}}}
\newcommand{\tvn}[1]{\mycomment{TVN}{#1}}{}
\newcommand{\red}[1]{{\color{red}{#1}}}
\newcommand{\code}[1]{\texttt{#1}}

\begin{document}

\pagestyle{empty}
\begin{tikzpicture}[overlay,remember picture]

    % Background color
    \fill[
    black!2]
    (current page.south west) rectangle (current page.north east);

    % Rectangles
    \shade[
    left color=Dandelion,
    right color=Dandelion!40,
    transform canvas ={rotate around ={45:($(current page.north west)+(0,-6)$)}}]
    ($(current page.north west)+(0,-6)$) rectangle ++(9,1.5);

    \shade[
    left color=lightgray,
    right color=lightgray!50,
    rounded corners=0.75cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(.5,-10)$)}}]
    ($(current page.north west)+(0.5,-10)$) rectangle ++(15,1.5);

    \shade[
    left color=lightgray,
    rounded corners=0.3cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(.5,-10)$)}}] ($(current page.north west)+(1.5,-9.55)$) rectangle ++(7,.6);

    \shade[
    left color=orange!80,
    right color=orange!60,
    rounded corners=0.4cm,
    transform canvas ={rotate around ={45:($(current page.north)+(-1.5,-3)$)}}]
    ($(current page.north)+(-1.5,-3)$) rectangle ++(9,0.8);

    \shade[
    left color=red!80,
    right color=red!80,
    rounded corners=0.9cm,
    transform canvas ={rotate around ={45:($(current page.north)+(-3,-8)$)}}] ($(current page.north)+(-3,-8)$) rectangle ++(15,1.8);

    \shade[
    left color=orange,
    right color=Dandelion,
    rounded corners=0.9cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(4,-15.5)$)}}]
    ($(current page.north west)+(4,-15.5)$) rectangle ++(30,1.8);

    \shade[
    left color=RoyalBlue,
    right color=Emerald,
    rounded corners=0.75cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(13,-10)$)}}]
    ($(current page.north west)+(13,-10)$) rectangle ++(15,1.5);

    \shade[
    left color=ForestGreen,
    rounded corners=0.3cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(18,-8)$)}}]
    ($(current page.north west)+(18,-8)$) rectangle ++(15,0.6);

    \shade[
    left color=ForestGreen,
    rounded corners=0.4cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(19,-5.65)$)}}]
    ($(current page.north west)+(19,-5.65)$) rectangle ++(15,0.8);

    \shade[
    left color=OrangeRed,
    right color=red!80,
    rounded corners=0.6cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(20,-9)$)}}]
    ($(current page.north west)+(20,-9)$) rectangle ++(14,1.2);



    % Title
    \node[align=center] at ($(current page.center)+(0,-5)$)
    {
    {\fontsize{38}{1} \selectfont {{OOP Design and Specification}}}\\[0.5in]

    {\fontsize{14}{19.2} \selectfont \textcolor{ForestGreen}{ \bf ThanhVu (Vu) Nguyen}}\\[0.1in]
    \today{} (latest version available on  \href{https://nguyenthanhvuh.github.io/class-oo/oop.pdf}{nguyenthanhvuh.github.io/class-oo/oop.pdf})
    };
    \end{tikzpicture}


\chapter*{Preface}



\newpage
\tableofcontents


\chapter{Introduction}\label{sec:intro}

This book will guide you through the fundamentals of constructing high-quality software using a modern \textbf{object-oriented programming} (OOP) approach.  We will use \emph{Python} for demonstration, but the concepts can be applied to any object-oriented programming language.  The goal is to develop programs that are reliable, efficient, and easy to understand, modify, and maintain.


\section{Decomposition}\label{sec:decomposition}

As the size of a program increases, it becomes essential to \emph{decompose} the program into smaller, independent programs (or functions or modules). This decomposition process allows for easier management of the program, especially when multiple developers are involved.   This makes the program easier to understand and maintain.




%\subsection{Decomposition}

Decomposition is the process of breaking a complex program into smaller, independent, more manageable programs, i.e., ``divide and conquer''. It allows programmer to focus on one part of the problem at a time, without worrying about the rest of the program.

\paragraph{Example} \autoref{ex:mergesort} shows a Python implementation of \emph{Merge Sort}, a classic example of problem decomposition. It breaks the problem of sorting a list into simpler problems of sorting smaller lists and merging them.

\begin{figure}[t]
\begin{lstlisting}[multicols=2]
def merge_sort(lst):
    if len(lst) <= 1:
        return lst

    mid = len(lst) // 2
    left = merge_sort(lst[:mid])
    right = merge_sort(lst[mid:])
    return merge(left, right)







def merge(left, right):
    result = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])
    return result
\end{lstlisting}
 \caption{Decomposition example: Mergesort}\label{ex:mergesort}
\end{figure}


\section{Abstraction}\label{sec:abstraction}



\emph{Abstraction} is a key concept in OOP that allows programmers to hide the implementation details of a program and focus on the essential features. By decoupling the \textbf{what} (the  behavior specification) from the \textbf{how} (the actual implementation), programmers could focus on higher-level design and reuse code more effectively.
In an OOP language such as Python, you can abstract problems by creating functions, classes, and modules that hide the underlying implementation details.

\paragraph{Example} \autoref{ex:mammal} demonstrates an abstraction for different types of mammals. Mammals such as Dog and Cat share common behaviors such as making noise (speak). We can create a class \code{Mammal} that defines these common behaviors, and then subclasses \code{Dog} and \code{Cat} that inherit from \code{Mammal} and define their own unique behaviors.  These are abstract data types that allow us to work with mammals. Also notice the specification (e.g., \code{REQUIRES}) in the comments that describe what the method does, not how it does it.

\begin{figure}[t]
\begin{lstlisting}[multicols=2]
class Mammal:
    def __init__(self, name):
        self.name = name

    def speak(self): pass

class Dog(Mammal):
    def speak(self): 
        """
        EFFECTS: Return the sound of a dog.
        """
        return "Woof!"


class Cat(Mammal):
    def speak(self):
        """
        EFFECTS: Return the sound of a dog.
        """
        return "Meow!"
    

\end{lstlisting}
 \caption{Decomposition example: Mergesort}\label{ex:mammal}
\end{figure}

\chapter{Procedural Abstraction}\label{chap:procedural-abstraction}

\emph{Procedural abstraction} is a fundamental concept in programming that allows developers to create functions (methods) that hide the implementation details of a program. By abstracting away the details, developers can focus on the essential features of the program, making it easier to understand, modify, and maintain. 

By separating procedure definition and invocation, we make two important methods of abstraction: abstraction by parameterization and abstraction by specification.

\paragraph{Abstraction by Parameterization}

This generalizes a function by using \emph{parameters}. This allows the function to be used with different input values, making it more versatile and reusable. \autoref{ex:abs-parameterization} shows an example of abstract parameterization. The \code{cal\_area} function calculates the area of a rectangle given its length and width, which are passed as parameters.

\begin{figure}[h]
    \begin{lstlisting}
    def cal_area(length, width):
        return length * width

    # can be used with different values for length and width.
    area1 = cal_area(5, 10)
    area2 = cal_area(7, 3)
\end{lstlisting}
\caption{Example: Abstract Parameterization}\label{ex:abs-parameterization}
\end{figure}



\paragraph{Abstraction by Specification} This specifies on what the function does (e.g., sorting), instead of how it does it (e.g., using quicksort or mergsort algorithms, implemented in C). By defining a function's behavior through \emph{specifications}, developers can implement the function in different ways as long as it fulfills the specifications. Similarly, the user can use the function without knowing the implementation details.

\autoref{ex:abs-specification} shows an example of abstraction by specification. The \code{exists} method return true if the \code{target} item is found in a list of sorted \code{items}. The user only needs to provide a sorted list and a target, but does not need to know what algorithm is used or implemented to determine if the item exists in the list.

\begin{figure}
\begin{lstlisting}
    def exists(items:List[int], target:int) -> bool:
        """
        Find an item in a list of sorted items.

        Pre: List of sorted items
        Post: True if the target is found, False otherwise.
        """
        ...

    # The user only needs to know that this function checks 
    # for the existence of an item in a sorted list. 
    # They don't need to know the search algorithm or implementation.
\end{lstlisting}
\caption{Abstraction by Specification}\label{ex:abs-specification}
\end{figure}

\section{Specifications}\label{sec:specifications}

We define abstractions through specifications, which describe what the abstraction is intended to do rather than how it should be implemented. This allows specifications to be much more concise and easier to read than the corresponding code.

Specifications which can be written in either \emph{formal} or \emph{informal languages}. Formal specifications have the advantage of being precise and unambiguous. However, in practice, we often use informal specifications, describing the behavior of the abstraction in plain English (e.g., the \code{sorting} example in \autoref{ex:abs-specification}).  Note that a specification is not a programming language or a program. Thus, our specifications won’t be written in code (e.g., in Python or Java)

\subsection{Specifications of a Function}
%3.3 Liskov

The specification of a function consists of a \emph{header} and a \emph{description} of its behavior.
The header gives the signature of the function, including its name, parameters, and return type. The description describes the function's behavior, including its preconditions and postconditions.

\paragraph{Header} The header provides the \emph{name} of the function, the number, order, and types of its \emph{parameters} (inputs), and the type of its return value (output). For instance, the headers for the \code{sort\_items} function in \autoref{ex:abs-specification} and the \code{cal\_area} function in \autoref{ex:abs-parameterization} are as follows

\begin{lstlisting}
def exists(items: list) -> bool: ...
def calc_area(length: float, width: float) -> float: ...
\end{lstlisting}

Note that in a language like Java, the header also provides \emph{exceptions} that the function may throw.

\paragraph{Preconditions and Postconditions}

A typical function specification in an OOP language such as Python includes: \emph{Preconditions} (also called the ``requires'' clause) and \emph{Postconditions} (also called the ``effects'' clause). Preconditions describe the conditions that must be true before the function is called. Typically these state the constraints or assumptions about the input parameters. If there are no preconditions, the clause is often written as \code{None}.

Postconditions, under the assumption that the preconditions are satisfied, describe the conditions that will be true after the function is called. These typically state the expected results or outcomes of the function. Moreover, they often describe the relationship between the inputs and outputs.


The clauses are usually written as \emph{comments} above the function definition, making them easily accessible within the code.


\begin{lstlisting}
def calc_area(length: float, width: float) -> float:
    """
    Calculates the area of a rectangle given its length and width.

    Pre: None
    Post: The area of the rectangle.
    """
    ...
\end{lstlisting}

For example, the specification of the \code{calc\_area} function in \autoref{ex:abs-parameterization} has (i) no preconditions and (ii) the postcondition that the function returns the area of a rectangle given its length and width.  Similarly, the \code{exists} function in \autoref{ex:abs-specification} has the specification that given a list of sorted items (precondition), it returns true if the item is found in the list, and false otherwise (postcondition).  Note how the specification is written in plain English, making it easy to understand for both developers and users of the function.


\paragraph{Modifies} Another common clause in a function specification is \emph{modifies}, which describes the inputs that the function modifies. This is particularly useful for functions that modify their input parameters.

\begin{lstlisting}
def add_to_list(input_list, value):
    """
    Adds a value to the input list.

    Pre: None
    Post: Value is added to the input list.
    Modifies: the input list
    """
    ...
\end{lstlisting}


\subsection{In-class Exercise: User Equality}
This exercise touches on some thorny issues with inheritance. There is a lot going on in this example, but it is a good exercise to understand the subtleties of inheritance. 

\begin{enumerate}
    \item First, look at the \href{https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-}{Javadoc} to understand the behaviors \code{equals()} (while the specification is for Java, the idea is the same in Python).
    \begin{itemize}
        \item Specifically, read carefully the \emph{symmetric}, \emph{reflexive}, and \emph{transitive} properties of \code{equals()}.
        \item Ignore \emph{consistency}, which requires that if two objects are equal, they remain equal.
    \end{itemize}    
    \item For the \code{User} class in \autoref{ex:user}, does \code{equals()} satisfy the three equivalence relation properties? If not, what is the problem?
    \begin{itemize}
        \item Come up with several concrete test cases (e.g., create various \code{User} instances) to check the properties.
        \item If there is a problem, show the test case that demonstrates the problem.
        \item Explain why the problem occurs and come up with a fix.
    \end{itemize}
    \item So the same analysis for the \code{SpecialUser} class in \autoref{ex:specialuser}.
    \end{enumerate}
    
    % 1. Is the given implementation of `equals()` in class `SpecialUser` satisfy the 3 equivalence relation properties? If not, what is the problem? Be concrete: find a specific object (test case!) that demonstrates the problem. How does *inheritance* makes `equals()` in class `SpecialUser` harder to get right?
    

\begin{figure}
\begin{lstlisting}
    class User:
        def __init__(self, name):
            self.name = name

        def __eq__(self, other):
            if not isinstance(other, User):
                return False
            return self.name == other.name
\end{lstlisting}
\caption{User class}\label{ex:user}
\end{figure}


\begin{figure}
\begin{lstlisting}
    class SpecialUser(User):
        """Don't do this until you've done with User"""

        def __init__(self, name, id):
            super().__init__(name)
            self.id = id

        def __eq__(self, other):
            if not isinstance(other, SpecialUser):
                return False
            return super().__eq__(other) and self.id == other.id
\end{lstlisting}
\caption{SpecialUser class}\label{ex:specialuser}
\end{figure}



\section{Designing Specifications}\label{sec:design-specifications}
%Liskov 3.5

When designing specifications, it is important to consider several factors to ensure that the function is well-defined and can be used effectively. These factors include the \emph{strength} of the pre- and post-conditions, whether the function is \emph{total} or \emph{partial}, and the \emph{avoiding implementation details} in the specification.

\subsection{Weak Pre-conditions}m
For pre-conditions, we want as weak a constraint as possible to make the function more versatile, allowing it to handle a larger class of inputs.
Logically, a condition $x$ is weaker than another if it is \emph{implied} by the other $y$, i.e.,  $y \implies x$, or that $x$'s constraints are a superset of $y$'s. For example, the condition $x \le 5$ is weaker than $x \le 10$ and the input list is not sorted is weaker than the list is sorted (which is weaker than the list that is both sorted and has no duplicates).
The \emph{weakest} precondition is \emph{True}, which indicates no constraints on the input.


\subsection{Strong Post-conditions}

In contrast, for post-conditions, we want as strong a condition as possible to ensure that the function behaves as expected. A condition $y$ is stronger than another condition $x$ if $y$ implies $x$, i.e., $y \implies x$, or that $y$'s constraints are a strict subset of $x$'s. For example, the condition $x \le 10$ is stronger than $x \le 5$ or that the input list is sorted is stronger than the list is not sorted.


\subsection{Total vs Partial Functions}

A function is \emph{total} if it is defined for all legal inputs; otherwise, it is \emph{partial}. Thus a function with no precondition is total, while a function with the strongest possible precondition is partial.  Total functions are preferred because they can be used in more situations, especially when the function is used publicly or in a library where the user may not know the input constraints. Partial functions can be used when the function is used internally, e.g., a helper or auxiliary function and the caller is knowledgeable and can ensure its preconditions are satisfied.

The functions \code{calc\_area} function in \autoref{ex:abs-parameterization} and \code{add\_to\_list} in \autoref{ex:abs-specification} are total because they can be called with any input. The \code{exists} function in \autoref{ex:abs-specification} is partial because it only works with sorted lists.


\paragraph{Turning Partial Functions into Total Functions} It is often possible to turn a partial function into a total function in two steps. First, we move preconditions into postconditions and specify the expected behavior when the precondition is not satisfied, e.g., throws an \code{Exception}. Second, we modify the function to satisfy the new specification, i.e., handling the cases when the preconditions are not satisfied. For example, the \code{exists} function in \autoref{ex:abs-specification} is turned into the total function shown in \autoref{ex:abs-total}.

\begin{figure}
\begin{lstlisting}
def exists(items: List[int], target: int) -> bool:
    """
    Find an item in a list of sorted items.

    Pre: True
    Post: If the input items are not sorted, raise an exception.
          Return True if the item is found, False otherwise.


    """

    if not is_sorted(items):
        raise Exception(...)
\end{lstlisting}
\caption{Total Specification for the program in \autoref{ex:abs-specification}}\label{ex:abs-total}
\end{figure}


\subsection{In-class Exercise: Partial and Total Specifications for \code{tail}}

Consider the following code:

\begin{lstlisting}
def tail(my_list):
     result = my_list.copy()
     result.pop(0)
     return result
\end{lstlisting}

\begin{itemize}
     \item What does the implementation of \code{tail} do in each of the following cases? You might want to see the \href{https://docs.python.org/3/tutorial/datastructures.html}{Python document} for \code{pop}.  How do you know: Running the code or reading Python document?
     \begin{itemize}
         \item \code{list = None}
         \item \code{list = []}
         \item \code{list = [1]}  
         \item \code{list = [1, 2, 3]}
     \end{itemize}
     \item Write a \emph{partial specification} for \code{tail}
     \item Rewrite the specification to be \emph{total}. Use \emph{exceptions} as needed.
    \end{itemize}

\subsection{No implementation details}
The specification should not include any implementation details, such as the algorithm used or the data structures employed. This improves flexibility as it allows the function to be implemented in different ways as long as it satisfies the specification. For example, the \code{exists} function in \autoref{ex:abs-specification} does not specify the search algorithm used to find the item in the list.

Some common examples to avoid include: the mentioning of specific data structures (e.g., arrays, indices), algorithms (e.g., quicksort or mergesort), and exceptions (e.g., related to IndexError). Also avoid specifications mentioning indices because this implies the use of arrays.




%\chapter{Exception}
%Liskov 4 ,  but won't follow this because it talks about checked vs unchecked exceptions, which are not really applicable in Python.
\section{Exercise}

\subsection{Specification for Sorting}
Write the specification for the generic \code{ascending\_sort} method below. The specification should include preconditions and postconditions.
\begin{lstlisting}
    def ascending_sort(my_list):
        # REQUIRES/PRE: 
        # EFFECTS/POST: 
        ...
\end{lstlisting}
    


\subsection{Specification of Binary Search}

Come up with the specification for a \emph{binary search} implementation whose header is given below. Remember for precondition you want something as \emph{weak} as possible and for postcondition as \emph{strong} as possible. Note that binary search returns the \emph{location} (an non-neg integer) of the \code{target} value if found, and returns -1 if \code{target} is not found. 

\begin{lstlisting}
def binary_search(arr: List[int], target: int) -> int:
    """
    PRE/REQUIRES: 
    POST/EFFECTS: 
    """
    ... 
\end{lstlisting}


\subsection{Loan Calculator}\label{ex:loan}    

Consider a function that calculates the number of months needed to pay off a loan of a given size at a fixed \emph{annual} interest rate and a fixed \emph{monthly} payment. For example, a \$100,000 loan at an 8\% annual rate would take 166 months to discharge at a monthly payment of \$1,000, and 141 months to discharge at a monthly payment of \$1,100. (In both cases, the final payment is smaller than the others; we round 165.34 up to 166 and 140.20 up to 141.) Continuing the example, the loan would never be paid off at a monthly payment of \$100, since the principal would grow rather than shrink.

\begin{itemize}


\item Define a function satisfying the following specification:

\begin{lstlisting}
def months(principal: int, rate: float, payment: int) -> int:
    """
    Calculate the number of months required to pay off a loan.
    
    param principal: Amount of the initial principal (in dollars)
    param rate: Annual interest rate (e.g., 0.08 for 8%)
    param payment: Amount of the monthly payment (in dollars)
    
    Requires/Pre: principal, rate, and payment all positive and 
    payment is sufficiently large to drive the principal to zero.
    Effects/Post: return the number of months required to pay off the principal
    """
\end{lstlisting}

\begin{itemize}
    \item The precondition is quite strong, which makes implementing the method easy. The key step in your calculation is to change the principal on each iteration with the following formula (which amounts to monthly compounding):
    \begin{lstlisting}
new_principal = old_principal * (1 + monthly_interest_rate) - payment
    \end{lstlisting}

    \item To make sure you understand the point about preconditions, your code is required to be \emph{minimal}. Specifically, if it is possible to delete parts of your implementation and still have it satisfy the requirements, you'll earn less than full credit.
\end{itemize}
\item \emph{Total} specification: Now change the specification to \emph{total} in which the postcondition handles violations of the preconditions using \emph{exceptions}. In addition, provide a new implementation \code{month} that satisfies the new specification.
\end{itemize}
\subsection{Partial and Total Functions}

\begin{enumerate}
    \item Write the \emph{partial} specifications for the below two functions.
    \item Modify the specifications to make the functions \emph{total}.
    \item Modify the implementations of the two functions to satisfy the total specification.
\end{enumerate}

Recall that specifications do not deal with types (which are taken care by the function signature and enforced by the type system of compiler/interpreter).  In other words, you do not need to worry about types here and can assume conditions about types are satisfied.

\begin{lstlisting}
def divide(a:float, b:float) -> float:
    """
    PRE:
    POST:
    """
    return a / b

def get_average(numbers: list[float]) -> float:
    """
    PRE:
    POST:
    """
    total = sum(numbers)
    return divide(total, len(numbers))
\end{lstlisting}



\sol{For \code{divide}, precond is \code{b} cannot be 0, postcond is the result is the division of \code{a} by \code{b}. For \code{get\_average}, precond is the list cannot be empty (which cause division by 0), postcond is the result is the average of the numbers in the list. To make them total, we throw an exception when the precond is violated.}

\chapter{Data Abstraction}\label{chap:adt}
%Liskov 5

%This chapter focuses on \emph{abstract data type} (ADT), a foundation of OOP and key concept in programming that allows developers to separate how data is implemented from how it behaves. Through ADT, programmers can create new data types relevant to their application. These ADTs consist of objects and associated operations.

In 1974, Barbara Liskov and Stephen N. Zilles introduced the concept of Abstract Data Types (\emph{ADTs}) in their influential paper ``Programming with Abstract Data Types'' as part of their work on the CLU programming language at MIT. ADTs revolutionized software design by separating the specification of a data type from its implementation. This meant that developers could define operations on a data structure (such as stacks or queues) without exposing the details of how the data was managed internally. This idea of data abstraction improved modularity, making programs easier to modify, extend, and maintain.

For her pioneering contributions to programming languages and system design, particularly through her work on ADTs and CLU, Barbara Liskov was awarded the Turing Award in 2008. Today, ADTs are a cornerstone of modern programming, underlying the concepts of encapsulation and modularity in modern OOP languages like Java, Python, and Rust.

%The CLU language was the first to explicitly support ADTs using a construct called a cluster, which encapsulated both the data structure and the operations that acted on it. CLU also introduced several other innovative features like iterators, exceptions, and parameterized types, many of which influenced modern programming languages such as Java, Python, and C++. Though CLU never became widely used, the principles it introduced, especially ADTs, became foundational in software engineering, leading to more modular and reusable code.



%An ADT has two main components: \emph{parameterization} and \emph{specification}. Parameterization involves using parameters for flexibility, while specification means including operations as part of the data type, which abstracts away the underlying data representation. This ensures that even if the data structure changes, programs that rely on it remain unaffected, as they only interact with the operations rather than the data's internal structure.

%By abstracting data, developers can postpone decisions about data structures until they fully understand how the data will be used, leading to more efficient programs. ADT is also beneficial during program maintenance, as changes to the data structure affect only the type's implementation, not the modules using it.


\section{Specifications of an ADT}

The specification of ADT explains what the operations on the data type do, allowing users to interact with objects only via methods, rather than accessing the internal representation. 
As with functions (\autoref{chap:procedural-abstraction}), the specification for an ADT defines its behaviors without being tied to a specific implementation.


\paragraph{Structure of an ADT} In a modern OOP language such as Python or Java, data abstractions are defined using \emph{classes}. Each class defines a name for the data type, along with its constructors and methods.

\begin{figure}
    \begin{lstlisting}
class DataType:
    """
    Overview: A brief description of the data type and its objects.
    """

    def __init__(self, ...):
        """
        Constructor to initialize a new object.
        """

    def method1(self, ...):
        """
        Method to perform an operation on the object.
        """
    \end{lstlisting}
    \caption{Abstract Data Type template}\label{ex:adt-template}
\end{figure}


\autoref{ex:adt-template} shows an ADT class template in Python. It consists of three main parts. The \emph{Overview} describes the abstract data type in terms of well-understood concepts, like mathematical models or real-world entities. For example, a stack could be described using mathematical sequences.
The Overview can also indicate whether the objects of this type are \emph{mutable} (their state can change) or \emph{immutable}.
The \emph{Constructor} initializes a new object, setting up any initial state required for the instance.
Finally, \emph{methods} define operations users can perform on the objects. These methods allow users to interact with the object without needing to know its internal representation. In Python, \code{self} is used to refer to the object itself, similar to \code{this} in Java or C++.

Note that as with procedural specification (\autoref{chap:procedural-abstraction}), the specifications of constructors and methods of an ADT do not include implementation details. They only describe what the operation does, not how it is done. Moreover, they are written in plain English as code comment.


\subsection{Example: \code{IntSet} ADT}

\autoref{ex:intset} gives the specification for an \code{IntSet} ADT, which represents unbounded set of integers. \code{IntSet} includes a constructor to initialize an empty set, and methods to insert, remove, check membership, get the size, and choose an element from the set. \code{IntSet} is also mutable, as it allows elements to be added or removed. \emph{mutator} \code{insert} and \code{remmove} are mutator methods and have a \code{MODIFIES} clause.  In contrast, \code{is\_in}, \code{size}, and \code{choose} are \emph{observer} methods that do not modify the object.

\begin{figure}
    \begin{lstlisting}
class IntSet:
    """
    Overview: IntSets are unbounded, mutable sets of integers.
    This implementation uses a list to store the elements, ensuring no duplicates.

    """
    def __init__(self):
        """
        Constructor
        EFFECTS: Initializes this to be an empty set.
        """
        self.els = []  # the representation (list)

    def insert(self, x: int) -> None:
        """
        MODIFIES: self
        EFFECTS: Adds x to the elements of this set if not already present.
        """
        if not self.is_in(x): self.els.append(x)
            
    def remove(self, x: int) -> int:
        """
        MODIFIES: self
        EFFECTS: Removes x from this set if it exists. Also returns       
        the index of x in the list.
        """
        i = self.find_idx(x)
        if i != -1:
            # Remove the element at index i
            self.els = self.els[:i] + self.els[i+1:]  
        return i

    def is_in(self, x: int) -> (bool, int):
        """
        EFFECTS: If x is in this set, return True. Otherwise False.
        """
        return True if find_index(x) != -1 else False

    def find_idx(self, x:int)->int:
        """
        EFFECTS: If x is in this set, return its index. Otherwise returns -1.
        """
        for i, element in enumerate(self.els):
            if x == element:
                return i
        return -1

    def size(self) -> int:
        """
        EFFECTS: Returns the number of elements in this set (its cardinality).
        """
        return len(self.els)

    def choose(self) -> int:
        """
        EFFECTS: If this set is empty, raises an Exception. 
        Otherwise, returns an arbitrary element of this set.
        """
        if len(self.els) == 0:
            raise Exception(...)
        return self.els[-1]  # Returns the last element arbitrarily

    def __str__(self) -> str:
        """
        Abstract function (AF) that returns a string representation of this set.
        EFFECTS: Returns a string representation of this set.
        """
        return str(self.els)
\end{lstlisting}
\caption{The IntSet ADT}\label{ex:intset}
\end{figure}

%\subsection{Example: \code{Polynomial} ADT}

\section{Implementing ADT}\label{sec:implementing-adt}

To implement an ADT, we first choose a \emph{representation} (\textbf{rep}) for its objects, then design constructors to initialize it correctly, and methods to interact with and modify the rep. 
For example, we can use a \code{list} (or vector) as the rep of \code{IntSet} in \autoref{ex:intset}. We could use other data structures, such as a \code{set} or \code{dict}, as the rep, but a list is a simple choice for demonstration.


To aid understanding and reasoning of the rep of an ADT, we use two key concepts: \emph{representation invariant} and \emph{abstraction function}.

\subsection{Representation Invariant (Rep-Inv)} Because the rep might not be necessarily related to the ADT itself (e.g., the list has different properties compared to a set), we need to ensure that our use of the rep is consistent with the ADT's behavior. 
To do this, we use \emph{representation invariant} (\textbf{rep-inv}) to specify the constraints for the rep of the ADT to capture its behavior. 

For example, the rep-inv for a stack is that the last element added is the first to be removed and the rep-inv for a binary search tree is that the left child is less than the parent, and the right child is greater. 
The rep-inv for our \code{IntSet} ADT in \autoref{ex:intset} is that all elements in the list are unique. 
\begin{lstlisting}
    # Rep-inv:
    # els is not null, only contains integers and has no duplicates.
\end{lstlisting}

The rep-inv must be preserved by all methods (more precisely, \emph{mutator} methods). It must hold true before and after the method is called. The rep-inv might be violated temporarily during the method execution, but it must be restored before the method returns. For \code{IntSet} Notice that the mutator \code{insert} method ensures that the element is not already in the list before adding it. 

The rep-inv is decided by the designer and specified in the ADT documentation as part of the specification (just like pre/post conditions) so that it is ensured at the end of each method (like the postcondition). Moreover, because rep-inv is so important, it is not only documented in comments but also checked at runtime.  This is done by invoking a \code{repOK}, discussed later, method at the start and end of each method.

\subsection{In-Class Exercise: Checking Rep-Invs}

\begin{lstlisting}
class Members:
    """
    Overview: Members is a mutable record of organization membership.
    AF: Collect the list as a set.
    
    Rep-Inv:
        - rep-inv1: members != None
        - rep-inv2: members != None and no duplicates in members.
        For simplicity, assume None can be a member.
    """

    def __init__(self):
        """Constructor: Initializes the membership list."""
        self.members = []  # The representation

    def join(self, person):
        """
        MODIFIES: self
        EFFECTS: Adds a person to the membership list.
        """
        self.members.append(person)

    def leave(self, person):
        """
        MODIFIES: self
        EFFECTS: Removes a person from the membership list.
        """
        self.members.remove(person)
\end{lstlisting}

\begin{enumerate}
\item Analyze these four questions for \emph{rep-inv 1}.
\begin{itemize}
    \item Does \code{join()} maintain rep-inv?
    \item Does \code{join()} satisfy its specification?
    \item Does \code{leave()} maintain rep-inv?
    \item Does \code{leave()} satisfy its specification?
\end{itemize}
\item Repeat for \emph{rep-inv 2}.
\item Recode \code{join()} to make the verification go through. Which rep-invariant do you use?
\item Recode \code{leave()} to make the verification go through. Which rep-invariant do you use?
\end{enumerate}

\subsection{Abstraction Function (AF)} 

It can be difficult to understand the ADT by looking at the rep directly. For example, we might not be able to visualize or reason about a binary tree or a graph ADT when using list as the rep. To aid understanding, \emph{abstraction function} (\textbf{AF}) provides a mapping between the rep and the ADT. 
Specifically, the AF maps from a \emph{concrete state} (i.e., the \code{els} rep in \autoref{ex:intset}) to an \emph{abstract state} (i.e., the integer set). AF is also a \emph{many-to-one} mapping, as multiple concrete states can map to the same abstract state, e.g., the list \code{[1, 2, 3]} and \code{[3, 2, 1]} both map to the same set \code{\{1, 2, 3\}}. 

Just as with rep-inv, the AF is documented in the class specification. Modern OOP languages often provide methods implementing the AF, in particular developer overrides the \code{\_\_str\_\_} method in Python and \code{toString} in Java to return a string representation of the object. For example, the \code{\_\_str\_\_} method in \autoref{ex:intset} returns a string representation of the set.



\subsection{In-Class Exercise: Stack ADT}

In this exercise, you will implement a \code{Stack} ADT. A stack is a common data structure that follows the Last-In-First-Out (LIFO) principle. You will:
\begin{enumerate}
\item Choose a Representation (rep) for the stack.
\item Define a Representation invariant (rep-inv)
\item Write a \code{repOK} method
\item Provide the specifications of basic stack operations (\code{push}, \code{pop}, \code{is\_empty}) and implement these methods accordingly.
\item Define an Abstraction Function (AF)
\item Implement \code{\_\_str\_\_()} to return a string representation of the stack based on the AF
\end{enumerate}

\section{Mutability vs. Immutability}\label{sec:mutability-vs-immutability}

An ADT can be either mutable or immutable, depending on whether their objects' values can change over time. An ADT should be immutable if the objects it models naturally have unchanging values, such as mathematical objects like integers, polynomials (Polys), or complex numbers. On the other hand, an ADT should be mutable if it models real-world entities that undergo changes, such as an automobile in a simulation, which might be running or stopped, or contain passengers, or if the ADT models data storage, like arrays or sets.

Immutability is beneficial because it offers greater safety and allows sharing of subparts without the risk of unexpected changes. Moreover, immutability can simplify the design by ensuring the object’s state is fixed once created. However, immutable objects can be less efficient, as creating a new object for each change can be costly in terms of memory and time.

\paragraph{Converting from mutable to immutable} 
Given a mutable ADT, it is possible to convert it to an immutable one by ensuring that the rep is not modified by any method. This can be achieved by making the rep private and only allowing read-only access to it. In Python, this can be done by using the \code{@property} decorator to create read-only properties. For example, the \code{els} list in \autoref{ex:intset} can be made read-only by defining a property method \code{elements} that returns a copy of the list.

\begin{lstlisting}
    class IntSet:
        def __init__(self):
            self.__els = []   # Private rep
        @property
        def self.els(self):
            return self.__els
\end{lstlisting}

Moreover, we need to convert mutator methods into observer methods, which make a copy of the rep, modify it, and return the modified rep object.  
\begin{lstlisting}
    def insert_immutable(self, x: int) -> IntSet:
        new_set = self.els.copy()
        if not self.is_in(x):
            new_set = new_set.append(x)
        return new_set
\end{lstlisting}

If the mutator returns a value $v$, then our new method returns a tuple consisting of (i) the new rep object and the return the value $v$. 
\begin{lstlisting}
    def remove_immutable(self, x: int): -> (IntSet, int):
        i = self.find_idx(x)
        new_set = self.els.copy()
        if i != -1:
            # Remove the element at index i
            new_set = self.els[:i] + self.els[i+1:]  
        return (new_set, i)
\end{lstlisting}

If you do not want to return multiple values (e.g., like in Java), then you can create two methods, one for returning the value and the other for returning the new rep object.
For example, a mutator \code{pop} method of a \code{Stack} would result into two methods: \code{pop2} returns the top element and \code{pop3} returns the new stack with the top element removed.

Finally, it is important that while it is possible to convert a mutable ADT to an immutable one as shown, mutability or immutability should be the property of the ADT type itself, not its implementation. Thus, it should be decided at the design stage and documented in the ADT specification.

\subsection{In-class Exercise: Immutable Queue}\label{ic:immutable-queue}

\begin{figure}
    \begin{lstlisting}

class Queue:
    """
    A generic Queue implementation using a list.
    """

    def __init__(self):
        """
        Constructor
        Initializes an empty queue.
        """
        self.elements = []
        self.size = 0

    def enqueue(self, e):
        """
        MODIFIES: self
        EFFECTS: Adds element e to the end of the queue.
        """
        self.elements.append(e)
        self.size += 1

    def dequeue(self):
        """
        MODIFIES: self
        EFFECTS: Removes and returns the element at the front of the queue.
        If the queue is empty, raises an IllegalStateException.
        """
        if self.size == 0:
            raise Exception(...)

        result = self.elements.pop(0)  # Removes and returns the first element
        self.size -= 1
        return result

    def is_empty(self):
        """
        EFFECTS: Returns True if the queue is empty, False otherwise.
        """
        return self.size == 0

    \end{lstlisting}
    \caption{Mutable Queue}\label{ex:mutable-queue}
\end{figure}

Rewrite the mutable \code{Queue} implementation in \autoref{ex:mutable-queue} so that it becomes \emph{immutable}. Keep the \textbf{rep} variables \code{elements} and \code{size}.




% \subsection{Locality and Modifiability}\label{sec:locality-modifiability}

% \emph{Locality} (the ability to reason about an ADT indepepdently of other code) and \emph{modifiability} (the ability to change an implementation without affecting other parts of the code) are two important concepts in writing code. It applies to functions (we want the function to be independent of other functions) and certain to data abstractions. For ADT implementation, this requires that the rep should be modifiable only within the ADT implementation and not outside of the ADT. This is achieved by making the rep \emph{private} and providing methods to access and modify the rep.

% Modifiability goes further than locality. To achieve modifiability, not only must modifications be restricted to the ADT implementation, but all access to the internal representation—-even for reading immutable components--must also be confined to the implementation. If other modules can access the internal representation, then changing the representation may affect those modules, violating modifiability. To ensure modifiability, instance variables must be declared private and cannot be exposed outside the ADT.
% Thus, it is essential that access to the internal representation is restricted to the ADT implementation. %Programming languages like Python allow encapsulation, ensuring that the representation is hidden and protected. If access to the representation is unrestricted, it becomes an additional property that must be proven about the code manually.

\section{Exercise}

\subsection{Polynomial ADT}
\begin{figure}
\begin{lstlisting}
class Poly:
    def __init__(self, c=0, n=0):
        if n < 0:
            raise ValueError("Poly(int, int) constructor: n must be >= 0")
        self.trms = {}
        if c != 0:
            self.trms[n] = c

    def degree(self):
        if len(self.trms) > 0:
            return next(reversed(self.trms.keys()))
        return 0

    def coeff(self, d):
        if d < 0:
            raise ValueError("Poly.coeff: d must be >= 0")
        return self.trms.get(d, 0)

    def sub(self, q):
        if q is None:
            raise ValueError("Poly.sub: q is None")
        return self.add(q.minus())

    def minus(self):
        result = Poly()
        for n, c in self.trms.items():
            result.trms[n] = -c
        return result

    def add(self, q):
        if q is None:
            raise ValueError("Poly.add: q is None")
        
        non_zero = set(self.trms.keys()).union(q.trms.keys())
        result = Poly()
        for n in non_zero:
            new_coeff = self.coeff(n) + q.coeff(n)
            if new_coeff != 0:
                result.trms[n] = new_coeff
        return result

    def mul(self, q):
        if q is None:
            raise ValueError("Poly.mul: q is None")
        
        result = Poly()
        for n1, c1 in self.trms.items():
            for n2, c2 in q.trms.items():
                result = result.add(Poly(c1 * c2, n1 + n2))
        return result

    def __str__(self):
        r = "Poly:"
        if len(self.trms) == 0:
            r += " 0"
        for n, c in self.trms.items():
            if c < 0:
                r += f" - {-c}x^{n}"
            else:
                r += f" + {c}x^{n}"
        return r
\end{lstlisting}
\caption{Polynomial ADT}\label{ex:poly}
\end{figure}


Use the Poly ADT in \autoref{ex:poly} to answer the following questions. Use the \code{Stack} ADT in \autoref{ex:stack} as an example. 

\begin{enumerate}
        \item Part 1
\begin{enumerate}
\item Write an Overview that describes what \code{Poly} does. You must provide some examples to demonstrate (e.g., \code{Poly(2,3)} means what?).
\item Provide the specifications for all methods in the ADT. 
\item Write the \textbf{rep} used in this code.  Describe how this rep represents \code{Poly}.
\item Provide the \textbf{rep-inv} for the ADT. Note, this would be the constraints over the rep variable(s).
\item Write a \code{repOK} method that checks the rep-inv.
\item Describe the AF in this code. Use \code{\_\_str\_\_} to help.
\end{enumerate}

        \item Part 2
\begin{enumerate}
        \item Introduce a fault (i.e. "bug") that breaks the \textbf{rep-inv}. Try to do this with a small (conceptual) change to the code. Show that the rep-invariant is broken with a concrete test case.
        \item Analyzed your bug with respect to the method specifications of \code{Poly}. Are all/some/none of the specification violated?
        \item Do you think your fault is realistic? Why or why not?
\end{enumerate}
        
\end{enumerate}


\subsection{Immutability}

The below class \code{Immutable} is supposed to be immutable. However, it is not. Identify the issues and fix them.  Note that in Python or Java, immutable types include \code{int}, \code{float}, \code{str}, \code{tuple}. and mutable types include \code{list} and \code{dict}. 

\begin{enumerate}
\item Which of the lines (A--F) has a problem with immutability? Explain why by showing code example, i.e., show code involving problematic lines; show how that breaks immutability.

\sol{Only line F is problematic. It returns a reference to the internal list, which can be modified. Note that line C has no issue because it creates a copy of the list. If there was no copy, then this would cause a problem as \code{mlist} could be modified outside the class and affects \code{\_mlist}.}
\item For each line that has a problem.  Write code to fix it so that the class is immutable.

\sol{To fix line F, simply return copy, i.e., return self.\_mlist.copy().}
\end{enumerate}

    
\begin{lstlisting}
class Immutable:
    def __init__(self, mstr: str, mint: int, mlist: list[str]):
        self._mstr = mstr                       # Line A
        self._mint = mint                       # Line B
        self._mlist = mlist.copy()              # Line C

    
    def get_mstr(self) -> str: return self._mstr        # Line D
    def get_mint(self) -> int: return self._mint        # Line E
    def get_mlist(self) -> list[str]: return self._mlist # Line F
\end{lstlisting}




% \chapter{Iterators and Generators}

% This chapter introduces the concept of \emph{iteration abstraction} through \emph{iterators}, which are a generalization of iteration mechanisms found in most programming languages. Iterators allow users to traverse arbitrary types of data efficiently and without the need for additional structures, such as arrays or list, that can consume extra memory or modify the collection being iterated over.


% \section{Iterators}

% \emph{Iterators} provide general-purpose iteration mechanism that is both efficient and preserves abstraction. An iterator is a special kind of object that allows us to access elements one at a time, without creating large intermediate structures or modifying the original collection, and can stop early if a certain condition is met (e.g., find a specific item). Thus, iterations avoid the space and time inefficiencies of other methods.

% Each iteration produces a new item that can then be used within the loop. Like with procedural and data abstraction, a key advantage of iterators is the separation of concerns: the iterator handles the production of items, while the code containing the loop handles the actions performed on those items. The iterator can be reused in different contexts without modification.

% \begin{figure}
% \begin{lstlisting}
% class IntSet:
%     def __init__(self):
%         self._elements = set()

%     def add(self, element):
%         self._elements.add(element)

%     def __iter__(self):
%         # Returns an iterator over the set
%         return iter(self._elements)

% # Now, we can efficiently compute the sum:
% def set_sum(s: IntSet) -> int:
%     return sum(s)

% \end{lstlisting}
% \caption{IntSet with Iterator}\label{ex:intset-iter}
% \end{figure}

% To motivate the needs for iteration, suppose that we want to compute the sum of an \code{IntSet} collection defined in \autoref{ex:intset}. To compute the sum, we need to iterate through each element in the set. One way to do this is to convert the set to a list and then iterate over the list. However, this approach is inefficient because it requires creating a new list, which consumes memory and time. Another approach is modifying \code{IntSet} to return its rep as a list so we can iterate over it. However, this approach violates the abstraction principle, as it exposes the internal representation of the set.

% Iterators provide a better solution by allowing us to iterate over the set without exposing its internal representation.
% The \code{IntSet} in \autoref{ex:intset-iter} defines an \code{\_\_iter\_\_} method, which returns an iterator over its elements. This allows us to directly iterate over \code{IntSet} instances using a \code{for} loop or other iteration constructs. For example, the \code{sum} function in \autoref{ex:intset-iter} computes the sum of the elements in the set without exposing the internal representation of the set.


% \section{Iterators and Generators}

% A modern OOP language such as Python provides support for iteration abstraction through its built-in iterator and generator mechanisms. In Python, an iterator returns a special kind of object called a \emph{generator}, which keeps track of the state of the iteration and produces elements one at a time. A Python generator is created using the \code{yield} keyword, and provides the \code{next} and \code{hasNext} methods to advance the iteration and check for the end of the sequence.

\chapter{Types}

In 1999, NASA's Mars Climate Orbiter mission ended in failure due to a simple yet catastrophic software error. The spacecraft, which cost \$125 million to build and launch, was launched on December 11, 1998 to study the Martian climate and atmosphere. After a 9-month journey, the spacecraft approached Mars on September 23, 1999, and was supposed to enter a stable orbit around Mars at an altitude of about 226 kilometers (140 miles) above the planet’s surface. However, the spacecraft instead plunged much deeper into the Martian atmosphere, to an estimated altitude of 57 kilometers (35 miles), causing it to either burn up or crash on the surface, resulting in a complete loss of the mission.

The cause of the failure was a software error involving typing mismatch between imperial units (pounds-force) and metric units (newtons) in the software that controlled the spacecraft's thrusters. The software expected data in metric units, but the thruster data was provided in imperial units, leading to the incorrect trajectory calculations. This mismatch was not caught during testing, and the spacecraft was lost as a result. This failure not only cost NASA a significant financial investment but also set back the Mars exploration program. 


\section{Type Systems in OOP}

In OOP, the type system forms the foundation for defining how ADT (\autoref{chap:adt}) is represented and manipulated in a language. Type systems provide rules for assigning types to variables, expressions, functions, and objects, enabling the development of reliable and efficient software. A well-defined type system also enforces contracts between components, ensuring that data is used appropriately.

This chapter covers key concepts in the type system of OOP languages, particularly in the context of Python, where both static and dynamic typing coexist. We will explore topics like polymorphism, inheritance, dynamic dispatching, and more, discussing their motivation, core concepts. 



% We can enhance ADT (\autoref{chap:adt}) by defining families of related ADTs, where all members share similar behavior through common methods. These type families are structured in a hierarchy, with a base class (\emph{supertype}) defining the core behavior, and subclasses (\emph{subtypes}) extending or adding to this behavior. For example, Cars and Buses as subtypes of Vehicle, or program-specific hierarchies like a BufferedReader as a subtype of Reader. 


% A key concept in typing is that the \emph{Liskov's principle of substitution}, which ensures that any subtype object can be substituted for a supertype object without breaking the program. This principle allows code written for the supertype (e.g., Reader) to work seamlessly with any subtype (e.g., BufferedReader), enabling abstraction by focusing on commonalities while still supporting specific behaviors at different levels of the hierarchy.

\section{Polymorphism}

Polymorphism is a cornerstone of OOP that allows objects of different types to be treated as objects of a common supertype. This facilitates flexibility in programming by enabling the use of a unified interface for different types of objects, reducing redundancy and increasing code reuse.

\autoref{ex:polymorphism} shows an example of subtype polymorphism, where a \code{Mammal} class has two subclasses, \code{Dog} and \code{Cat}, each implementing the \code{speak} method differently. The \code{make\_mammal\_speak} function can then be used to make any mammal speak, regardless of its specific type.

\begin{figure}
\begin{lstlisting}

from abc import ABC, abstractmethod

class Mammal(ABC):
    """
    Abstract class
    """
    
    @abstractmethod
    def speak(self):
        raise NotImplementedError("Subclasses should implement this!")

class Dog(Mammal):
    def speak(self):
        return "Woof!"

    def bark(self):
        return "Bark!"

class Cat(Mammal):
    def speak(self): return "Meow!"
        
# Using polymorphism
def make_animal_speak(mammal: Mammal): return mammal.speak()

mammals = [Dog(), Cat()]
for m in mammals:
    print(make_animal_speak(m))
\end{lstlisting}
\caption{Polymorphism}\label{ex:polymorphism}
\end{figure}

\section{Inheritance}

Inheritance creates a hierarchical relationship between classes and allows a class to be a \emph{subclass} or \emph{subtype} of one other class (its \emph{superclass} or \emph{supertype}).
\autoref{ex:polymorphism} shows an example of inheritance.
\code{Mammal} is the superclass of \code{Dog} and \code{Cat}.
\code{Dog} and \code{Cat} are the subclasses of \code{Mammal}
They override \code{speak} to provide a specific implementation.
In addition to \emph{overriding} the \code{speak} method in \code{Mammal}, \code{Dog} defines a new method \code{bark} that is specific to dogs.


This is an example of single inheritance, where a subclass can inherit from only one superclass. Python also supports multiple inheritance, where a subclass can inherit from multiple superclasses. For example, an \code{HybridVehicle} class could inherit from both \code{Car} and \code{BatteryVehicle} classes. However, multiple inheritance can lead to complex hierarchies and potential conflicts, so it should be used judiciously.

\section{Abstract Class}
OOP has two types of classes: \emph{concrete} and \emph{abstract} classes. Concrete classes provide a full implementation of the type while abstract classes provide at most a partial implementation of the type. Abstract classes cannot be instantiated (no objects) since some of their methods are not yet implemented (abstract methods). Abstract classes can have both abstract (to be implemented by subclasses) and concrete methods (already implemented or partially implemented). 

In Python abstract classes are defined using the \code{abc} module, which provides the \code{ABC} class and the \code{abstractmethod} decorator. The \code{ABC} class is used as a base class for abstract classes, and the \code{abstractmethod} decorator is used to mark methods as abstract. In \autoref{ex:polymorphism},
\code{Mammal} is an abstract class and contains an abstract method \code{speak} that its subclasses must implement.
In Java, abstract classes and methods are defined using the \code{abstract} keyword, e.g., \code{public abstract class Mammal} and \code{public abstract void speak();}.

\section{Interface}

Interface is a special type of abstract classes that contains only abstract methods (no concrete methods). They define a specification that classes must adhere to, providing the methods that must be implemented by any class that implements the interface. Multiple classes can implement the same interface, allowing for polymorphism and flexibility in the design.

In Python, interfaces are not explicitly defined, but the concept can be implemented using abstract classes with only abstract methods. For example, the abstract class \code{Mammal} in \autoref{ex:polymorphism} acts as an interface that specifies the \code{speak} method that all mammals must implement.
In Java, interfaces are explicitly defined using the \code{interface} keyword, e.g., \code{interface Mammal}, and methods are declared without a body, e.g., \code{public void speak();}. A class can implement multiple interfaces, allowing for more flexibility in defining contracts between classes.


\paragraph{Comparable interface} A good example of an interface is \code{Comparable}, which defines a single method \code{compare\_to} that allows objects to be compared to each other. Any class that implements \code{Comparable} can be compared to other objects of the same type, enabling sorting and other operations that require comparison.

The code below demonstrates the use of the \code{Comparable} interface in Python. The \code{Number} class implements the \code{Comparable} interface by defining the \code{compare\_to} method, which compares two \code{Number} objects based on their values. The \code{sort} function uses the \code{compare\_to} method to sort a list of \code{Number} objects.

\begin{lstlisting}
    from abc import ABC, abstractmethod
from typing import List

# Define a Comparable interface using ABC
class Comparable(ABC):
    @abstractmethod
    def compare_to(self, other: "Comparable") -> int:
        """Compares this object with another."""
        pass

# Implement Comparable in a concrete class
class Number(Comparable):
    def __init__(self, value: int):
        self.value = value

    def compare_to(self, other: "Number") -> int:
        if self.value < other.value:
            return -1
        elif self.value > other.value:
            return 1
        else:
            return 0

# Polymorphic sorting function that relies on the compare_to method
def sort(items: List[Comparable]) -> List[Comparable]:
    return sorted(items, key=lambda x: x.value)

# Usage
numbers = [Number(3), Number(1), Number(4), Number(2)]
sorted_numbers = sort(numbers)
print(sorted_numbers)  # Output: [1, 2, 3, 4]
\end{lstlisting}    

\subsection{Element Subtype vs Related Subtype} There are two types of subtypes: \emph{element subtype} and \emph{related subtype}. Element subtype relies on a common interface or abstract class, e.g., \code{Number} is an element subtype of \code{Comparable}. While this common approach allows for polymorphism, it requires all potential types must be pre-planned to fit the hierarchy. 

On the other hand, a related subtype does not directly rely on a common interface or abstract class (which might be designed much later). Instead, this approach creates a related subtype that implement the desired interface and then adapts it to the existing hierarchy. The code below demonstrates the use of a related subtype, where \code{Price} is adapted to \code{PriceComparable}, which implements \code{Comparable}, to allow sorting of \code{Price} objects.

\begin{lstlisting}
class Price:
    def __init__(self, amount: float):
        self.amount = amount


class PriceComparable(Comparable):
    def __init__(self, price: Price):
        self.price = price
    def compare_to(self, other: "PriceComparable") -> int:
        if self.price.amount < other.price.amount:
            return -1
        elif self.price.amount > other.price.amount:
            return 1
        else:
            return 0

# sorting using related subtype            
prices = [Price(3.0), Price(1.0), Price(4.0), Price(2.0)]
price_comparators = [PriceComparable(p) for p in prices]
sorted_prices = sort(price_comparators)
\end{lstlisting}

\section{Dynamic Dispatching}

Dynamic dispatching refers to how a program selects which method to invoke when a method is called on an object.  It allows the correct method to be invoked based on the \emph{runtime type} of the object, even if the reference to the object is of a more general (superclass) type. This is particularly useful when working with inheritance and polymorphism, where subclasses override methods from a superclass.
The distinction between dynamic dispatching and static dispatching lies in when the decision about which method to invoke is made—either at runtime (dynamic) or compile-time (static).

In \autoref{ex:polymorphism} the \code{make\_mammal\_speak} method will invoke the \code{speak} method of the correct subclass based on the runtime type of the object. This is dynamic dispatching in action, where the method \code{speak} to be called is determined at runtime based on the actual type of the object.  However, if we explicitly create a \code{Dog} instance and call \code{speak} on it, the method is statically dispatched, as the compiler knows the type of the object at compile-time and can directly call the correct method.

The code below demonstrates the difference between static and dynamic dispatching. The \code{Dog} object \code{d} is statically dispatched, while the \code{Mammal} object \code{m} is dynamically dispatched.
\begin{lstlisting}
    Dog d = Dog();
    d.speak();  # Static dispatching

    Mammal m = Dog();
    m.speak();  # Dynamic dispatching
\end{lstlisting}    

\section{Liskov Substitution Principle (LSP)}
The Liskov Substitution Principle (LSP) is a fundamental concept of object-oriented design, which ensures that objects of a subclass should be able to replace objects of the superclass without altering the correctness of the program. LSP promotes proper design and enforces correct use of inheritance.
Violating LSP can lead to unexpected behavior and errors in the program, as the assumptions made about the superclass may no longer hold for the subclass. 

The main idea of LSP is that a subclass \emph{is-a} superclass and can do everything the superclass can do, and can also do more. For example, a \code{Dog} is a \code{Mammal} and can speak like any mammal, but it can also bark, which is specific to dogs.
This enables substitution of objects of the subclass for objects of the superclass, allowing for polymorphism and dynamic dispatching to work correctly. The \code{make\_animal\_speak} function in \autoref{ex:polymorphism} demonstrates LSP by accepting any \code{Mammal} object and making it speak, regardless of its specific type.


\paragraph{Rules} If \code{S} is a subtype of \code{T}, then objects of type \code{T} may be replaced with objects of type \code{S} without altering any of the desirable properties of the program. This means whenever you use \code{T}, you can use \code{S} instead. To achieve this, we must follow the following rules:
\begin{itemize}
\item[\textbf{Signature Rule}] The signatures of methods of \code{S} must strengthen methods of \code{T}. In other words, the methods of \code{S} are a superset of the methods of \code{T}. Thus, if \code{T} has \code{n} methods, \code{S} also has \code{n} methods and additional ones (methods specific to \code{S}). 

\item[\textbf{Method Rule}] The specification of \code{f'} strengthens that of \code{f}. This means that the preconditions of \code{f'} must be weaker or equal to the preconditions of \code{f}, i.e.,  \code{f'} accepts more inputs than \code{f}.  The postconditions of \code{f} must be stronger or equal to that of \code{f}. This means that \code{f'} is more precise and specific than \code{f}.

\item[\textbf{Property Rule}] The subtype must preserve all properties of the supertype.  For example, the rep-invariant of the subtpe \code{S} must be stronger or equal to that of the supertype \code{T}. This means \code{S} should maintain or strengthen the properties (including rep invariants) of \code{T}
\end{itemize}

\subsection{In-Class Exercise: Bank Account}

%\autoref{ex:bankaccount}

\begin{figure}
    \begin{lstlisting}
class BankAccount:
    def __init__(self, balance: float):
        self._balance = balance if balance >= 0 else 0  
        
    def repOK(self):
        return self._balance >= 0

    def deposit(self, amount: float) -> bool:
        """
        REQUIRES: amount must be positive
        EFFECTS: balance is the original balance plus deposited amount
        """
        if amount <= 0:
            return False
        self._balance += amount
        # check_repOK()
        return True

    def withdraw(self, amount: float) -> bool:
        # REQUIRES: amount must be positive and less than or equal to balance
        # EFFECTS: balance is the original balance minus withdrawn amount

        if amount <= 0 or amount > self._balance:
            return False
        self._balance -= amount
        self.check_repOK()
        # check_repOK()
        return True

class BonusBankAccount(BankAccount):
    def __init__(self, balance: float, bonus_interest: float):
        super().__init__(balance)
        self._bonus_interest = bonus_interest

    def deposit(self, amount: float) -> str:
        # REQUIRES: (same) amount must be positive
        # EFFECTS: (stronger) deposit and also add bonus interest

        stats = super().deposit(amount)
        if stats:
            # deposit successful, add interest
            self._balance += self._bonus_interest * amount
        
        # check_repOK()
        return stats


    def withdraw(self, amount: float) -> bool:
        """
        REQUIRES: (weaker) allow zero withdrawals, which are ignored
        EFFECTS: (same) balance is the original balance minus withdrawn amount
        """
        if amount == 0:
            return True  # Zero withdrawal is considered a no-op
        ret =  super().withdraw(amount)
        # check_repOK()
        return ret
    
    
    def repOK(self):
        """
        Stronger Rep-inv: balance and bonus interest must be non-negative
        """
        return super().repOK() and self._bonus_interest >= 0
        
    \end{lstlisting}
\caption{Liskov Substitution Principle demonstration}\label{ex:bankaccount}
\end{figure}

\section{Encapsulation}
Encapsulation is a fundamental concept in OOP that combines data and methods into a single unit called a class. Encapsulation allows the class to control access to its data and methods, ensuring that they are used correctly and consistently. This helps to prevent misuse and errors, and promotes good design practices such as information hiding and modularity.

Encapsulation is achieved through the use of access modifiers, which specify the level of access to class members. In Java, access modifiers are enforced by the language, and there are four levels of access: \emph{private}, \emph{protected}, \emph{package-private} (default), and \emph{public}.  In Python, access modifiers are not enforced by the language, but conventions are used to indicate the intended level of access. For example, underscore (\_) is used to indicate private or protected attribute (variable). %, and a double underscore (\_\_) is used to indicate a private attribute. 

Encapsulation avoids direct access to the internal representation of a class, e.g., rep-invariants, which can lead to unintended side effects and break the class's invariants. Instead, access to the class's data should be controlled through methods, such as \code{getters} and \code{setters} methods.

In the \code{BankAccount} class in \autoref{ex:bankaccount}, the \code{\_balance} attribute is a private member, and access to it is controlled through the \code{deposit} and \code{withdraw} methods. This ensures that the balance is updated correctly and that the rep-invariant is maintained (\code{repOK}). The \code{BonusBankAccount} class extends \code{BankAccount} and adds a \code{\_bonus\_interest} attribute, which is also a private member that is not exposed directly. 



\subsection{In-class: Polymorphism concepts: Vehicle}

You will design a system that models different types of vehicles (e.g., cars, bicycles). Each vehicle has the ability to start, stop, and display its details. Vehicles should differ in their implementation of these behaviors. You will use abstract classes and interfaces to define the basic structure and ensure that your system adheres to OOP principles.

\begin{enumerate}
    \item Create an abstract class \code{Vehicle} that has
    \begin{enumerate}
        \item An encapsulated attribute for \code{speed}.
        \item Abstract methods: \code{start()}, \code{stop()}, and \code{display()}.
    \end{enumerate}
    \item Define an interface called \code{Refuelable}, with a method \code{refuel(amount:int)}
    \item Create concrete subclasses
    \begin{enumerate}
	    \item Create \code{Car} and \code{Bicycle} classes that inherit from \code{Vehicle}.
	    \item Car also implements the \code{Refuelable} interface (because it uses fuel).
	    \item Implement methods to \code{start}, \code{stop}, \code{display}, and \code{refuel} if applicable.
	    \item Ensure each class encapsulates its specific properties (e.g., \code{fuel\_level} for cars).
    \end{enumerate}
    \item Demonstrate Polymorphism and other OOP principles
    \begin{enumerate}
        \item Create a function \code{operate\_vehicle(vehicle:Vehicle)} that accepts any vehicle type and calls its \code{start}, \code{stop}, and \code{display} methods. This function demonstrates polymorphism and dynamic dispatching.
        \item Create test cases to demonstrate LSP by substituting instances of \code{Car} and \code{Bicycle} for \code{Vehicle} in the \code{operate\_vehicle} function. 
        \item Protect rep data and other attributes and access them through setters and getters methods.
    \item Provide proper document and specifications for your code (e.g., class Overview, rep-invs, method specifications, AF, \code{repOK}).
    \end{enumerate}

\end{enumerate}

\section{Exercise}

\subsection{LSP: Market subtype}

Determine whether the \code{LowBidMarket} and \code{LowOfferMarket} classes below are proper subtypes of \code{Market}. Specifically, for each method, list whether the precondition is weaker, the postcondition is stronger, and conclude whether LSP holds.

Note that this is purely a ``paper and pencil'' exercise. No code is required. Write your answer so that it is easily understandable by someone with only a passing knowledge of Liskov's rules for subtypes.


\begin{lstlisting}
class Market:
    def __init__(self):
        self.wanted = set()  # items for which prices are of interest
        self.offers = {}     # offers to sell items at specific prices

    def offer(self, item, price):
        """
        Requires: item is an element of wanted.
        Effects: Adds (item, price) to offers.
        """
        if item in self.wanted:
            if item not in self.offers:
                self.offers[item] = []
            self.offers[item].append(price)

    def buy(self, item):
        """
        Requires: item is an element of the domain of offers.
        Effects: Chooses and removes some (arbitrary) pair (item, price) from
                    offers and returns the chosen price.
        """
        if item in self.offers and self.offers[item]:
            return self.offers[item].pop(0)  # Removes and returns the first price
        return None

class LowBidMarket(Market):
    def offer(self, item, price):
        """
        Requires: item is an element of wanted.
        Effects: If (item, price) is not cheaper than any existing pair
                    (item, existing_price) in offers, do nothing.
                    Else add (item, price) to offers.
        """
        if item in self.wanted:
            if item not in self.offers:
                self.offers[item] = []
            # Only add if price is lower than existing prices
            if not self.offers[item] or price < min(self.offers[item]):
                self.offers[item].append(price)

class LowOfferMarket(Market):
    def buy(self, item):
        """
        Requires: item is an element of the domain of offers.
        Effects: Chooses and removes the pair (item, price) with the 
                    lowest price from offers and returns the chosen price.
        """
        if item in self.offers and self.offers[item]:
            # Find and remove the lowest price from the list
            lowest_price = min(self.offers[item])
            self.offers[item].remove(lowest_price)
            return lowest_price
        return None                
\end{lstlisting}

\subsection{LSP: Reducer}
\begin{figure}
\begin{lstlisting}
class A:
    def reduce(self, x):
        """
        Effects: if x is None, raise ValueError;
                 if x is not appropriate, raise TypeError;
                 else, reduce this by x.
        """

class B:
    def reduce(self, x):
        """
        Requires: x is not None.
        Effects: if x is not appropriate, raise TypeError;
                 else, reduce this by x.
        """

class C:
    def reduce(self, x):
        """
        Effects: if x is None, return normally with no change;
                 if x is not appropriate, raise TypeError;
                 else, reduce this by x.
        """
\end{lstlisting}
\caption{LSP Exercise}\label{ex:lsp-exercise}
\end{figure}

For the classes \code{A}, \code{B}, and \code{C} in \autoref{ex:lsp-exercise}, determine whether LSP holds in the following cases. Specifically, for each case, list whether the precondition is weaker, the postcondition is stronger, and conclude whether LSP holds.
\begin{enumerate}
    \item \code{B} extends \code{A}.
    \sol{B's pre is stronger than A's because it requires that $x$ is not None while A's has no pre. \textbf{LSP does not hold}. The posts of \code{A} and \code{B} are the same}
    \item \code{C} extends \code{A}
    \sol{Pre's are the same (both are total methods). C's post is stronger than A's because it allows $x$ to be None while A's does not. \textbf{LSP holds}.}
    \item \code{A} extends \code{B}
    \sol{A's pre is weaker than B's because A has no pre. The posts for both are essentially the same because B's pre explicitly requires $x$ to be not None. \textbf{LSP holds}. Note that you might argue A's post is stronger, which is also fine and also means LSP holds.}
    \item \code{C} extends \code{B}
    \sol{C's pre is weaker than B's because C allows $x$ to be None while B does not. The posts are the same. \textbf{LSP does not hold}.}
    \item \code{A} extends \code{C}
\end{enumerate}

\subsection{LSP Analysis}

Consider the following classes with their specifications for the \code{update()} method:

\begin{lstlisting}
class A:
    def update(self, value):
        """
        Effects/Post: If value is not valid, do nothing;
                 otherwise, update this with value.
        """

class B:
    def update(self, value):
        """
        Requires/Pre: value must be an integer.
        Effects/Post: If value is valid, update this with value;
                 otherwise, do nothing.
        """

class C:
    def update(self, value):
        """
        Effects/Post: If value is invalid, set default update;
                 otherwise, update this with value.
        """
\end{lstlisting}    

For each case below, determine if LSP holds by checking whether the preconditions are weaker and the postconditions are stronger, and conclude whether LSP holds. Note that as soon as one rule is violated, LSP does not hold.

\begin{enumerate}
    \item \code{B} extends \code{A}
    \item \code{C} extends \code{A}
    \item \code{A} extends \code{B}
    \item \code{C} extends \code{B}
    \item \code{A} extends \code{C}
\end{enumerate}
	% 1.	B extends A
	% •	Precondition Comparison:
	% •	Class B requires value to be an integer, which is a stricter requirement than A’s flexible acceptance of any value.
	% •	Postcondition Comparison:
	% •	The postconditions are similar; however, B may limit behavior compared to A by failing to handle non-integer values.
	% •	LSP Conclusion:
	% •	LSP does not hold because B’s preconditions are stricter, which violates the principle of substitutability.
	% 2.	C extends A
	% •	Precondition Comparison:
	% •	C has the same preconditions as A; it allows any value input without specific requirements, maintaining or weakening the base class preconditions.
	% •	Postcondition Comparison:
	% •	C has a stronger postcondition since it provides a default update when the value is invalid rather than doing nothing as A does.
	% •	LSP Conclusion:
	% •	LSP holds because C maintains weaker preconditions and provides a stronger postcondition compared to A.
	% 3.	A extends B
	% •	Precondition Comparison:
	% •	A’s precondition is weaker because it accepts all types of values, whereas B strictly requires integers.
	% •	Postcondition Comparison:
	% •	A does nothing when a value is not valid, which can be seen as weaker compared to B’s update rule for valid integers.
	% •	LSP Conclusion:
	% •	LSP does not hold because A’s postconditions are weaker and do not provide the expected behavior of the subclass B.
	% 4.	C extends B
	% •	Precondition Comparison:
	% •	C allows a broader range of inputs compared to B, which requires integers.
	% •	Postcondition Comparison:
	% •	C’s stronger postcondition of setting a default update when values are invalid provides additional functionality over B’s more limited action.
	% •	LSP Conclusion:
	% •	LSP holds because C has weaker preconditions and stronger postconditions compared to B.
	% 5.	A extends C
	% •	Precondition Comparison:
	% •	A and C share the same precondition of accepting any value without specific requirements.
	% •	Postcondition Comparison:
	% •	A’s postcondition is weaker because it does nothing when value is invalid, while C still performs a default update.
	% •	LSP Conclusion:
	% •	LSP does not hold because A provides weaker behavior than C and fails to maintain the expected outcome set by C.






\chapter{Iterators}
Iterators and generators are powerful constructs in OOP that enable efficient traversal and on-the-fly computation of sequences of data. They allow developers to handle large datasets, abstract complex data traversal patterns, and create custom iterators for any type of object. 

\section{Motivation}
Let’s consider a scenario where you need to generate Fibonacci numbers. A common but inefficient approach is to generate all Fibonacci numbers up to a certain limit and store them in a list, which consumes a lot of memory, especially for large sequences.

\begin{lstlisting}
def generate_fib_list(n: int) -> list[int]:
    fib_sequence = [0, 1]
    for _ in range(2, n):
        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])
    return fib_sequence

# Create the first 100K Fibs; consume lots of memory for storing all numbers
fib_numbers = generate_fib_list(10**6)  
print(fib_numbers[:10])  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] # only use first 10
\end{lstlisting}

This approach is inefficient because it generates all Fibonacci numbers up to a certain limit and stores them in a list, which consumes a lot of memory, especially for large sequences. Also, this approach is wasteful because it generates all Fibonacci numbers at once, even if only a few are needed.
A more efficient approach is to use an iterator or generator to produce Fibonacci numbers on the fly, only when needed.

\begin{lstlisting}
# Efficient generator function that yields Fibonacci numbers on demand
def fib_generator(n: int):
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

print(list(fib_generator(10))) # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
\end{lstlisting}

Using generator functions, we can efficiently generate Fibonacci numbers on demand, reducing memory consumption and improving performance. Generators produce values one at a time, only when needed, making them ideal for large datasets or infinite sequences.

\section{Brief History}
The concept of iterators in object-oriented programming was pioneered by the language CLU in the 1970s, developed by Barbara Liskov. CLU introduced iterators as a core language feature, allowing traversal of collections without exposing their internal structures, managing the iteration state internally. This innovation laid the foundation for modern iterator designs by demonstrating how encapsulating traversal logic could lead to cleaner, more maintainable code. C++ in the 1980s further popularized iterators through the Standard Template Library (STL), which abstracted the traversal of various collections, enhancing code reuse and flexibility. The importance of iterators was further solidified by the Design Patterns book by the Gang of Four (GoF) in 1994, which formalized the iterator pattern as a key design strategy, emphasizing the separation of traversal from the data structure itself.

Java, released in 1995, built on these ideas by integrating the Iterator interface into its collections framework, standardizing the way collections were traversed across the language. Java’s approach unified data traversal, promoting object-oriented principles like encapsulation and abstraction. The introduction of generators in Python in 2001 marked a significant evolution in iteration. Python’s yield keyword allowed functions to produce values lazily, one at a time, without storing the entire sequence in memory, enabling efficient data processing for large or infinite sequences. This approach made creating iterators more intuitive and readable, influencing other languages and underscoring the importance of efficient iteration mechanisms in modern programming.

\section{Iterators}

An iterator is an ADT that allows you to traverse through all the elements of a collection, such as a list, tuple, or custom data structure, without exposing the underlying details of the collection (i.e., promoting encapsulation). 

Key Concepts of Iterators:
\begin{itemize}
\item Iteration Methods: An iterator object implements two key methods: \code{\_\_iter\_\_()} and \code{\_\_next\_\_()}.
\begin{itemize}
    \item \code{\_\_iter\_\_()}: Returns the iterator object itself and is implicitly called at the start of loops.
	\item \code{\_\_next\_\_()}: Returns the next element in the sequence and raises a StopIteration exception when there are no more elements.
\end{itemize}
\item State Management: Iterators manage their own state, allowing them to keep track of the current position in the collection.
\end{itemize}

\begin{lstlisting}
# Creating an iterator for a countdown
class Countdown:
    def __init__(self, start: int):
        self.current = start

    def __iter__(self): return self

    def __next__(self):
        if self.current <= 0:
            raise StopIteration  # End of iteration
        else:
            current_value = self.current
            self.current -= 1
            return current_value

# Usage of the custom iterator
countdown = Countdown(5)
for number in countdown:
    print(number)
# Output: 5, 4, 3, 2, 1
\end{lstlisting}

In the example above, the \code{Countdown} class implements iteration by defining the \code{\_\_iter\_\_()} and \code{\_\_next\_\_()} methods. The \code{\_\_iter\_\_()} method returns the iterator object itself, while \code{\_\_next\_\_()} manages the countdown state by returning the next element in the countdown sequence and stopping the iteration by raising the \code{StopIteration} exception when the countdown reaches zero.


\paragraph{Benefits of Iterators}
\begin{itemize}
\item Memory Efficiency: Iterators retrieve elements one at a time, reducing memory usage compared to loading all elements at once.
\item Encapsulation: Iterators hide the internal structure of the collection, providing a clean, consistent interface for traversal.
\item Flexibility: Custom iterators can be defined for any object, making them adaptable to a wide range of data structures.
\end{itemize}


\section{Generator}
A generator is a special iterator that uses the \code{yield} keyword. Generators allow you to turn a method into one that behaves like an iterator, without having to create a separate iterator class. Generator thus has the same benefits as iterators, such as memory efficiency and encapsulation, and does not require the explicit implementation of the \code{\_\_iter\_\_()} and \code{\_\_next\_\_()} methods.

\begin{lstlisting}
# Generator function for a countdown
def countdown(start: int):
    while start > 0:
        yield start
        start -= 1

# Usage of the generator
for number in countdown(5):
    print(number)
# Output: 5, 4, 3, 2, 1
\end{lstlisting}

Instead of defining the \code{Countdown} class as an iterator, the \code{countdown} function is defined as a generator that yields the countdown sequence.
Each call to \code{yield} returns the current value of \code{start} and saves the function's state, allowing it to resume where it left off when called again.

\paragraph{Benefits of Generators}
\begin{itemize}
    \item Conciseness: Generators provide a more straightforward syntax for creating iterators.
	\item Performance: They generate values on demand, reducing memory consumption compared to traditional lists.
	\item Enhanced Readability: Generator functions are typically easier to understand and maintain compared to an iterator class.    
\end{itemize}   

\section{In-Class Exercise: Prime Number}\label{ex:prime-number}

A \emph{prime number} is a natural number greater than 1 that has no positive divisors other than 1 and itself. In this exercise, you will implement three different approaches to generate prime numbers: a non-iterator method, a custom iterator class, and a generator function. You will compare the performance of these approaches and observe the benefits of using iterators and generators.

\begin{enumerate}
    
    \item Write a non-iterator and non-generator method \code{gen\_prime} that generates prime numbers up to a specified limit.
    \begin{enumerate}
    \item Test the iterator by printing all prime numbers that is less than 50.
    \item Measure the performance of the iterator by generating all prime numbers that your computer can handle (in Python, use \code{time(...)}).  Try various limits and measure the time.
    \end{enumerate}

\item Write a custom iterator called \code{PrimeNumberIterator} that generates prime numbers up to a specified limit.
\begin{enumerate}
    \item The class needs to have \code{\_\_iter\_\_()} and \code{\_\_next\_\_()} methods.
    \item Use a helper function to check for prime numbers (reuse the code in \code{gen\_prime}).
    \item Raise \code{StopIteration} when the current number exceeds the limit.
    \item Test the iterator by printing all prime numbers that is less than 50.
    \item Measure the performance of the iterator by generating all prime numbers that your computer can handle like before.  Try various limits and measure the time.
\end{enumerate}
\item Write a generator function called \code{gen\_prime\_generator} that yields prime numbers up to a specified limit (this means using the \code{yield} keyword).
\begin{enumerate}
    \item Test the generator by printing all prime numbers that is less than 50.
    \item Measure the performance of the generator by generating all prime numbers that your computer can handle like before.  Try various limits and measure the time.
\end{enumerate}
\end{enumerate}

% class PrimeNumberIterator:
%     def __init__(self, limit):
%         self.limit = limit
%         self.current = 2

%     def __iter__(self):
%         return self

%     def __next__(self):
%         while self.current <= self.limit:
%             if self.is_prime(self.current):
%                 prime = self.current
%                 self.current += 1
%                 return prime
%             self.current += 1
%         raise StopIteration

%     @staticmethod
%     def is_prime(n):
%         if n < 2:
%             return False
%         for i in range(2, int(n**0.5) + 1):
%             if n % i == 0:
%                 return False
%         return True

\section{Exercise}
\subsection{Perfect Number Generation}

A \emph{perfect number} is a positive integer that is equal to the sum of its proper divisors, excluding itself (e.g., 6, 28). You will implement three different approaches to find perfect numbers up to a given limit, comparing their performance and resource usage.  

For this exercise, you can use either Python or Java and submit your code with \emph{clear documentation} on how to run and test your code. That is, you must explicitly state the commands to run your code and the expected output. You will also need to provide screenshots or logs of the execution results, including the time taken and memory usage.  

If you do not provide clear documentation, you will not receive credit. If we cannot run your code, you will not receive credit. If we do not see the results you claim, you will not receive credit. 

\begin{enumerate}
\item Part 1: Generate Perfect Numbers Without Iterators or Generators.  Write a method \code{gen\_perfect} that generates perfect numbers up to a given positive value \code{n}, i.e., generate perfect numbers less than or equal to \code{n}.  You will not use iterators or generators and store all perfect numbers in a list.
\begin{enumerate}
    \item Play around with different \code{n} (e.g., 10,000, 100,000) to see how the program performs. Aim for about 20 seconds of execution time.
    \item Print out the first 5 perfect numbers generated.
    \item Measure execution time and memory usage, which should be relatively high due to high computational demands and storage of all perfect numbers.
\end{enumerate}

\item Part 2: Implement a custom iterator called \code{PowerNumberIterator} for perfect numbers. You can reuse the code from part 1.  After that, do exactly the analysis that you did in Part 1, i.e., play with different \code{n} values, print out the first 5 numbers generated, and measure the performance of the iterator.  You should see a significant improvement in memory usage and execution time compared to the non-iterator approach.
\item Part 3: Use a generator function \code{gen\_power\_generator} to yield perfect numbers.  Reuse the code from part 1 and make changes to it to use generator.  Then do the same analysis as in Part 1 and Part 2.
\item Part 4: Write a short report comparing the performance of the three approaches.  Include the time taken, memory usage, and ease of implementation.  Discuss the benefits of using iterators and generators over the non-iterator approach.
\end{enumerate}

\subsection{Iterators and Generators Multiple Choice}


\begin{enumerate}
\item What does this class represent?
\begin{lstlisting}
    class Counter:
        def __init__(self, start, end):
            self.current = start
            self.end = end
    
        def __iter__(self):
            return self
    
        def __next__(self):
            if self.current > self.end:
                raise StopIteration
            else:
                self.current += 1
                return self.current - 1
    \end{lstlisting}
\begin{enumerate}
    \item A list that can be iterated through once.
    \item An infinite loop that never stops.
    \item An iterator that generates numbers between \texttt{start} and \texttt{end}, inclusive.
    \item A generator function that yields values on demand.
\end{enumerate}

%\textbf{Correct Answer:} C



\item What is the primary benefit of using a generator in this example?
\begin{lstlisting}
    def count_down(n):
        while n > 0:
            yield n
            n -= 1
    \end{lstlisting}

\begin{enumerate}
    \item It stores all the countdown numbers in memory at once.
    \item It allows for lazy evaluation, producing numbers one at a time without storing the entire sequence in memory.
    \item It is faster than using a list comprehension.
    \item It automatically handles errors.
\end{enumerate}

%\textbf{Correct Answer:} B

\item What is yielded by the generator function \texttt{fibonacci}?

\begin{lstlisting}
    def fibonacci(n):
        a, b = 0, 1
        for _ in range(n):
            yield a
            a, b = b, a + b
\end{lstlisting}

\begin{enumerate}
    \item The sum of all Fibonacci numbers up to \texttt{n}.
    \item Fibonacci numbers up to \texttt{n}, one by one, using lazy evaluation.
    \item A list of the first \texttt{n} Fibonacci numbers.
    \item The Fibonacci sequence stored as a tuple.
\end{enumerate}

%\textbf{Correct Answer:} B

\item What happens if you try to convert the generator \texttt{generate\_squares} to a list?

\begin{lstlisting}
    def generate_squares(limit):
        for i in range(limit):
            yield i ** 2
    \end{lstlisting}

\begin{enumerate}
    \item It will yield values one by one without storing them in memory.
    \item It will return an error when converted to a list.
    \item It will be exhausted and return an empty list.
    \item It will create a list of square numbers up to \code{limit - 1}.
\end{enumerate}

%\textbf{Correct Answer:} D


\item What is the purpose of the \texttt{infinite\_numbers} generator?
\begin{lstlisting}
    def infinite_numbers():
        num = 0
        while True:
            yield num
            num += 1
    \end{lstlisting}
\begin{enumerate}
    \item It generates numbers up to a fixed limit.
    \item It generates a series of numbers starting from 0, but stops after a certain point.
    \item It generates an infinite sequence of numbers, producing them one at a time.
    \item It returns a list of numbers in ascending order.
\end{enumerate}

%\textbf{Correct Answer:} C
\end{enumerate}



\chapter{First-Class Functions}

In modern OOP, functions are treated as \emph{first-class} citizens, meaning they can be assigned to variables, passed as arguments, and returned from other functions.


\begin{lstlisting}
    def greet(name):
        return f"Hello, {name}!"

    # Assigning the function to a variable
    greeting = greet

    # Now the variable `greeting` can be used like the function `greet`
    print(greeting("Alice"))  # Output: Hello, Alice!
\end{lstlisting}

In this example, the \code{greet} function is assigned to a variable \code{greeting}, which can then be called like a regular function. 

\begin{lstlisting}
    def apply(op, a, b):
        return op(a, b)

    def add(x, y):
        return x + y

    def subtract(x, y):
        return x - y

    # Passing functions as arguments
    result_add = apply_op(add, 10, 5)       # Output: 15
    result_subtract = apply_op(subtract, 10, 5)  # Output: 5
\end{lstlisting}

For this example, \code{apply\_op} takes another function \code{op} as an argument and applies it to the given arguments. This allows for dynamic behavior based on the function passed to \code{apply\_op}.



\paragraph{History} Lisp, developed by John McCarthy in the late 1950s, was one of the first languages to treat functions as first-class citizens. Lisp's approach to functions was heavily influenced by \emph{lambda calculus}, developed by Alonzo Church in the 1930s, which formalized functions as mathematical expressions. Lisp's support for first-class functions allows for powerful programming techniques, such as higher-order functions (\autoref{sec:higher-order}).  Nowadays, most modern programming languages including Python, JavaScript, and Ruby treat functions as first-class citizens. 

\section{Anonymous and Lambda Functions}\label{sec:lambda}
A popular use for first-class functions is to create \emph{anonymous} or \emph{lambda} functions, which are unnamed functions defined on the fly. Lambda functions are useful for short, simple operations that do not require a full function definition. 
\begin{lstlisting}
# Lambda function to square a number
square = lambda x: x ** 2
print(square(5))  # Output: 25
\end{lstlisting}

In the example above, a lambda function is used to define a function that squares a number. The lambda function is assigned to the variable \code{square} and can be called like a regular function.
Lambda functions are often used in conjunction with higher-order functions like \code{map}, \code{filter}, and \code{reduce}, described in \autoref{sec:higher-order}, to perform operations on collections of data.

\section{Higher-Order Functions}\label{sec:higher-order}

In the world of first-class functions, functions that operate on other functions are called \emph{higher-order functions}. More specifically, a higher-order function is a function that takes one or more functions as arguments or returns a function as its result.

\begin{lstlisting}
    def square(x):
        return x * x

    def cube(x):
        return x * x * x

    def apply_to_list(func, numbers):
        return [func(number) for number in numbers]

    numbers = [1, 2, 3, 4, 5]
    print(apply_to_list(square, numbers))  # Output: [1, 4, 9, 16, 25]
    print(apply_to_list(cube, numbers))    # Output: [1, 8, 27, 64, 125]

\end{lstlisting}

In this example, the higher-order function \code{apply\_to\_list} takes a function and a list of numbers as inputs and applies the function to each number in the list, returning a new list with the results. 


\subsection{Popular Higher-Order Functions}

Higher-order functions are commonly used in functional programming and are available in many programming languages. Three popular higher-order functions include:

\begin{itemize}
    \item \code{map(f, iterable)}: Applies a function \code{f} to each item in an iterable (e.g., list, tuple) and returns a new iterable with the results.\\
    Example: \code{list(map(square, [1,2,3,4,5]))} returns \code{[1, 4, 9, 16, 25]}.
    \item \code{filter(f, iterable)}: Filters elements in an iterable based on a predicate \code{f} (i.e., a function that returns a boolean value).\\
    Example: \code{list(filter(lambda x: x \% 2 == 0, [1,2,3,4,5]))} returns \code{[2, 4]}. Lambda functions are discussed in the next section (\autoref{sec:lambda}).
    \item \code{reduce(f, iterable)}: Applies a binary function \code{f} to the first two items of an iterable, then to the result and the next item, and so on. It returns a single value.\\
    Example: \code{reduce(lambda x, y: x + y, [1,2,3,4,5])} returns \code{15}. 
\end{itemize}

\paragraph{Fun fact} While \code{reduce} is well-known in functional languages such as Haskell and Ocaml, the Python community believes that list comprehensions and generator expressions made the code more readable than \code{reduce}. Thus, in Python 3, \code{reduce} was moved to the \code{functools} module to emphasize its specialized use case.

For example, compare the following code snippets that calculate the sum of a list of numbers using \code{reduce} and list comprehension:
\begin{lstlisting}
# Calculate the sum of a list of numbers using reduce
numbers = [1, 2, 3, 4, 5]
total = reduce(lambda x, y: x + y, numbers)
print(total)  # Output: 15

# using list comprehension
total = sum(numbers)
print(total)  # Output: 15

# using generator expression
total = sum(x for x in numbers)
print(total)  # Output: 15
\end{lstlisting}

\paragraph{Fun fact} The MapReduce framework, introduced by Google in 2004, was inspired by \code{map} and \code{reduce} (``map'' distributes work across multiple nodes and the ``reduce'' aggregates the results).  It revolutionizes large-scale data processing and allows Google to index the web efficiently. It influences current web technologies such as Apache Hadoop and Apache Spark.




\section{Closures}
Closures are a higher-order function that returns a function. It is a powerful feature of first-class functions and allows functions to retain access to variables from their enclosing scope even after the scope has finished executing. It is a way to bind a function with its environment, allowing the function to access and manipulate variables that are not in its local scope. 

\paragraph{Fun fact} Closures are used extensively in Javascript, introduced in Netscape Navigator in 1995 by Bredan Eich. Javascript's support for closures and first-class functions enabled the development of dynamic and interactive web applications, leading to its widespread adoption and popularity.

\paragraph{Examples}

\begin{lstlisting}
def make_multiplier(factor):
    def multiplier(x):
        return x * factor
    return multiplier  # Return the inner function

# Create a function that multiplies by 3
times_three = make_multiplier(3)
print(times_three(5))  # Output: 15

# Using with higher-order functions
numbers = [1, 2, 3, 4, 5]
multiplied_numbers = list(map(make_multiplier(2), numbers))
print(multiplied_numbers)  # Output: [2, 4, 6, 8, 10]
\end{lstlisting}

The above example demonstrates a closure where the \code{make\_multiplier} function returns an inner function \code{multiplier} that multiplies a number by a given factor. The \code{times\_three} function is created by calling \code{make\_multiplier(3)}, which returns a function that multiplies by 3. The closure allows the \code{multiplier} function to retain access to the \code{factor} variable even after \code{make\_multiplier} has finished executing.

\begin{lstlisting}
    def make_averager():
    series = []

    def averager(new_value):
        series.append(new_value)
        total = sum(series)
        return total / len(series)

    return averager

    avg = make_averager()
    print(avg(10))  # Output: 10.0
    print(avg(11))  # Output: 10.5
    print(avg(12))  # Output: 11.0
    print(avg(13))  # Output: 11.5
\end{lstlisting}

In the example above, the \code{make\_averager} function creates a closure that calculates the average of a series of numbers. The \code{averager} function retains access to the \code{series} list, allowing it to accumulate values and calculate the average over time.
\section{In-Class Exercise: Lambda Functions and Closure}
In this exercise you will demonstrate the concepts of higher-order functions, lambda functions, and closure. Example code are written in Python but you can use Python or any other language that supports these features.

\begin{enumerate}
\item Part 1: Create a \emph{higher-order} function that applies different operations (addition, subtraction, multiplication) to two numbers.
\begin{enumerate}
\item Create a function called \code{operate\_on\_numbers (operation: function, a: int, b: int) -> int} that takes another function (operation) as an argument and applies that function to two numbers.
\item Create multiple simple functions \code{add}, \code{subtract}, \code{multiply} that can be passed as arguments to \code{operate\_on\_numbers}.
\item Test the function by applying each operation to two numbers and printing the results.
\begin{lstlisting}
    # Test the higher-order function
    print(operate_on_numbers(add, 5, 3))        # Output: 8
    print(operate_on_numbers(subtract, 5, 3))   # Output: 2
    print(operate_on_numbers(multiply, 5, 3))   # Output: 15
\end{lstlisting}

\end{enumerate}


\item Part 2: Modify the code from Part 1 to use \emph{lambda functions} 
\begin{enumerate}
\item Replace \code{add}, \code{subtract}, and \code{multiply} with lambda expressions.
\item Test the function by applying each operation to two numbers and printing the results.
\item Discuss when might using a lambda function be more advantageous? When might a named function be better?
\end{enumerate}


\item Part 3: Create a \emph{closure} that stores a base number and uses it to multiply with other numbers.
\begin{enumerate}
\item Create a function called \code{create\_multiplier(base: int) -> function} that takes a base number and returns a closure that multiplies other numbers by the base.
\item Test the closure by creating multiple multiplier functions with different base numbers and applying them to other numbers.
\begin{lstlisting}
    # Create closures
    double = create_multiplier(2)
    triple = create_multiplier(3)
    
    print(double(5))  # Output: 10
    print(triple(5))  # Output: 15
\end{lstlisting}
\end{enumerate}

\item Part 4: Combine all three concepts to create a flexible higher-order function that applies a lambda function within a closure.

\begin{enumerate}
\item Modify \code{create\_multiplier} to take a lambda function as input and return a closure that applies this lambda function to the result of the multiplication.
\item The returned closure will both multiply the input by the base number and apply the lambda function to the result.
\item Test the function by creating a closure that doubles a number and then squares the result.
\begin{lstlisting}
    # Create closures with different lambda functions
    double_then_square = create_custom_multiplier(2, lambda y: y ** 2)
    triple_then_add_five = create_custom_multiplier(3, lambda y: y + 5)
    
    print(double_then_square(4))  # Output: (4 * 2) ** 2 = 64
    print(triple_then_add_five(4))  # Output: (4 * 3) + 5 = 17    
\end{lstlisting} 
\end{enumerate}

% **Example Code**:

% ```python
% def create_custom_multiplier(n, func):
%     def multiplier(x):
%         return func(x * n)  # The closure captures `n` and applies `func` to the result
%     return multiplier


% ```


\end{enumerate}

\begin{enumerate}
\item Part 1: Higher-order Functions: Create a higher-order function that applies different operations (addition, subtraction, multiplication) to two numbers.
\begin{enumerate}
\item Create a function called \code{operate\_on\_numbers (operation: function, a: int, b: int) -> int} that takes another function (operation) as an argument and applies that function to two numbers.
\item Create multiple simple functions \code{add}, \code{subtract}, \code{multiply} that can be passed as arguments to \code{operate\_on\_numbers}.
\item Test the function by applying each operation to two numbers and printing the results.
\begin{lstlisting}
    # Test the higher-order function
    print(operate_on_numbers(add, 5, 3))        # Output: 8
    print(operate_on_numbers(subtract, 5, 3))   # Output: 2
    print(operate_on_numbers(multiply, 5, 3))   # Output: 15
\end{lstlisting}

\end{enumerate}

\item Part 2: Lambda Functions:  Modify the code from Part 1 to use \emph{lambda functions} 
\begin{enumerate}
\item Replace \code{add}, \code{subtract}, and \code{multiply} with lambda expressions.
\item Test the function by applying each operation to two numbers and printing the results.
\item Discuss when might using a lambda function be more advantageous? When might a named function be better?
\end{enumerate}


\item Part 3: Closures:  Create a closure that stores a base number and uses it to multiply with other numbers.
\begin{enumerate}
\item Create a function called \code{create\_multiplier(base: int) -> function} that takes a base number and returns a closure that multiplies other numbers by the base.
\item Test the closure by creating multiple multiplier functions with different base numbers and applying them to other numbers.
\begin{lstlisting}
    # Create closures
    double = create_multiplier(2)
    triple = create_multiplier(3)
    
    print(double(5))  # Output: 10
    print(triple(5))  # Output: 15
\end{lstlisting}
\end{enumerate}

\item Part 4: Combining Concepts: Combine all three concepts to create a flexible higher-order function that applies a lambda function within a closure.

\begin{enumerate}
\item Modify \code{create\_multiplier} to take a lambda function as input and return a closure that applies this lambda function to the result of the multiplication.
\item The returned closure will both multiply the input by the base number and apply the lambda function to the result.
\item Test the function by creating a closure that doubles a number and then squares the result.
\begin{lstlisting}
    # Create closures with different lambda functions
    double_then_square = create_custom_multiplier(2, lambda y: y ** 2)
    triple_then_add_five = create_custom_multiplier(3, lambda y: y + 5)
    
    print(double_then_square(4))  # Output: (4 * 2) ** 2 = 64
    print(triple_then_add_five(4))  # Output: (4 * 3) + 5 = 17    
\end{lstlisting} 
\end{enumerate}

% **Example Code**:

% ```python
% def create_custom_multiplier(n, func):
%     def multiplier(x):
%         return func(x * n)  # The closure captures `n` and applies `func` to the result
%     return multiplier


% ```


\end{enumerate}



\section{Decorators}
\section{Partial Functions}
\section{Currying}
\section{Functional Programming}


\chapter{Testing}

\chapter{Design Patterns}

\section{Creational Patterns}
\subsection{Singleton}
\subsection{Factory Method}

\section{Structural Patterns}
\section{Behavioral Patterns}



\section{Composition over Inheritance}


\appendix



\chapter{Miscs}


\bibliographystyle{abbrv}

\chapter{More Examples}
\section{ADT}
\subsection{Stack ADT}
\begin{figure}
    \begin{lstlisting}
        class Stack:
        """
        Overview: Stack is a mutable ADT that represents a collection of elements in LIFO.
        AF(c) = the sequence of elements in the stack in sorted order from bottom to top.
        rep-inv: 
            1. elements is a list (could be empty list, which represents and empty stack).
            2. The top of the stack is always the last element in the list.
        """
    
        def __init__(self):
            """
            Constructor
            EFFECTS: Initializes an empty stack.
            MODIFIES: self
            """
            self.elements = []
    
        def repOK(self):
            """
            EFFECTS: Returns True if the rep-invariant holds, otherwise False.
            The invariant checks:
            1. elements is a list.
            2. If the stack is non-empty, the top of the stack is the last element in the list.
            """
            # Check that elements is a list
            if not isinstance(self.elements, list):
                return False
            
            # If the stack is not empty, ensure that the top is the last element in the list.
            # This is implicitly guaranteed by the use of `list.append` for push and `list.pop` for pop,
            # so no further explicit check is needed for the "top as last element."
            return True
    
        def push(self, value):
            """
            MODIFIES: self
            EFFECTS: Adds value to the top of the stack.
            """
            self.elements.append(value)
    
        def pop(self):
            """
            MODIFIES: self
            EFFECTS: Removes and returns the top element from the stack. 
            Raises an exception if the stack is empty.
            """
            if self.is_empty():
                raise Exception("Stack is empty")
            return self.elements.pop()
    
        def is_empty(self):
            """
            EFFECTS: Returns True if the stack is empty, otherwise False.
            """
            return len(self.elements) == 0
    
        def __str__(self):
            """
            EFFECTS: Returns a string representation of the stack,
                     showing the elements from bottom to top.
            """
            # The abstraction function maps the list of elements to a stack view
            return f"Stack({self.elements})"
    \end{lstlisting}
    \caption{Stack ADT}\label{ex:stack}
\end{figure}
    

\end{document}


%repr-inv:https://ocw.mit.edu/courses/6-170-laboratory-in-software-engineering-fall-2005/1a1f80fa85176ed3cae09ccd74f902d3_lec8.pdf




