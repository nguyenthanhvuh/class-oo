\documentclass[oneside,11pt,dvipsnames]{book}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[margin=1.5in]{geometry}
\usepackage{soul}
% \usepackage[small,compact]{titlesec} %very powerful
\usepackage[most]{tcolorbox}
% \setsecnumdepth{subsection}
% \setcounter{tocdepth}{3}
\usepackage{multicol}
\usepackage{enumitem}
\usepackage{epigraph}
\usepackage{cite}
\usepackage{caption}
\captionsetup{font=small}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{hyperref}
\usepackage{wrapfig}
\setlength\intextsep{0pt} % remove extra space above and below in-line float
\usepackage{hyperref}
\hypersetup{
  colorlinks,
  citecolor=black,
  filecolor=black,
  linkcolor=blue,
  urlcolor=blue,
}
\usepackage{booktabs}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\scriptsize,
  language=python,
  morekeywords={assert},
  keywordstyle=\color{blue},
  commentstyle=\color{magenta},
  numbers=none,
  mathescape,
  stepnumber=1,
  numbersep=8pt,
  tabsize=4,
  showspaces=false,
  showstringspaces=false,
  emph={},
  emphstyle=\color{red}\bfseries
}

\usepackage{tikz}
\usetikzlibrary{calc}
\usepackage{xcolor}

\usepackage{anyfontsize}
\usepackage{sectsty}

\usepackage{etoolbox}

\newtoggle{usesol}
\settoggle{usesol}{false} % not sol version
\newcommand{\sol}[1]{\iftoggle{usesol}{\textbf{Sol:} #1}{}}
\newcommand{\notsol}[1]{\nottoggle{usesol}{#1}{}}
\newcommand{\solite}[2]{\iftoggle{usesol}{#1}{#2}}

\usepackage[makeroom]{cancel}

\newtcolorbox{mybox}{
  enhanced,
  boxrule=0pt,frame hidden,
  borderline west={2pt}{0pt}{green!75!black},
  colback=green!10!white,
  sharp corners
}

\newenvironment{commentbox}[1][]{
  \small
  \begin{mybox}
    {\small \textbf{#1}}
  }{
  \end{mybox}
}

\newtcolorbox{mydomesticbox}{
  enhanced,
  boxrule=0pt,frame hidden,
  borderline west={2pt}{0pt}{red!75!black},
  colback=blue!10!white,
  sharp corners
}

\newenvironment{domesticbox}[1][]{
  \small
  \begin{mydomesticbox}
    {\small \textbf{#1}}
  }{
  \end{mydomesticbox}
}

\renewcommand{\figurename}{Fig.}
\renewcommand{\tablename}{Tab.}
\def\Section{\S}
\renewcommand{\figureautorefname}{Fig.}
\renewcommand{\tableautorefname}{Tab.}
\makeatletter
\renewcommand{\chapterautorefname}{\S\@gobble}
\renewcommand{\sectionautorefname}{\S\@gobble}
\renewcommand{\subsectionautorefname}{\S\@gobble}
\renewcommand{\appendixautorefname}{\S\@gobble}
\makeatother

\newcommand{\mycomment}[3][\color{blue}]{{#1{{#2}: {#3}}}}
\newcommand{\tvn}[1]{\mycomment{TVN}{#1}}{}
\newcommand{\red}[1]{{\color{red}{#1}}}
\newcommand{\code}[1]{\texttt{#1}}

\begin{document}

\pagestyle{empty}
\begin{tikzpicture}[overlay,remember picture]

    % Background color
    \fill[
    black!2]
    (current page.south west) rectangle (current page.north east);

    % Rectangles
    \shade[
    left color=Dandelion,
    right color=Dandelion!40,
    transform canvas ={rotate around ={45:($(current page.north west)+(0,-6)$)}}]
    ($(current page.north west)+(0,-6)$) rectangle ++(9,1.5);

    \shade[
    left color=lightgray,
    right color=lightgray!50,
    rounded corners=0.75cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(.5,-10)$)}}]
    ($(current page.north west)+(0.5,-10)$) rectangle ++(15,1.5);

    \shade[
    left color=lightgray,
    rounded corners=0.3cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(.5,-10)$)}}] ($(current page.north west)+(1.5,-9.55)$) rectangle ++(7,.6);

    \shade[
    left color=orange!80,
    right color=orange!60,
    rounded corners=0.4cm,
    transform canvas ={rotate around ={45:($(current page.north)+(-1.5,-3)$)}}]
    ($(current page.north)+(-1.5,-3)$) rectangle ++(9,0.8);

    \shade[
    left color=red!80,
    right color=red!80,
    rounded corners=0.9cm,
    transform canvas ={rotate around ={45:($(current page.north)+(-3,-8)$)}}] ($(current page.north)+(-3,-8)$) rectangle ++(15,1.8);

    \shade[
    left color=orange,
    right color=Dandelion,
    rounded corners=0.9cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(4,-15.5)$)}}]
    ($(current page.north west)+(4,-15.5)$) rectangle ++(30,1.8);

    \shade[
    left color=RoyalBlue,
    right color=Emerald,
    rounded corners=0.75cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(13,-10)$)}}]
    ($(current page.north west)+(13,-10)$) rectangle ++(15,1.5);

    \shade[
    left color=ForestGreen,
    rounded corners=0.3cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(18,-8)$)}}]
    ($(current page.north west)+(18,-8)$) rectangle ++(15,0.6);

    \shade[
    left color=ForestGreen,
    rounded corners=0.4cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(19,-5.65)$)}}]
    ($(current page.north west)+(19,-5.65)$) rectangle ++(15,0.8);

    \shade[
    left color=OrangeRed,
    right color=red!80,
    rounded corners=0.6cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(20,-9)$)}}]
    ($(current page.north west)+(20,-9)$) rectangle ++(14,1.2);



    % Title
    \node[align=center] at ($(current page.center)+(0,-5)$)
    {
    {\fontsize{38}{1} \selectfont {{OOP Design and Specification}}}\\[0.5in]

    {\fontsize{14}{19.2} \selectfont \textcolor{ForestGreen}{ \bf ThanhVu (Vu) Nguyen}}\\[0.1in]
    \today{} (latest version available on  \href{https://nguyenthanhvuh.github.io/class-oo/oop.pdf}{nguyenthanhvuh.github.io/class-oo/oop.pdf})
    };
    \end{tikzpicture}


\chapter*{Preface}



\newpage
\tableofcontents


\chapter{Introduction}\label{sec:intro}

This book will guide you through the fundamentals of constructing high-quality software using a modern \textbf{object-oriented programming} (OOP) approach.  We will use \emph{Python} for demonstration, but the concepts can be applied to any object-oriented programming language.  The goal is to develop programs that are reliable, efficient, and easy to understand, modify, and maintain.


\section{Decomposition}\label{sec:decomposition}

As the size of a program increases, it becomes essential to \emph{decompose} the program into smaller, independent programs (or functions or modules). This decomposition process allows for easier management of the program, especially when multiple developers are involved.   This makes the program easier to understand and maintain.




%\subsection{Decomposition}

Decomposition is the process of breaking a complex program into smaller, independent, more manageable programs, i.e., ``divide and conquer''. It allows programmer to focus on one part of the problem at a time, without worrying about the rest of the program.

\paragraph{Example} \autoref{ex:mergesort} shows a Python implementation of \emph{Merge Sort}, a classic example of problem decomposition. It breaks the problem of sorting a list into simpler problems of sorting smaller lists and merging them.

\begin{figure}[t]
\begin{lstlisting}[multicols=2]
def merge_sort(lst):
    if len(lst) <= 1:
        return lst

    mid = len(lst) // 2
    left = merge_sort(lst[:mid])
    right = merge_sort(lst[mid:])
    return merge(left, right)







def merge(left, right):
    result = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])
    return result
\end{lstlisting}
 \caption{Decomposition example: Mergesort}\label{ex:mergesort}
\end{figure}


\section{Abstraction}\label{sec:abstraction}



\emph{Abstraction} is a key concept in OOP that allows programmers to hide the implementation details of a program and focus on the essential features. By decoupling the \textbf{what} (the  behavior specification) from the \textbf{how} (the actual implementation), programmers could focus on higher-level design and reuse code more effectively.
In an OOP language such as Python, you can abstract problems by creating functions, classes, and modules that hide the underlying implementation details.

\paragraph{Example} \autoref{ex:mammal} demonstrates an abstraction for different types of mammals. Mammals such as Dog and Cat share common behaviors such as making noise (speak). We can create a class \code{Mammal} that defines these common behaviors, and then subclasses \code{Dog} and \code{Cat} that inherit from \code{Mammal} and define their own unique behaviors.  These are abstract data types that allow us to work with mammals. Also notice the specification (e.g., \code{REQUIRES}) in the comments that describe what the method does, not how it does it.

\begin{figure}[t]
\begin{lstlisting}[multicols=2]
class Mammal:
    def __init__(self, name):
        self.name = name

    def speak(self): pass

class Dog(Mammal):
    def speak(self): 
        """
        EFFECTS: Return the sound of a dog.
        """
        return "Woof!"


class Cat(Mammal):
    def speak(self):
        """
        EFFECTS: Return the sound of a dog.
        """
        return "Meow!"
    

\end{lstlisting}
 \caption{Decomposition example: Mergesort}\label{ex:mammal}
\end{figure}

\chapter{Procedural Abstraction}\label{chap:procedural-abstraction}

\emph{Procedural abstraction} is a fundamental concept in programming that allows developers to create functions (methods) that hide the implementation details of a program. By abstracting away the details, developers can focus on the essential features of the program, making it easier to understand, modify, and maintain. 

By separating procedure definition and invocation, we make two important methods of abstraction: abstraction by parameterization and abstraction by specification.

\paragraph{Abstraction by Parameterization}

This generalizes a function by using \emph{parameters}. This allows the function to be used with different input values, making it more versatile and reusable. \autoref{ex:abs-parameterization} shows an example of abstract parameterization. The \code{cal\_area} function calculates the area of a rectangle given its length and width, which are passed as parameters.

\begin{figure}[h]
    \begin{lstlisting}
    def cal_area(length, width):
        return length * width

    # can be used with different values for length and width.
    area1 = cal_area(5, 10)
    area2 = cal_area(7, 3)
\end{lstlisting}
\caption{Example: Abstract Parameterization}\label{ex:abs-parameterization}
\end{figure}



\paragraph{Abstraction by Specification} This specifies on what the function does (e.g., sorting), instead of how it does it (e.g., using quicksort or mergsort algorithms, implemented in C). By defining a function's behavior through \emph{specifications}, developers can implement the function in different ways as long as it fulfills the specifications. Similarly, the user can use the function without knowing the implementation details.

\autoref{ex:abs-specification} shows an example of abstraction by specification. The \code{exists} method return true if the \code{target} item is found in a list of sorted \code{items}. The user only needs to provide a sorted list and a target, but does not need to know what algorithm is used or implemented to determine if the item exists in the list.

\begin{figure}
\begin{lstlisting}
    def exists(items:List[int], target:int) -> bool:
        """
        Find an item in a list of sorted items.

        Pre: List of sorted items
        Post: True if the target is found, False otherwise.
        """
        ...

    # The user only needs to know that this function checks 
    # for the existence of an item in a sorted list. 
    # They don't need to know the search algorithm or implementation.
\end{lstlisting}
\caption{Abstraction by Specification}\label{ex:abs-specification}
\end{figure}

\section{Specifications}\label{sec:specifications}

We define abstractions through specifications, which describe what the abstraction is intended to do rather than how it should be implemented. This allows specifications to be much more concise and easier to read than the corresponding code.

Specifications which can be written in either \emph{formal} or \emph{informal languages}. Formal specifications have the advantage of being precise and unambiguous. However, in practice, we often use informal specifications, describing the behavior of the abstraction in plain English (e.g., the \code{sorting} example in \autoref{ex:abs-specification}).  Note that a specification is not a programming language or a program. Thus, our specifications won’t be written in code (e.g., in Python or Java)

\subsection{Specifications of a Function}
%3.3 Liskov

The specification of a function consists of a \emph{header} and a \emph{description} of its behavior.
The header gives the signature of the function, including its name, parameters, and return type. The description describes the function's behavior, including its preconditions and postconditions.

\paragraph{Header} The header provides the \emph{name} of the function, the number, order, and types of its \emph{parameters} (inputs), and the type of its return value (output). For instance, the headers for the \code{sort\_items} function in \autoref{ex:abs-specification} and the \code{cal\_area} function in \autoref{ex:abs-parameterization} are as follows

\begin{lstlisting}
def exists(items: list) -> bool: ...
def calc_area(length: float, width: float) -> float: ...
\end{lstlisting}

Note that in a language like Java, the header also provides \emph{exceptions} that the function may throw.

\paragraph{Preconditions and Postconditions}

A typical function specification in an OOP language such as Python includes: \emph{Preconditions} (also called the ``requires'' clause) and \emph{Postconditions} (also called the ``effects'' clause). Preconditions describe the conditions that must be true before the function is called. Typically these state the constraints or assumptions about the input parameters. If there are no preconditions, the clause is often written as \code{None}.

Postconditions, under the assumption that the preconditions are satisfied, describe the conditions that will be true after the function is called. These typically state the expected results or outcomes of the function. Moreover, they often describe the relationship between the inputs and outputs.


The clauses are usually written as \emph{comments} above the function definition, making them easily accessible within the code.


\begin{lstlisting}
def calc_area(length: float, width: float) -> float:
    """
    Calculates the area of a rectangle given its length and width.

    Pre: None
    Post: The area of the rectangle.
    """
    ...
\end{lstlisting}

For example, the specification of the \code{calc\_area} function in \autoref{ex:abs-parameterization} has (i) no preconditions and (ii) the postcondition that the function returns the area of a rectangle given its length and width.  Similarly, the \code{exists} function in \autoref{ex:abs-specification} has the specification that given a list of sorted items (precondition), it returns true if the item is found in the list, and false otherwise (postcondition).  Note how the specification is written in plain English, making it easy to understand for both developers and users of the function.


\paragraph{Modifies} Another common clause in a function specification is \emph{modifies}, which describes the inputs that the function modifies. This is particularly useful for functions that modify their input parameters.

\begin{lstlisting}
def add_to_list(input_list, value):
    """
    Adds a value to the input list.

    Pre: None
    Post: Value is added to the input list.
    Modifies: the input list
    """
    ...
\end{lstlisting}


\subsection{In-class Exercise: User Equality}
This exercise touches on some thorny issues with inheritance. There is a lot going on in this example, but it is a good exercise to understand the subtleties of inheritance. 

\begin{enumerate}
    \item First, look at the \href{https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-}{Javadoc} to understand the behaviors \code{equals()} (while the specification is for Java, the idea is the same in Python).
    \begin{itemize}
        \item Specifically, read carefully the \emph{symmetric}, \emph{reflexive}, and \emph{transitive} properties of \code{equals()}.
        \item Ignore \emph{consistency}, which requires that if two objects are equal, they remain equal.
    \end{itemize}    
    \item For the \code{User} class in \autoref{ex:user}, does \code{equals()} satisfy the three equivalence relation properties? If not, what is the problem?
    \begin{itemize}
        \item Come up with several concrete test cases (e.g., create various \code{User} instances) to check the properties.
        \item If there is a problem, show the test case that demonstrates the problem.
        \item Explain why the problem occurs and come up with a fix.
    \end{itemize}
    \item So the same analysis for the \code{SpecialUser} class in \autoref{ex:specialuser}.
    \end{enumerate}
    
    % 1. Is the given implementation of `equals()` in class `SpecialUser` satisfy the 3 equivalence relation properties? If not, what is the problem? Be concrete: find a specific object (test case!) that demonstrates the problem. How does *inheritance* makes `equals()` in class `SpecialUser` harder to get right?
    

\begin{figure}
\begin{lstlisting}
    class User:
        def __init__(self, name):
            self.name = name

        def __eq__(self, other):
            if not isinstance(other, User):
                return False
            return self.name == other.name
\end{lstlisting}
\caption{User class}\label{ex:user}
\end{figure}


\begin{figure}
\begin{lstlisting}
    class SpecialUser(User):
        """Don't do this until you've done with User"""

        def __init__(self, name, id):
            super().__init__(name)
            self.id = id

        def __eq__(self, other):
            if not isinstance(other, SpecialUser):
                return False
            return super().__eq__(other) and self.id == other.id
\end{lstlisting}
\caption{SpecialUser class}\label{ex:specialuser}
\end{figure}



\section{Designing Specifications}\label{sec:design-specifications}
%Liskov 3.5

When designing specifications, it is important to consider several factors to ensure that the function is well-defined and can be used effectively. These factors include the \emph{strength} of the pre- and post-conditions, whether the function is \emph{total} or \emph{partial}, and the \emph{avoiding implementation details} in the specification.

\subsection{Weak Pre-conditions}m
For pre-conditions, we want as weak a constraint as possible to make the function more versatile, allowing it to handle a larger class of inputs.
Logically, a condition $x$ is weaker than another if it is \emph{implied} by the other $y$, i.e.,  $y \implies x$, or that $x$'s constraints are a superset of $y$'s. For example, the condition $x \le 5$ is weaker than $x \le 10$ and the input list is not sorted is weaker than the list is sorted (which is weaker than the list that is both sorted and has no duplicates).
The \emph{weakest} precondition is \emph{True}, which indicates no constraints on the input.


\subsection{Strong Post-conditions}

In contrast, for post-conditions, we want as strong a condition as possible to ensure that the function behaves as expected. A condition $y$ is stronger than another condition $x$ if $y$ implies $x$, i.e., $y \implies x$, or that $y$'s constraints are a strict subset of $x$'s. For example, the condition $x \le 10$ is stronger than $x \le 5$ or that the input list is sorted is stronger than the list is not sorted.


\subsection{Total vs Partial Functions}

A function is \emph{total} if it is defined for all legal inputs; otherwise, it is \emph{partial}. Thus a function with no precondition is total, while a function with the strongest possible precondition is partial.  Total functions are preferred because they can be used in more situations, especially when the function is used publicly or in a library where the user may not know the input constraints. Partial functions can be used when the function is used internally, e.g., a helper or auxiliary function and the caller is knowledgeable and can ensure its preconditions are satisfied.

The functions \code{calc\_area} function in \autoref{ex:abs-parameterization} and \code{add\_to\_list} in \autoref{ex:abs-specification} are total because they can be called with any input. The \code{exists} function in \autoref{ex:abs-specification} is partial because it only works with sorted lists.


\paragraph{Turning Partial Functions into Total Functions} It is often possible to turn a partial function into a total function in two steps. First, we move preconditions into postconditions and specify the expected behavior when the precondition is not satisfied, e.g., throws an \code{Exception}. Second, we modify the function to satisfy the new specification, i.e., handling the cases when the preconditions are not satisfied. For example, the \code{exists} function in \autoref{ex:abs-specification} is turned into the total function shown in \autoref{ex:abs-total}.

\begin{figure}
\begin{lstlisting}
def exists(items: List[int], target: int) -> bool:
    """
    Find an item in a list of sorted items.

    Pre: True
    Post: If the input items are not sorted, raise an exception.
          Return True if the item is found, False otherwise.


    """

    if not is_sorted(items):
        raise Exception(...)
\end{lstlisting}
\caption{Total Specification for the program in \autoref{ex:abs-specification}}\label{ex:abs-total}
\end{figure}


\subsection{In-class Exercise: Partial and Total Specifications for \code{tail}}

Consider the following code:

\begin{lstlisting}
def tail(my_list):
     result = my_list.copy()
     result.pop(0)
     return result
\end{lstlisting}

\begin{itemize}
     \item What does the implementation of \code{tail} do in each of the following cases? You might want to see the \href{https://docs.python.org/3/tutorial/datastructures.html}{Python document} for \code{pop}.  How do you know: Running the code or reading Python document?
     \begin{itemize}
         \item \code{list = None}
         \item \code{list = []}
         \item \code{list = [1]}  
         \item \code{list = [1, 2, 3]}
     \end{itemize}
     \item Write a \emph{partial specification} for \code{tail}
     \item Rewrite the specification to be \emph{total}. Use \emph{exceptions} as needed.
    \end{itemize}

\subsection{No implementation details}
The specification should not include any implementation details, such as the algorithm used or the data structures employed. This improves flexibility as it allows the function to be implemented in different ways as long as it satisfies the specification. For example, the \code{exists} function in \autoref{ex:abs-specification} does not specify the search algorithm used to find the item in the list.

Some common examples to avoid include: the mentioning of specific data structures (e.g., arrays, indices), algorithms (e.g., quicksort or mergesort), and exceptions (e.g., related to IndexError). Also avoid specifications mentioning indices because this implies the use of arrays.




%\chapter{Exception}
%Liskov 4 ,  but won't follow this because it talks about checked vs unchecked exceptions, which are not really applicable in Python.
\section{Exercise}

\subsection{Specification for Sorting}
Write the specification for the generic \code{ascending\_sort} method below. The specification should include preconditions and postconditions.
\begin{lstlisting}
    def ascending_sort(my_list):
        # REQUIRES/PRE: 
        # EFFECTS/POST: 
        ...
\end{lstlisting}
    


\subsection{Specification of Binary Search}

Come up with the specification for a \emph{binary search} implementation whose header is given below. Remember for precondition you want something as \emph{weak} as possible and for postcondition as \emph{strong} as possible. Note that binary search returns the \emph{location} (an non-neg integer) of the \code{target} value if found, and returns -1 if \code{target} is not found. 

\begin{lstlisting}
def binary_search(arr: List[int], target: int) -> int:
    """
    PRE/REQUIRES: 
    POST/EFFECTS: 
    """
    ... 
\end{lstlisting}


\subsection{Loan Calculator}\label{ex:loan}    

Consider a function that calculates the number of months needed to pay off a loan of a given size at a fixed \emph{annual} interest rate and a fixed \emph{monthly} payment. For example, a \$100,000 loan at an 8\% annual rate would take 166 months to discharge at a monthly payment of \$1,000, and 141 months to discharge at a monthly payment of \$1,100. (In both cases, the final payment is smaller than the others; we round 165.34 up to 166 and 140.20 up to 141.) Continuing the example, the loan would never be paid off at a monthly payment of \$100, since the principal would grow rather than shrink.

\begin{itemize}


\item Define a function satisfying the following specification:

\begin{lstlisting}
def months(principal: int, rate: float, payment: int) -> int:
    """
    Calculate the number of months required to pay off a loan.
    
    param principal: Amount of the initial principal (in dollars)
    param rate: Annual interest rate (e.g., 0.08 for 8%)
    param payment: Amount of the monthly payment (in dollars)
    
    Requires/Pre: principal, rate, and payment all positive and 
    payment is sufficiently large to drive the principal to zero.
    Effects/Post: return the number of months required to pay off the principal
    """
\end{lstlisting}

\begin{itemize}
    \item The precondition is quite strong, which makes implementing the method easy. The key step in your calculation is to change the principal on each iteration with the following formula (which amounts to monthly compounding):
    \begin{lstlisting}
new_principal = old_principal * (1 + monthly_interest_rate) - payment
    \end{lstlisting}

    \item To make sure you understand the point about preconditions, your code is required to be \emph{minimal}. Specifically, if it is possible to delete parts of your implementation and still have it satisfy the requirements, you'll earn less than full credit.
\end{itemize}
\item \emph{Total} specification: Now change the specification to \emph{total} in which the postcondition handles violations of the preconditions using \emph{exceptions}. In addition, provide a new implementation \code{month} that satisfies the new specification.
\end{itemize}
\subsection{Partial and Total Functions}

\begin{enumerate}
    \item Write the \emph{partial} specifications for the below two functions.
    \item Modify the specifications to make the functions \emph{total}.
    \item Modify the implementations of the two functions to satisfy the total specification.
\end{enumerate}

Recall that specifications do not deal with types (which are taken care by the function signature and enforced by the type system of compiler/interpreter).  In other words, you do not need to worry about types here and can assume conditions about types are satisfied.

\begin{lstlisting}
def divide(a:float, b:float) -> float:
    """
    PRE:
    POST:
    """
    return a / b

def get_average(numbers: list[float]) -> float:
    """
    PRE:
    POST:
    """
    total = sum(numbers)
    return divide(total, len(numbers))
\end{lstlisting}



\sol{For \code{divide}, precond is \code{b} cannot be 0, postcond is the result is the division of \code{a} by \code{b}. For \code{get\_average}, precond is the list cannot be empty (which cause division by 0), postcond is the result is the average of the numbers in the list. To make them total, we throw an exception when the precond is violated.}

\chapter{Data Abstraction}\label{chap:adt}
%Liskov 5

%This chapter focuses on \emph{abstract data type} (ADT), a foundation of OOP and key concept in programming that allows developers to separate how data is implemented from how it behaves. Through ADT, programmers can create new data types relevant to their application. These ADTs consist of objects and associated operations.

In 1974, Barbara Liskov and Stephen N. Zilles introduced the concept of Abstract Data Types (\emph{ADTs}) in their influential paper ``Programming with Abstract Data Types'' as part of their work on the CLU programming language at MIT. ADTs revolutionized software design by separating the specification of a data type from its implementation. This meant that developers could define operations on a data structure (such as stacks or queues) without exposing the details of how the data was managed internally. This idea of data abstraction improved modularity, making programs easier to modify, extend, and maintain.

For her pioneering contributions to programming languages and system design, particularly through her work on ADTs and CLU, Barbara Liskov was awarded the Turing Award in 2008. Today, ADTs are a cornerstone of modern programming, underlying the concepts of encapsulation and modularity in modern OOP languages like Java, Python, and Rust.

%The CLU language was the first to explicitly support ADTs using a construct called a cluster, which encapsulated both the data structure and the operations that acted on it. CLU also introduced several other innovative features like iterators, exceptions, and parameterized types, many of which influenced modern programming languages such as Java, Python, and C++. Though CLU never became widely used, the principles it introduced, especially ADTs, became foundational in software engineering, leading to more modular and reusable code.



%An ADT has two main components: \emph{parameterization} and \emph{specification}. Parameterization involves using parameters for flexibility, while specification means including operations as part of the data type, which abstracts away the underlying data representation. This ensures that even if the data structure changes, programs that rely on it remain unaffected, as they only interact with the operations rather than the data's internal structure.

%By abstracting data, developers can postpone decisions about data structures until they fully understand how the data will be used, leading to more efficient programs. ADT is also beneficial during program maintenance, as changes to the data structure affect only the type's implementation, not the modules using it.


\section{Specifications of an ADT}

The specification of ADT explains what the operations on the data type do, allowing users to interact with objects only via methods, rather than accessing the internal representation. 
As with functions (\autoref{chap:procedural-abstraction}), the specification for an ADT defines its behaviors without being tied to a specific implementation.


\paragraph{Structure of an ADT} In a modern OOP language such as Python or Java, data abstractions are defined using \emph{classes}. Each class defines a name for the data type, along with its constructors and methods.

\begin{figure}
    \begin{lstlisting}
class DataType:
    """
    Overview: A brief description of the data type and its objects.
    """

    def __init__(self, ...):
        """
        Constructor to initialize a new object.
        """

    def method1(self, ...):
        """
        Method to perform an operation on the object.
        """
    \end{lstlisting}
    \caption{Abstract Data Type template}\label{ex:adt-template}
\end{figure}


\autoref{ex:adt-template} shows an ADT class template in Python. It consists of three main parts. The \emph{Overview} describes the abstract data type in terms of well-understood concepts, like mathematical models or real-world entities. For example, a stack could be described using mathematical sequences.
The Overview can also indicate whether the objects of this type are \emph{mutable} (their state can change) or \emph{immutable}.
The \emph{Constructor} initializes a new object, setting up any initial state required for the instance.
Finally, \emph{methods} define operations users can perform on the objects. These methods allow users to interact with the object without needing to know its internal representation. In Python, \code{self} is used to refer to the object itself, similar to \code{this} in Java or C++.

Note that as with procedural specification (\autoref{chap:procedural-abstraction}), the specifications of constructors and methods of an ADT do not include implementation details. They only describe what the operation does, not how it is done. Moreover, they are written in plain English as code comment.


\subsection{Example: \code{IntSet} ADT}

\autoref{ex:intset} gives the specification for an \code{IntSet} ADT, which represents unbounded set of integers. \code{IntSet} includes a constructor to initialize an empty set, and methods to insert, remove, check membership, get the size, and choose an element from the set. \code{IntSet} is also mutable, as it allows elements to be added or removed. \emph{mutator} \code{insert} and \code{remmove} are mutator methods and have a \code{MODIFIES} clause.  In contrast, \code{is\_in}, \code{size}, and \code{choose} are \emph{observer} methods that do not modify the object.

\begin{figure}
    \begin{lstlisting}
class IntSet:
    """
    Overview: IntSets are unbounded, mutable sets of integers.
    This implementation uses a list to store the elements, ensuring no duplicates.

    """
    def __init__(self):
        """
        Constructor
        EFFECTS: Initializes this to be an empty set.
        """
        self.els = []  # the representation (list)

    def insert(self, x: int) -> None:
        """
        MODIFIES: self
        EFFECTS: Adds x to the elements of this set if not already present.
        """
        if not self.is_in(x): self.els.append(x)
            
    def remove(self, x: int) -> int:
        """
        MODIFIES: self
        EFFECTS: Removes x from this set if it exists. Also returns       
        the index of x in the list.
        """
        i = self.find_idx(x)
        if i != -1:
            # Remove the element at index i
            self.els = self.els[:i] + self.els[i+1:]  
        return i

    def is_in(self, x: int) -> (bool, int):
        """
        EFFECTS: If x is in this set, return True. Otherwise False.
        """
        return True if find_index(x) != -1 else False

    def find_idx(self, x:int)->int:
        """
        EFFECTS: If x is in this set, return its index. Otherwise returns -1.
        """
        for i, element in enumerate(self.els):
            if x == element:
                return i
        return -1

    def size(self) -> int:
        """
        EFFECTS: Returns the number of elements in this set (its cardinality).
        """
        return len(self.els)

    def choose(self) -> int:
        """
        EFFECTS: If this set is empty, raises an Exception. 
        Otherwise, returns an arbitrary element of this set.
        """
        if len(self.els) == 0:
            raise Exception(...)
        return self.els[-1]  # Returns the last element arbitrarily

    def __str__(self) -> str:
        """
        Abstract function (AF) that returns a string representation of this set.
        EFFECTS: Returns a string representation of this set.
        """
        return str(self.els)
\end{lstlisting}
\caption{The IntSet ADT}\label{ex:intset}
\end{figure}

%\subsection{Example: \code{Polynomial} ADT}

\section{Implementing ADT}\label{sec:implementing-adt}

To implement an ADT, we first choose a \emph{representation} (\textbf{rep}) for its objects, then design constructors to initialize it correctly, and methods to interact with and modify the rep. 
For example, we can use a \code{list} (or vector) as the rep of \code{IntSet} in \autoref{ex:intset}. We could use other data structures, such as a \code{set} or \code{dict}, as the rep, but a list is a simple choice for demonstration.


To aid understanding and reasoning of the rep of an ADT, we use two key concepts: \emph{representation invariant} and \emph{abstraction function}.

\subsection{Representation Invariant (Rep-Inv)} Because the rep might not be necessarily related to the ADT itself (e.g., the list has different properties compared to a set), we need to ensure that our use of the rep is consistent with the ADT's behavior. 
To do this, we use \emph{representation invariant} (\textbf{rep-inv}) to specify the constraints for the rep of the ADT to capture its behavior. 

For example, the rep-inv for a stack is that the last element added is the first to be removed and the rep-inv for a binary search tree is that the left child is less than the parent, and the right child is greater. 
The rep-inv for our \code{IntSet} ADT in \autoref{ex:intset} is that all elements in the list are unique. 
\begin{lstlisting}
    # Rep-inv:
    # els is not null, only contains integers and has no duplicates.
\end{lstlisting}

The rep-inv must be preserved by all methods (more precisely, \emph{mutator} methods). It must hold true before and after the method is called. The rep-inv might be violated temporarily during the method execution, but it must be restored before the method returns. For \code{IntSet} Notice that the mutator \code{insert} method ensures that the element is not already in the list before adding it. 

The rep-inv is decided by the designer and specified in the ADT documentation as part of the specification (just like pre/post conditions) so that it is ensured at the end of each method (like the postcondition). Moreover, because rep-inv is so important, it is not only documented in comments but also checked at runtime.  This is done by invoking a \code{repOK}, discussed later, method at the start and end of each method.

\subsection{In-Class Exercise: Checking Rep-Invs}

\begin{lstlisting}
class Members:
    """
    Overview: Members is a mutable record of organization membership.
    AF: Collect the list as a set.
    
    Rep-Inv:
        - rep-inv1: members != None
        - rep-inv2: members != None and no duplicates in members.
        For simplicity, assume None can be a member.
    """

    def __init__(self):
        """Constructor: Initializes the membership list."""
        self.members = []  # The representation

    def join(self, person):
        """
        MODIFIES: self
        EFFECTS: Adds a person to the membership list.
        """
        self.members.append(person)

    def leave(self, person):
        """
        MODIFIES: self
        EFFECTS: Removes a person from the membership list.
        """
        self.members.remove(person)
\end{lstlisting}

\begin{enumerate}
\item Analyze these four questions for \emph{rep-inv 1}.
\begin{itemize}
    \item Does \code{join()} maintain rep-inv?
    \item Does \code{join()} satisfy its specification?
    \item Does \code{leave()} maintain rep-inv?
    \item Does \code{leave()} satisfy its specification?
\end{itemize}
\item Repeat for \emph{rep-inv 2}.
\item Recode \code{join()} to make the verification go through. Which rep-invariant do you use?
\item Recode \code{leave()} to make the verification go through. Which rep-invariant do you use?
\end{enumerate}

\subsection{Abstraction Function (AF)} 

It can be difficult to understand the ADT by looking at the rep directly. For example, we might not be able to visualize or reason about a binary tree or a graph ADT when using list as the rep. To aid understanding, \emph{abstraction function} (\textbf{AF}) provides a mapping between the rep and the ADT. 
Specifically, the AF maps from a \emph{concrete state} (i.e., the \code{els} rep in \autoref{ex:intset}) to an \emph{abstract state} (i.e., the integer set). AF is also a \emph{many-to-one} mapping, as multiple concrete states can map to the same abstract state, e.g., the list \code{[1, 2, 3]} and \code{[3, 2, 1]} both map to the same set \code{\{1, 2, 3\}}. 

Just as with rep-inv, the AF is documented in the class specification. Modern OOP languages often provide methods implementing the AF, in particular developer overrides the \code{\_\_str\_\_} method in Python and \code{toString} in Java to return a string representation of the object. For example, the \code{\_\_str\_\_} method in \autoref{ex:intset} returns a string representation of the set.



\subsection{In-Class Exercise: Stack ADT}

In this exercise, you will implement a \code{Stack} ADT. A stack is a common data structure that follows the Last-In-First-Out (LIFO) principle. You will:
\begin{enumerate}
\item Choose a Representation (rep) for the stack.
\item Define a Representation invariant (rep-inv)
\item Write a \code{repOK} method
\item Provide the specifications of basic stack operations (\code{push}, \code{pop}, \code{is\_empty}) and implement these methods accordingly.
\item Define an Abstraction Function (AF)
\item Implement \code{\_\_str\_\_()} to return a string representation of the stack based on the AF
\end{enumerate}

\section{Mutability vs. Immutability}\label{sec:mutability-vs-immutability}

An ADT can be either mutable or immutable, depending on whether their objects' values can change over time. An ADT should be immutable if the objects it models naturally have unchanging values, such as mathematical objects like integers, polynomials (Polys), or complex numbers. On the other hand, an ADT should be mutable if it models real-world entities that undergo changes, such as an automobile in a simulation, which might be running or stopped, or contain passengers, or if the ADT models data storage, like arrays or sets.

Immutability is beneficial because it offers greater safety and allows sharing of subparts without the risk of unexpected changes. Moreover, immutability can simplify the design by ensuring the object’s state is fixed once created. However, immutable objects can be less efficient, as creating a new object for each change can be costly in terms of memory and time.

\paragraph{Converting from mutable to immutable} 
Given a mutable ADT, it is possible to convert it to an immutable one by ensuring that the rep is not modified by any method. This can be achieved by making the rep private and only allowing read-only access to it. In Python, this can be done by using the \code{@property} decorator to create read-only properties. For example, the \code{els} list in \autoref{ex:intset} can be made read-only by defining a property method \code{elements} that returns a copy of the list.

\begin{lstlisting}
    class IntSet:
        def __init__(self):
            self.__els = []   # Private rep
        @property
        def self.els(self):
            return self.__els
\end{lstlisting}

Moreover, we need to convert mutator methods into observer methods, which make a copy of the rep, modify it, and return the modified rep object.  
\begin{lstlisting}
    def insert_immutable(self, x: int) -> IntSet:
        new_set = self.els.copy()
        if not self.is_in(x):
            new_set = new_set.append(x)
        return new_set
\end{lstlisting}

If the mutator returns a value $v$, then our new method returns a tuple consisting of (i) the new rep object and the return the value $v$. 
\begin{lstlisting}
    def remove_immutable(self, x: int): -> (IntSet, int):
        i = self.find_idx(x)
        new_set = self.els.copy()
        if i != -1:
            # Remove the element at index i
            new_set = self.els[:i] + self.els[i+1:]  
        return (new_set, i)
\end{lstlisting}

If you do not want to return multiple values (e.g., like in Java), then you can create two methods, one for returning the value and the other for returning the new rep object.
For example, a mutator \code{pop} method of a \code{Stack} would result into two methods: \code{pop2} returns the top element and \code{pop3} returns the new stack with the top element removed.

Finally, it is important that while it is possible to convert a mutable ADT to an immutable one as shown, mutability or immutability should be the property of the ADT type itself, not its implementation. Thus, it should be decided at the design stage and documented in the ADT specification.

\subsection{In-class Exercise: Immutable Queue}\label{ic:immutable-queue}


\begin{figure}
    \begin{lstlisting}

class Queue:
    """
    A generic Queue implementation using a list.
    """

    def __init__(self):
        """
        Constructor
        Initializes an empty queue.
        """
        self.elements = []
        self.size = 0

    def enqueue(self, e):
        """
        MODIFIES: self
        EFFECTS: Adds element e to the end of the queue.
        """
        self.elements.append(e)
        self.size += 1

    def dequeue(self):
        """
        MODIFIES: self
        EFFECTS: Removes and returns the element at the front of the queue.
        If the queue is empty, raises an IllegalStateException.
        """
        if self.size == 0:
            raise Exception(...)

        result = self.elements.pop(0)  # Removes and returns the first element
        self.size -= 1
        return result

    def is_empty(self):
        """
        EFFECTS: Returns True if the queue is empty, False otherwise.
        """
        return self.size == 0

    \end{lstlisting}
    \caption{Mutable Queue}\label{ex:mutable-queue}
\end{figure}

Rewrite the mutable \code{Queue} implementation in \autoref{ex:mutable-queue} so that it becomes \emph{immutable}. Keep the \textbf{rep} variables \code{elements} and \code{size}.




% \subsection{Locality and Modifiability}\label{sec:locality-modifiability}

% \emph{Locality} (the ability to reason about an ADT indepepdently of other code) and \emph{modifiability} (the ability to change an implementation without affecting other parts of the code) are two important concepts in writing code. It applies to functions (we want the function to be independent of other functions) and certain to data abstractions. For ADT implementation, this requires that the rep should be modifiable only within the ADT implementation and not outside of the ADT. This is achieved by making the rep \emph{private} and providing methods to access and modify the rep.

% Modifiability goes further than locality. To achieve modifiability, not only must modifications be restricted to the ADT implementation, but all access to the internal representation—-even for reading immutable components--must also be confined to the implementation. If other modules can access the internal representation, then changing the representation may affect those modules, violating modifiability. To ensure modifiability, instance variables must be declared private and cannot be exposed outside the ADT.
% Thus, it is essential that access to the internal representation is restricted to the ADT implementation. %Programming languages like Python allow encapsulation, ensuring that the representation is hidden and protected. If access to the representation is unrestricted, it becomes an additional property that must be proven about the code manually.

\section{Exercise}

\subsection{Polynomial ADT}
\begin{figure}
\begin{lstlisting}
class Poly:
    def __init__(self, c=0, n=0):
        if n < 0:
            raise ValueError("Poly(int, int) constructor: n must be >= 0")
        self.trms = {}
        if c != 0:
            self.trms[n] = c

    def degree(self):
        if len(self.trms) > 0:
            return next(reversed(self.trms.keys()))
        return 0

    def coeff(self, d):
        if d < 0:
            raise ValueError("Poly.coeff: d must be >= 0")
        return self.trms.get(d, 0)

    def sub(self, q):
        if q is None:
            raise ValueError("Poly.sub: q is None")
        return self.add(q.minus())

    def minus(self):
        result = Poly()
        for n, c in self.trms.items():
            result.trms[n] = -c
        return result

    def add(self, q):
        if q is None:
            raise ValueError("Poly.add: q is None")
        
        non_zero = set(self.trms.keys()).union(q.trms.keys())
        result = Poly()
        for n in non_zero:
            new_coeff = self.coeff(n) + q.coeff(n)
            if new_coeff != 0:
                result.trms[n] = new_coeff
        return result

    def mul(self, q):
        if q is None:
            raise ValueError("Poly.mul: q is None")
        
        result = Poly()
        for n1, c1 in self.trms.items():
            for n2, c2 in q.trms.items():
                result = result.add(Poly(c1 * c2, n1 + n2))
        return result

    def __str__(self):
        r = "Poly:"
        if len(self.trms) == 0:
            r += " 0"
        for n, c in self.trms.items():
            if c < 0:
                r += f" - {-c}x^{n}"
            else:
                r += f" + {c}x^{n}"
        return r
\end{lstlisting}
\caption{Polynomial ADT}\label{ex:poly}
\end{figure}


Use the Poly ADT in \autoref{ex:poly} to answer the following questions. Use the \code{Stack} ADT in \autoref{ex:stack} as an example. 

\begin{enumerate}
        \item Part 1
\begin{enumerate}
\item Write an Overview that describes what \code{Poly} does. You must provide some examples to demonstrate (e.g., \code{Poly(2,3)} means what?).
\item Provide the specifications for all methods in the ADT. 
\item Write the \textbf{rep} used in this code.  Describe how this rep represents \code{Poly}.
\item Provide the \textbf{rep-inv} for the ADT. Note, this would be the constraints over the rep variable(s).
\item Write a \code{repOK} method that checks the rep-inv.
\item Describe the AF in this code. Use \code{\_\_str\_\_} to help.
\end{enumerate}

        \item Part 2
\begin{enumerate}
        \item Introduce a fault (i.e. "bug") that breaks the \textbf{rep-inv}. Try to do this with a small (conceptual) change to the code. Show that the rep-invariant is broken with a concrete test case.
        \item Analyzed your bug with respect to the method specifications of \code{Poly}. Are all/some/none of the specification violated?
        \item Do you think your fault is realistic? Why or why not?
\end{enumerate}
        
\end{enumerate}


\subsection{Immutability}

The below class \code{Immutable} is supposed to be immutable. However, it is not. Identify the issues and fix them.  Note that in Python or Java, immutable types include \code{int}, \code{float}, \code{str}, \code{tuple}. and mutable types include \code{list} and \code{dict}. 

\begin{enumerate}
\item Which of the lines (A--F) has a problem with immutability? Explain why by showing code example, i.e., show code involving problematic lines; show how that breaks immutability.

\sol{Only line F is problematic. It returns a reference to the internal list, which can be modified. Note that line C has no issue because it creates a copy of the list. If there was no copy, then this would cause a problem as \code{mlist} could be modified outside the class and affects \code{\_mlist}.}
\item For each line that has a problem.  Write code to fix it so that the class is immutable.

\sol{To fix line F, simply return copy, i.e., return self.\_mlist.copy().}
\end{enumerate}

    
\begin{lstlisting}
class Immutable:
    def __init__(self, mstr: str, mint: int, mlist: list[str]):
        self._mstr = mstr                       # Line A
        self._mint = mint                       # Line B
        self._mlist = mlist.copy()              # Line C

    
    def get_mstr(self) -> str: return self._mstr        # Line D
    def get_mint(self) -> int: return self._mint        # Line E
    def get_mlist(self) -> list[str]: return self._mlist # Line F
\end{lstlisting}




% \chapter{Iterators and Generators}

% This chapter introduces the concept of \emph{iteration abstraction} through \emph{iterators}, which are a generalization of iteration mechanisms found in most programming languages. Iterators allow users to traverse arbitrary types of data efficiently and without the need for additional structures, such as arrays or list, that can consume extra memory or modify the collection being iterated over.


% \section{Iterators}

% \emph{Iterators} provide general-purpose iteration mechanism that is both efficient and preserves abstraction. An iterator is a special kind of object that allows us to access elements one at a time, without creating large intermediate structures or modifying the original collection, and can stop early if a certain condition is met (e.g., find a specific item). Thus, iterations avoid the space and time inefficiencies of other methods.

% Each iteration produces a new item that can then be used within the loop. Like with procedural and data abstraction, a key advantage of iterators is the separation of concerns: the iterator handles the production of items, while the code containing the loop handles the actions performed on those items. The iterator can be reused in different contexts without modification.

% \begin{figure}
% \begin{lstlisting}
% class IntSet:
%     def __init__(self):
%         self._elements = set()

%     def add(self, element):
%         self._elements.add(element)

%     def __iter__(self):
%         # Returns an iterator over the set
%         return iter(self._elements)

% # Now, we can efficiently compute the sum:
% def set_sum(s: IntSet) -> int:
%     return sum(s)

% \end{lstlisting}
% \caption{IntSet with Iterator}\label{ex:intset-iter}
% \end{figure}

% To motivate the needs for iteration, suppose that we want to compute the sum of an \code{IntSet} collection defined in \autoref{ex:intset}. To compute the sum, we need to iterate through each element in the set. One way to do this is to convert the set to a list and then iterate over the list. However, this approach is inefficient because it requires creating a new list, which consumes memory and time. Another approach is modifying \code{IntSet} to return its rep as a list so we can iterate over it. However, this approach violates the abstraction principle, as it exposes the internal representation of the set.

% Iterators provide a better solution by allowing us to iterate over the set without exposing its internal representation.
% The \code{IntSet} in \autoref{ex:intset-iter} defines an \code{\_\_iter\_\_} method, which returns an iterator over its elements. This allows us to directly iterate over \code{IntSet} instances using a \code{for} loop or other iteration constructs. For example, the \code{sum} function in \autoref{ex:intset-iter} computes the sum of the elements in the set without exposing the internal representation of the set.


% \section{Iterators and Generators}

% A modern OOP language such as Python provides support for iteration abstraction through its built-in iterator and generator mechanisms. In Python, an iterator returns a special kind of object called a \emph{generator}, which keeps track of the state of the iteration and produces elements one at a time. A Python generator is created using the \code{yield} keyword, and provides the \code{next} and \code{hasNext} methods to advance the iteration and check for the end of the sequence.

\chapter{Types}

In 1999, NASA's Mars Climate Orbiter mission ended in failure due to a simple yet catastrophic software error. The spacecraft, which cost \$125 million to build and launch, was launched on December 11, 1998 to study the Martian climate and atmosphere. After a 9-month journey, the spacecraft approached Mars on September 23, 1999, and was supposed to enter a stable orbit around Mars at an altitude of about 226 kilometers (140 miles) above the planet’s surface. However, the spacecraft instead plunged much deeper into the Martian atmosphere, to an estimated altitude of 57 kilometers (35 miles), causing it to either burn up or crash on the surface, resulting in a complete loss of the mission.

The cause of the failure was a software error involving typing mismatch between imperial units (pounds-force) and metric units (newtons) in the software that controlled the spacecraft's thrusters. The software expected data in metric units, but the thruster data was provided in imperial units, leading to the incorrect trajectory calculations. This mismatch was not caught during testing, and the spacecraft was lost as a result. This failure not only cost NASA a significant financial investment but also set back the Mars exploration program. 


\section{Type Systems in OOP}

In OOP, the type system forms the foundation for defining how ADT (\autoref{chap:adt}) is represented and manipulated in a language. Type systems provide rules for assigning types to variables, expressions, functions, and objects, enabling the development of reliable and efficient software. A well-defined type system also enforces contracts between components, ensuring that data is used appropriately.

This chapter covers key concepts in the type system of OOP languages, particularly in the context of Python, where both static and dynamic typing coexist. We will explore topics like polymorphism, inheritance, dynamic dispatching, and more, discussing their motivation, core concepts. 



% We can enhance ADT (\autoref{chap:adt}) by defining families of related ADTs, where all members share similar behavior through common methods. These type families are structured in a hierarchy, with a base class (\emph{supertype}) defining the core behavior, and subclasses (\emph{subtypes}) extending or adding to this behavior. For example, Cars and Buses as subtypes of Vehicle, or program-specific hierarchies like a BufferedReader as a subtype of Reader. 


% A key concept in typing is that the \emph{Liskov's principle of substitution}, which ensures that any subtype object can be substituted for a supertype object without breaking the program. This principle allows code written for the supertype (e.g., Reader) to work seamlessly with any subtype (e.g., BufferedReader), enabling abstraction by focusing on commonalities while still supporting specific behaviors at different levels of the hierarchy.

\section{Polymorphism}

Polymorphism is a cornerstone of OOP that allows objects of different types to be treated as objects of a common supertype. This facilitates flexibility in programming by enabling the use of a unified interface for different types of objects, reducing redundancy and increasing code reuse.

\autoref{ex:polymorphism} shows an example of subtype polymorphism, where a \code{Mammal} class has two subclasses, \code{Dog} and \code{Cat}, each implementing the \code{speak} method differently. The \code{make\_mammal\_speak} function can then be used to make any mammal speak, regardless of its specific type.

\begin{figure}
\begin{lstlisting}

from abc import ABC, abstractmethod

class Mammal(ABC):
    """
    Abstract class
    """
    
    @abstractmethod
    def speak(self):
        raise NotImplementedError("Subclasses should implement this!")

class Dog(Mammal):
    def speak(self):
        return "Woof!"

    def bark(self):
        return "Bark!"

class Cat(Mammal):
    def speak(self): return "Meow!"
        
# Using polymorphism
def make_animal_speak(mammal: Mammal): return mammal.speak()

mammals = [Dog(), Cat()]
for m in mammals:
    print(make_animal_speak(m))
\end{lstlisting}
\caption{Polymorphism}\label{ex:polymorphism}
\end{figure}

\section{Inheritance}

Inheritance creates a hierarchical relationship between classes and allows a class to be a \emph{subclass} or \emph{subtype} of one other class (its \emph{superclass} or \emph{supertype}).
\autoref{ex:polymorphism} shows an example of inheritance.
\code{Mammal} is the superclass of \code{Dog} and \code{Cat}.
\code{Dog} and \code{Cat} are the subclasses of \code{Mammal}
They override \code{speak} to provide a specific implementation.
In addition to \emph{overriding} the \code{speak} method in \code{Mammal}, \code{Dog} defines a new method \code{bark} that is specific to dogs.


This is an example of single inheritance, where a subclass can inherit from only one superclass. Python also supports multiple inheritance, where a subclass can inherit from multiple superclasses. For example, an \code{HybridVehicle} class could inherit from both \code{Car} and \code{BatteryVehicle} classes. However, multiple inheritance can lead to complex hierarchies and potential conflicts, so it should be used judiciously.

\section{Abstract Class}
OOP has two types of classes: \emph{concrete} and \emph{abstract} classes. Concrete classes provide a full implementation of the type while abstract classes provide at most a partial implementation of the type. Abstract classes cannot be instantiated (no objects) since some of their methods are not yet implemented (abstract methods). Abstract classes can have both abstract (to be implemented by subclasses) and concrete methods (already implemented or partially implemented). 

In Python abstract classes are defined using the \code{abc} module, which provides the \code{ABC} class and the \code{abstractmethod} decorator. The \code{ABC} class is used as a base class for abstract classes, and the \code{abstractmethod} decorator is used to mark methods as abstract. In \autoref{ex:polymorphism},
\code{Mammal} is an abstract class, i.e., it cannot be instantiated, and contains an abstract method \code{speak} that its subclasses must implement.
In Java, abstract classes are defined using the \code{abstract} keyword, e.g., \code{public abstract class Mammal}, and abstract methods are declared using the \code{abstract} keyword as well, e.g., \code{public abstract void speak();}.

\section{Interface}

Interface is a special type of abstract class that contains only abstract methods (no concrete methods). They define a specification that classes must adhere to, providing the methods that must be implemented by any class that implements the interface. Multiple classes can implement the same interface, allowing for polymorphism and flexibility in the design.

In Python, interfaces are not explicitly defined, but the concept can be implemented using abstract classes with only abstract methods. For example, the abstract class \code{Mammal} in \autoref{ex:polymorphism} acts as an interface that specifies the \code{speak} method that all mammals must implement.
In Java, interfaces are explicitly defined using the \code{interface} keyword, e.g., \code{interface Mammal}, and methods are declared without a body, e.g., \code{public void speak();}. A class can implement multiple interfaces, allowing for more flexibility in defining contracts between classes.


\paragraph{Comparable interface} A good example of an interface is \code{Comparable}, which defines a single method \code{compare\_to} that allows objects to be compared to each other. Any class that implements \code{Comparable} can be compared to other objects of the same type, enabling sorting and other operations that require comparison.

The code below demonstrates the use of the \code{Comparable} interface in Python. The \code{Number} class implements the \code{Comparable} interface by defining the \code{compare\_to} method, which compares two \code{Number} objects based on their values. The \code{sort} function uses the \code{compare\_to} method to sort a list of \code{Number} objects.

\begin{lstlisting}
    from abc import ABC, abstractmethod
from typing import List

# Define a Comparable interface using ABC
class Comparable(ABC):
    @abstractmethod
    def compare_to(self, other: "Comparable") -> int:
        """Compares this object with another."""
        pass

# Implement Comparable in a concrete class
class Number(Comparable):
    def __init__(self, value: int):
        self.value = value

    def compare_to(self, other: "Number") -> int:
        if self.value < other.value:
            return -1
        elif self.value > other.value:
            return 1
        else:
            return 0

# Polymorphic sorting function that relies on the compare_to method
def sort(items: List[Comparable]) -> List[Comparable]:
    return sorted(items, key=lambda x: x.value)

# Usage
numbers = [Number(3), Number(1), Number(4), Number(2)]
sorted_numbers = sort(numbers)
print(sorted_numbers)  # Output: [1, 2, 3, 4]
\end{lstlisting}    

\subsection{Element Subtype vs Related Subtype} There are two types of subtypes: \emph{element subtype} and \emph{related subtype}. Element subtype relies on a common interface or abstract class, e.g., \code{Number} is an element subtype of \code{Comparable} because it implements the \code{compare\_to} method. While this common approach allows for polymorphism, it requires all potential types must be pre-planned to fit the hierarchy. 


On the other hand, a related subtype does not directly rely on a common interface or abstract class (which might be designed much later). Instead, this approach creates a related subtype that implement the desired interface and then adapts it to the existing hierarchy. The code below demonstrates the use of a related subtype, where \code{Price} is adapted to \code{PriceComparable}, which implements \code{Comparable}, to allow sorting of \code{Price} objects.

\begin{lstlisting}
class Price:
    def __init__(self, amount: float):
        self.amount = amount


class PriceComparable(Comparable):
    def __init__(self, price: Price):
        self.price = price
    def compare_to(self, other: "PriceComparable") -> int:
        if self.price.amount < other.price.amount:
            return -1
        elif self.price.amount > other.price.amount:
            return 1
        else:
            return 0

# sorting using related subtype            
prices = [Price(3.0), Price(1.0), Price(4.0), Price(2.0)]
price_comparators = [PriceComparable(p) for p in prices]
sorted_prices = sort(price_comparators)
\end{lstlisting}

\section{Dynamic Dispatching}

Dynamic dispatching refers to how a program selects which method to invoke when a method is called on an object.  It allows the correct method to be invoked based on the \emph{runtime type} of the object, even if the reference to the object is of a more general (superclass) type. This is particularly useful when working with inheritance and polymorphism, where subclasses override methods from a superclass.
The distinction between dynamic dispatching and static dispatching lies in when the decision about which method to invoke is made—either at runtime (dynamic) or compile-time (static).

In \autoref{ex:polymorphism} the \code{make\_mammal\_speak} method will invoke the \code{speak} method of the correct subclass based on the runtime type of the object. This is dynamic dispatching in action, where the method \code{speak} to be called is determined at runtime based on the actual type of the object.  However, if we explicitly create a \code{Dog} instance and call \code{speak} on it, the method is statically dispatched, as the compiler knows the type of the object at compile-time and can directly call the correct method.

The code below demonstrates the difference between static and dynamic dispatching. The \code{Dog} object \code{d} is statically dispatched, while the \code{Mammal} object \code{m} is dynamically dispatched.
\begin{lstlisting}
    Dog d = Dog();
    d.speak();  # Static dispatching

    Mammal m = Dog();
    m.speak();  # Dynamic dispatching
\end{lstlisting}    

\section{Liskov Substitution Principle (LSP)}
The Liskov Substitution Principle (LSP) is a fundamental concept of object-oriented design, which ensures that objects of a subclass should be able to replace objects of the superclass without altering the correctness of the program. LSP promotes proper design and enforces correct use of inheritance.
Violating LSP can lead to unexpected behavior and errors in the program, as the assumptions made about the superclass may no longer hold for the subclass. 

The main idea of LSP is that a subclass \emph{is-a} superclass and can do everything the superclass can do, and can also do more. For example, a \code{Dog} is a \code{Mammal} and can speak like any mammal, but it can also bark, which is specific to dogs.
This enables substitution of objects of the subclass for objects of the superclass, allowing for polymorphism and dynamic dispatching to work correctly. The \code{make\_animal\_speak} function in \autoref{ex:polymorphism} demonstrates LSP by accepting any \code{Mammal} object and making it speak, regardless of its specific type.


\paragraph{Rules} If \code{S} is a subtype of \code{T}, then objects of type \code{T} may be replaced with objects of type \code{S} without altering any of the desirable properties of the program. This means whenever you use \code{T}, you can use \code{S} instead. To achieve this, we must follow the following rules:
\begin{itemize}
\item[\textbf{Signature Rule}] The signatures of methods of \code{S} must strengthen methods of \code{T}. In other words, the methods of \code{S} are a superset of the methods of \code{T}. Thus, if \code{T} has \code{n} methods, \code{S} also has \code{n} methods and additional ones (methods specific to \code{S}). 

\item[\textbf{Method Rule}] The specification of \code{f'} strengthens that of \code{f}. This means that the preconditions of \code{f'} must be weaker or equal to the preconditions of \code{f}, i.e.,  \code{f'} accepts more inputs than \code{f}.  The postconditions of \code{f} must be stronger or equal to that of \code{f}. This means that \code{f'} is more precise and specific than \code{f}.

\item[\textbf{Property Rule}] The subtype must preserve all properties of the supertype.  For example, the rep-invariant of the subtpe \code{S} must be stronger or equal to that of the supertype \code{T}. This means \code{S} should maintain or strengthen the properties (including rep invariants) of \code{T}
\end{itemize}

\subsection{In-Class Exercise: BankAccount}

%\autoref{ex:bankaccount}

\begin{figure}
    \begin{lstlisting}
class BankAccount:
    def __init__(self, balance: float):
        self._balance = balance if balance >= 0 else 0  
        
    def repOK(self):
        return self._balance >= 0

    def deposit(self, amount: float) -> bool:
        """
        REQUIRES: amount must be positive
        EFFECTS: balance is the original balance plus deposited amount
        """
        if amount <= 0:
            return False
        self._balance += amount
        # check_repOK()
        return True

    def withdraw(self, amount: float) -> bool:
        # REQUIRES: amount must be positive and less than or equal to balance
        # EFFECTS: balance is the original balance minus withdrawn amount

        if amount <= 0 or amount > self._balance:
            return False
        self._balance -= amount
        self.check_repOK()
        # check_repOK()
        return True

class BonusBankAccount(BankAccount):
    def __init__(self, balance: float, bonus_interest: float):
        super().__init__(balance)
        self._bonus_interest = bonus_interest

    def deposit(self, amount: float) -> str:
        # REQUIRES: (same) amount must be positive
        # EFFECTS: (stronger) deposit and also add bonus interest

        stats = super().deposit(amount)
        if stats:
            # deposit successful, add interest
            self._balance += self._bonus_interest * amount
        
        # check_repOK()
        return stats


    def withdraw(self, amount: float) -> bool:
        """
        REQUIRES: (weaker) allow zero withdrawals, which are ignored
        EFFECTS: (same) balance is the original balance minus withdrawn amount
        """
        if amount == 0:
            return True  # Zero withdrawal is considered a no-op
        ret =  super().withdraw(amount)
        # check_repOK()
        return ret
    
    
    def repOK(self):
        """
        Stronger Rep-inv: balance and bonus interest must be non-negative
        """
        return super().repOK() and self._bonus_interest >= 0
        
    \end{lstlisting}
\caption{Liskov Substitution Principle demonstration}\label{ex:bankaccount}
\end{figure}




% \begin{lstlisting}
% class IntSet:
%     def insert(self, x): ...; self.repOk()
%     def remove(self, x): ...; self.repOk()
%     def repOk(self): ...

%     class MaxIntSet(IntSet):
%     def insert(self, x): ...; super().insert(x); self.repOk()
%     def remove(self, x): super().remove; ...; self.repOk()
%     def repOk(self): super().repOk(); ...

% s = MaxIntSet()
% s.insert(3)
% s.insert(5)
% s.remove(5)
%\end{lstlisting}

\section{Exercise}

\subsection{LSP: Market subtype}

Determine whether the \code{LowBidMarket} and \code{LowOfferMarket} classes are proper subtypes of \code{Market}. Specifically, for each method in each class, list whether the precondition is weaker, the postcondition is stronger, and conclude whether LSP holds.

\begin{lstlisting}
class Market:
    def __init__(self):
        self.wanted = set()  # items for which prices are of interest
        self.offers = {}     # offers to sell items at specific prices

    def offer(self, item, price):
        """
        Requires: item is an element of wanted.
        Effects: Adds (item, price) to offers.
        """
        if item in self.wanted:
            if item not in self.offers:
                self.offers[item] = []
            self.offers[item].append(price)

    def buy(self, item):
        """
        Requires: item is an element of the domain of offers.
        Effects: Chooses and removes some (arbitrary) pair (item, price) from
                    offers and returns the chosen price.
        """
        if item in self.offers and self.offers[item]:
            return self.offers[item].pop(0)  # Removes and returns the first price
        return None

class LowBidMarket(Market):
    def offer(self, item, price):
        """
        Requires: item is an element of wanted.
        Effects: If (item, price) is not cheaper than any existing pair
                    (item, existing_price) in offers, do nothing.
                    Else add (item, price) to offers.
        """
        if item in self.wanted:
            if item not in self.offers:
                self.offers[item] = []
            # Only add if price is lower than existing prices
            if not self.offers[item] or price < min(self.offers[item]):
                self.offers[item].append(price)

class LowOfferMarket(Market):
    def buy(self, item):
        """
        Requires: item is an element of the domain of offers.
        Effects: Chooses and removes the pair (item, price) with the 
                    lowest price from offers and returns the chosen price.
        """
        if item in self.offers and self.offers[item]:
            # Find and remove the lowest price from the list
            lowest_price = min(self.offers[item])
            self.offers[item].remove(lowest_price)
            return lowest_price
        return None                
\end{lstlisting}

\subsection{LSP: Reducer}
\begin{figure}
\begin{lstlisting}
class A:
    def reduce(self, x):
        """
        Effects: if x is None, raise ValueError;
                 if x is not appropriate, raise TypeError;
                 else, reduce this by x.
        """

class B(A):
    def reduce(self, x):
        """
        Requires: x is not None.
        Effects: if x is not appropriate, raise TypeError;
                 else, reduce this by x.
        """

class C(A):
    def reduce(self, x):
        """
        Effects: if x is None, return normally with no change;
                 if x is not appropriate, raise TypeError;
                 else, reduce this by x.
        """
\end{lstlisting}
\caption{LSP Exercise}\label{ex:lsp-exercise}
\end{figure}

For the classes \code{A}, \code{B}, and \code{C} in \autoref{ex:lsp-exercise}, determine whether LSP holds in the following cases. Specifically, for each case, list whether the precondition is weaker, the postcondition is stronger, and conclude whether LSP holds.
\begin{enumerate}
    \item \code{B} extends \code{A}.
    \sol{B's pre is stronger than A's because it requires that $x$ is not None while A's has no pre. \textbf{LSP does not hold}. The posts of \code{A} and \code{B} are the same}
    \item \code{C} extends \code{A}
    \sol{Pre's are the same (both are total methods). C's post is stronger than A's because it allows $x$ to be None while A's does not. \textbf{LSP holds}.}
    \item \code{A} extends \code{B}
    \sol{A's pre is weaker than B's because A has no pre. The posts for both are essentially the same because B's pre explicitly requires $x$ to be not None. \textbf{LSP holds}. Note that you might argue A's post is stronger, which is also fine and also means LSP holds.}
    \item \code{C} extends \code{B}
    \sol{C's pre is weaker than B's because C allows $x$ to be None while B does not. The posts are the same. \textbf{LSP does not hold}.}
    \item \code{A} extends \code{C}
\end{enumerate}

\appendix

\chapter{Miscs}



\bibliographystyle{abbrv}

\chapter{More Examples}
\section{ADT}
\subsection{Stack ADT}
\begin{figure}
    \begin{lstlisting}
        class Stack:
        """
        Overview: Stack is a mutable ADT that represents a collection of elements in LIFO.
        AF(c) = the sequence of elements in the stack in sorted order from bottom to top.
        rep-inv: 
            1. elements is a list (could be empty list, which represents and empty stack).
            2. The top of the stack is always the last element in the list.
        """
    
        def __init__(self):
            """
            Constructor
            EFFECTS: Initializes an empty stack.
            MODIFIES: self
            """
            self.elements = []
    
        def repOK(self):
            """
            EFFECTS: Returns True if the rep-invariant holds, otherwise False.
            The invariant checks:
            1. elements is a list.
            2. If the stack is non-empty, the top of the stack is the last element in the list.
            """
            # Check that elements is a list
            if not isinstance(self.elements, list):
                return False
            
            # If the stack is not empty, ensure that the top is the last element in the list.
            # This is implicitly guaranteed by the use of `list.append` for push and `list.pop` for pop,
            # so no further explicit check is needed for the "top as last element."
            return True
    
        def push(self, value):
            """
            MODIFIES: self
            EFFECTS: Adds value to the top of the stack.
            """
            self.elements.append(value)
    
        def pop(self):
            """
            MODIFIES: self
            EFFECTS: Removes and returns the top element from the stack. 
            Raises an exception if the stack is empty.
            """
            if self.is_empty():
                raise Exception("Stack is empty")
            return self.elements.pop()
    
        def is_empty(self):
            """
            EFFECTS: Returns True if the stack is empty, otherwise False.
            """
            return len(self.elements) == 0
    
        def __str__(self):
            """
            EFFECTS: Returns a string representation of the stack,
                     showing the elements from bottom to top.
            """
            # The abstraction function maps the list of elements to a stack view
            return f"Stack({self.elements})"
    \end{lstlisting}
    \caption{Stack ADT}\label{ex:stack}
\end{figure}
    

\end{document}


%repr-inv:https://ocw.mit.edu/courses/6-170-laboratory-in-software-engineering-fall-2005/1a1f80fa85176ed3cae09ccd74f902d3_lec8.pdf




