\documentclass[oneside,11pt,dvipsnames]{book}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[margin=1.5in]{geometry}
\usepackage{soul}
% \usepackage[small,compact]{titlesec} %very powerful
\usepackage[most]{tcolorbox}
% \setsecnumdepth{subsection}
% \setcounter{tocdepth}{3}
\usepackage{multicol}
\usepackage{enumitem}
\usepackage{epigraph}
\usepackage{cite}
\usepackage{caption}
\captionsetup{font=small}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{hyperref}
\usepackage{wrapfig}
\setlength\intextsep{0pt} % remove extra space above and below in-line float
\usepackage{hyperref}
\hypersetup{
  colorlinks,
  citecolor=black,
  filecolor=black,
  linkcolor=blue,
  urlcolor=blue,
}
\usepackage{booktabs}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\scriptsize,
  language=python,
  morekeywords={assert},
  keywordstyle=\color{blue},
  commentstyle=\color{magenta},
  numbers=none,
  mathescape,
  stepnumber=1,
  numbersep=8pt,
  tabsize=4,
  showspaces=false,
  showstringspaces=false,
  emph={},
  emphstyle=\color{red}\bfseries
}

\usepackage{tikz}
\usetikzlibrary{calc}
\usepackage{xcolor}

\usepackage{anyfontsize}
\usepackage{sectsty}

\usepackage{etoolbox}

\newtoggle{usesol}
\settoggle{usesol}{true} % not sol version
\newcommand{\sol}[1]{\iftoggle{usesol}{\textbf{Sol:} #1}{}}
\newcommand{\notsol}[1]{\nottoggle{usesol}{#1}{}}
\newcommand{\solite}[2]{\iftoggle{usesol}{#1}{#2}}

\usepackage[makeroom]{cancel}

\newtcolorbox{mybox}{
  enhanced,
  boxrule=0pt,frame hidden,
  borderline west={2pt}{0pt}{green!75!black},
  colback=green!10!white,
  sharp corners
}

\newenvironment{commentbox}[1][]{
  \small
  \begin{mybox}
    {\small \textbf{#1}}
  }{
  \end{mybox}
}

\newtcolorbox{mydomesticbox}{
  enhanced,
  boxrule=0pt,frame hidden,
  borderline west={2pt}{0pt}{red!75!black},
  colback=blue!10!white,
  sharp corners
}

\newenvironment{domesticbox}[1][]{
  \small
  \begin{mydomesticbox}
    {\small \textbf{#1}}
  }{
  \end{mydomesticbox}
}

\renewcommand{\figurename}{Fig.}
\renewcommand{\tablename}{Tab.}
\def\Section{\S}
\renewcommand{\figureautorefname}{Fig.}
\renewcommand{\tableautorefname}{Tab.}
\makeatletter
\renewcommand{\chapterautorefname}{\S\@gobble}
\renewcommand{\sectionautorefname}{\S\@gobble}
\renewcommand{\subsectionautorefname}{\S\@gobble}
\renewcommand{\appendixautorefname}{\S\@gobble}
\makeatother

\newcommand{\mycomment}[3][\color{blue}]{{#1{{#2}: {#3}}}}
\newcommand{\tvn}[1]{\mycomment{TVN}{#1}}{}
\newcommand{\red}[1]{{\color{red}{#1}}}
\newcommand{\code}[1]{\texttt{#1}}

\newcommand{\pycode}[1]{
\begin{lstlisting}[multicols=2, language=Python,
keywordstyle=\color{blue},
commentstyle=\color{green!60!black},
stringstyle=\color{red},
basicstyle=\ttfamily\scriptsize]
#1
\end{lstlisting}
}


\begin{document}

\pagestyle{empty}
\begin{tikzpicture}[overlay,remember picture]

    % Background color
    \fill[
    black!2]
    (current page.south west) rectangle (current page.north east);

    % Rectangles
    \shade[
    left color=Dandelion,
    right color=Dandelion!40,
    transform canvas ={rotate around ={45:($(current page.north west)+(0,-6)$)}}]
    ($(current page.north west)+(0,-6)$) rectangle ++(9,1.5);

    \shade[
    left color=lightgray,
    right color=lightgray!50,
    rounded corners=0.75cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(.5,-10)$)}}]
    ($(current page.north west)+(0.5,-10)$) rectangle ++(15,1.5);

    \shade[
    left color=lightgray,
    rounded corners=0.3cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(.5,-10)$)}}] ($(current page.north west)+(1.5,-9.55)$) rectangle ++(7,.6);

    \shade[
    left color=orange!80,
    right color=orange!60,
    rounded corners=0.4cm,
    transform canvas ={rotate around ={45:($(current page.north)+(-1.5,-3)$)}}]
    ($(current page.north)+(-1.5,-3)$) rectangle ++(9,0.8);

    \shade[
    left color=red!80,
    right color=red!80,
    rounded corners=0.9cm,
    transform canvas ={rotate around ={45:($(current page.north)+(-3,-8)$)}}] ($(current page.north)+(-3,-8)$) rectangle ++(15,1.8);

    \shade[
    left color=orange,
    right color=Dandelion,
    rounded corners=0.9cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(4,-15.5)$)}}]
    ($(current page.north west)+(4,-15.5)$) rectangle ++(30,1.8);

    \shade[
    left color=RoyalBlue,
    right color=Emerald,
    rounded corners=0.75cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(13,-10)$)}}]
    ($(current page.north west)+(13,-10)$) rectangle ++(15,1.5);

    \shade[
    left color=ForestGreen,
    rounded corners=0.3cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(18,-8)$)}}]
    ($(current page.north west)+(18,-8)$) rectangle ++(15,0.6);

    \shade[
    left color=ForestGreen,
    rounded corners=0.4cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(19,-5.65)$)}}]
    ($(current page.north west)+(19,-5.65)$) rectangle ++(15,0.8);

    \shade[
    left color=OrangeRed,
    right color=red!80,
    rounded corners=0.6cm,
    transform canvas ={rotate around ={45:($(current page.north west)+(20,-9)$)}}]
    ($(current page.north west)+(20,-9)$) rectangle ++(14,1.2);



    % Title
    \node[align=center] at ($(current page.center)+(0,-5)$)
    {
    {\fontsize{38}{1} \selectfont {{OOP Design and Specification}}}\\[0.5in]

    {\fontsize{14}{19.2} \selectfont \textcolor{ForestGreen}{ \bf ThanhVu (Vu) Nguyen}}\\[0.1in]
    \today{} (latest version available on  \href{https://nguyenthanhvuh.github.io/class-oo/oop.pdf}{nguyenthanhvuh.github.io/class-oo/oop.pdf})
    };
    \end{tikzpicture}


\chapter*{Preface}



\newpage
\tableofcontents


\chapter{Introduction}\label{sec:intro}

This book will guide you through the fundamentals of constructing high-quality software using a modern \textbf{object-oriented programming} (OOP) approach.  We will use \emph{Python} for demonstration, but the concepts can be applied to any object-oriented programming language.  The goal is to develop programs that are reliable, efficient, and easy to understand, modify, and maintain.


\section{Decomposition}\label{sec:decomposition}

As the size of a program increases, it becomes essential to \emph{decompose} the program into smaller, independent programs (or functions or modules). This decomposition process allows for easier management of the program, especially when multiple developers are involved.   This makes the program easier to understand and maintain.




%\subsection{Decomposition}

Decomposition is the process of breaking a complex program into smaller, independent, more manageable programs, i.e., ``divide and conquer''. It allows programmer to focus on one part of the problem at a time, without worrying about the rest of the program.

\paragraph{Example} \autoref{ex:mergesort} shows a Python implementation of \emph{Merge Sort}, a classic example of problem decomposition. It breaks the problem of sorting a list into simpler problems of sorting smaller lists and merging them.

\begin{figure}[t]
\begin{lstlisting}[multicols=2, language=Python, keywordstyle=\color{blue}, commentstyle=\color{green!60!black}, stringstyle=\color{red}, basicstyle=\ttfamily\scriptsize]
def merge_sort(lst):
    if len(lst) <= 1:
        return lst

    mid = len(lst) // 2
    left = merge_sort(lst[:mid])
    right = merge_sort(lst[mid:])
    return merge(left, right)






def merge(left, right):
    result = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])
    return result
\end{lstlisting}
 \caption{Decomposition example: Mergesort}\label{ex:mergesort}
\end{figure}


\section{Abstraction}\label{sec:abstraction}



\emph{Abstraction} is a key concept in OOP that allows programmers to hide the implementation details of a program and focus on the essential features.
In an OOP language such as Python, you can abstract problems by creating functions, classes, and modules that hide the underlying implementation details.

\paragraph{Example} \autoref{ex:mammal} demonstrates an abstraction for different types of mammals. Mammals such as Dog and Cat share common behaviors such as making noise (speak). We can create a class \code{Mammal} that defines these common behaviors, and then subclasses \code{Dog} and \code{Cat} that inherit from \code{Mammal} and define their own unique behaviors.

\begin{figure}[t]
\begin{lstlisting}[multicols=2, language=Python, keywordstyle=\color{blue}, commentstyle=\color{green!60!black}, stringstyle=\color{red}, basicstyle=\ttfamily\scriptsize]

class Mammal:
    def __init__(self, name):
        self.name = name

    def speak(self): pass

class Dog(Mammal):
    def speak(self): return "Woof!"

class Cat(Mammal):
    def speak(self): return "Meow!"
\end{lstlisting}
 \caption{Decomposition example: Mergesort}\label{ex:mammal}
\end{figure}

\chapter{Procedural Abstraction}\label{chap:procedural-abstraction}

One common mechanism to \emph{procedural abstraction}, which achieves abstraction is through the use of functions (procedures). By separating procedure definition and invocation, we make two important methods of abstraction: abstraction by parameterization and abstraction by specification.

\paragraph{Abstraction by Parameterization}

This allows you to generalize a function by using parameters. By abstracting away the specific data with \emph{parameters}, the function becomes more versatile and can be reused in different situations. \autoref{ex:abs-parameterization} shows an example of abstract parameterization. The \code{cal\_area} function calculates the area of a rectangle given its length and width, which are passed as parameters.


\begin{figure}
\begin{lstlisting}
def cal_area(length, width):
    return length * width

# can be used with different values for length and width.
area1 = cal_area(5, 10)
area2 = cal_area(7, 3)

\end{lstlisting}
\caption{Example: Abstract Parameterization}\label{ex:abs-parameterization}
\end{figure}



\paragraph{Abstraction by Specification} This focuses on what the function does (e.g., sorting), instead of how it does it (e.g., using quicksort or mergsort algorithms). By defining a function's behavior through \emph{specifications}, developers can implement the function in different ways as long as it fulfills the specifications. Similarly, the user can use the function without knowing the implementation details.

\autoref{ex:abs-specification} shows an example of abstraction by specification. The \code{exists} method return true if the \code{target} item is found in a list of sorted \code{items}. The user only needs to provide a sorted list and a target, but does not need to know what algorithm is used or implemented to determine if the item exists in the list.

\begin{figure}
\begin{lstlisting}
def exists(items:List[int], target:int) -> bool:
    """
    Find an item in a list of sorted items.

    Pre: List of sorted items
    Post: True if the target is found, False otherwise.
    """
    ...

# The user only needs to know that this function checks for the existence of an item
#  in a sorted list, without needing to understand the search algorithm/implementation.

\end{lstlisting}
\caption{Abstraction by Specification}\label{ex:abs-specification}
\end{figure}

\section{Specifications}\label{sec:specifications}

We define abstractions through specifications, which describe what the abstraction is intended to do rather than how it should be implemented. This allows specifications to be much more concise and easier to read than the corresponding code.

Specifications which can be written in either \emph{formal} or \emph{informal languages}. Formal specifications have the advantage of being precise and unambiguous. However, in practice, we often use informal specifications, describing the behavior of the abstraction in plain English (e.g., the \code{sorting} example in \autoref{ex:abs-specification}).  Note that a specification is not a programming language or a program. Thus, our specifications won’t be written in code (e.g., in Python or Java)

\subsection{Specifications of a Function}
%3.3 Liskov

The specification of a function consists of a \emph{header} and a \emph{description} of its behavior.
The header gives the signature of the function, including its name, parameters, and return type. The description describes the function's behavior, including its preconditions and postconditions.

\paragraph{Header} The header provides the \emph{name} of the function, the number, order, and types of its \emph{parameters} (inputs), and the type of its return value (output). For instance, the headers for the \code{sort\_items} function in \autoref{ex:abs-specification} and the \code{cal\_area} function in \autoref{ex:abs-parameterization} are as follows

\begin{lstlisting}[language=Python, keywordstyle=\color{blue}, commentstyle=\color{green!60!black}, stringstyle=\color{red}, basicstyle=\ttfamily\scriptsize]
    def exists(items: list) -> bool: ...

    def calc_area(length: float, width: float) -> float: ...
\end{lstlisting}

Note that in a language like Java, the header also provides \emph{exceptions} that the function may throw.

\paragraph{Preconditions and Postconditions}

A typical function specification in an OOP language such as Python includes: \emph{Preconditions} (also called the ``requires'' clause) and \emph{Postconditions} (also called the ``effects'' clause). Preconditions describe the conditions that must be true before the function is called. Typically these state the constraints or assumptions about the input parameters. If there are no preconditions, the clause is often written as \code{None}.

Postconditions, under the assumption that the preconditions are satisfied, describe the conditions that will be true after the function is called. These typically state the expected results or outcomes of the function. Moreover, they often describe the relationship between the inputs and outputs.


The clauses are usually written as \emph{comments} above the function definition, making them easily accessible within the code.


\begin{lstlisting}[language=Python, keywordstyle=\color{blue}, commentstyle=\color{green!60!black}, stringstyle=\color{red}, basicstyle=\ttfamily\scriptsize]
    def calc_area(length: float, width: float) -> float:
        """
        Calculates the area of a rectangle given its length and width.

        Pre: None
        Post: The area of the rectangle.
        """
        ...
\end{lstlisting}

For example, the specification of the \code{calc\_area} function in \autoref{ex:abs-parameterization} has (i) no preconditions and (ii) the postcondition that the function returns the area of a rectangle given its length and width.  Similarly, the \code{exists} function in \autoref{ex:abs-specification} has the specification that given a list of sorted items (precondition), it returns true if the item is found in the list, and false otherwise (postcondition).  Note how the specification is written in plain English, making it easy to understand for both developers and users of the function.


\paragraph{Modifies} Another common clause in a function specification is \emph{modifies}, which describes the inputs that the function modifies. This is particularly useful for functions that modify their input parameters.

\begin{lstlisting}
    def add_to_list(input_list, value):
    """
    Adds a value to the input list.

    Pre: None
    Post: Value is added to the input list.
    Modifies: the input list
    """
    ...
\end{lstlisting}


\subsection{In-class Exercise: Equality}
This exercise touches on some thorny issues in data abstraction and inheritance. There is a lot going on in this example. Hence don’t worry if it seems confusing today. We’ll revisit this topic several times this semester.

\begin{enumerate}
    \item First, look at the \href{https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-}{Javadoc} to understand the behaviors \code{equals()} (while this is in Java, the concept is the same in Python).
    \begin{itemize}
        \item Specifically, read carefully the \emph{symmetric}, \emph{reflexive}, and \emph{transitive} properties of \code{equals()}.
        \item Ignore \emph{consistency}, which requires that if two objects are equal, they remain equal.
    \end{itemize}    
    \item For the \code{User} class in \autoref{ex:user}, does \code{equals()} satisfy the three equivalence relation properties? If not, what is the problem?
    \begin{itemize}
        \item Come up with several concrete test cases (e.g., create various \code{User} instances) to check the properties.
        \item If there is a problem, show the test case that demonstrates the problem.
        \item Explain why the problem occurs and come up with a fix.
    \end{itemize}
    \item So the same analysis for the \code{SpecialUser} class in \autoref{ex:specialuser}.
    \end{enumerate}
    
    % 1. Is the given implementation of `equals()` in class `SpecialUser` satisfy the 3 equivalence relation properties? If not, what is the problem? Be concrete: find a specific object (test case!) that demonstrates the problem. How does *inheritance* makes `equals()` in class `SpecialUser` harder to get right?
    

\begin{figure}
\begin{lstlisting}
# Do User first before doing SuperUser (much harder)

class User:
    def __init__(self, name):
        self.name = name

    def __eq__(self, other):
        if not isinstance(other, User):
            return False
        return self.name == other.name
\end{lstlisting}
\caption{User class}\label{ex:user}
\end{figure}


\begin{figure}
\begin{lstlisting}
class SpecialUser(User):
    """Don't do this until you've done with User"""

    def __init__(self, name, id):
        super().__init__(name)
        self.id = id

    def __eq__(self, other):
        if not isinstance(other, SpecialUser):
            return False
        return super().__eq__(other) and self.id == other.id
\end{lstlisting}
\caption{SpecialUser class}\label{ex:specialuser}
\end{figure}



\section{Designing Specifications}\label{sec:design-specifications}
%Liskov 3.5

When designing specifications, it is important to consider several factors to ensure that the function is well-defined and can be used effectively. These factors include the \emph{strength} of the pre- and post-conditions, whether the function is \emph{total} or \emph{partial}, and the \emph{avoiding implementation details} in the specification.

\subsection{Weak Pre-conditions}
For pre-conditions, we want as weak a constraint as possible to make the function more versatile, allowing it to handle a larger class of inputs.
A condition is weaker than another if it is implied by the other or having less constraints than the other. For example, the condition $x \le 5$ is weaker than $x \le 10$ or that the input list is not sorted is weaker than the list is sorted (which is weaker than the list that is both sorted and has no duplicates).
The \emph{weakest} precondition is \emph{True}, which indicates no constraints on the input.


\subsection{Strong Post-conditions}

In contrast, for post-conditions, we want as strong a condition as possible to ensure that the function behaves as expected. A condition is stronger than another if it implies the other or that its constraints are a strict subset of the other. For example, the condition $x \le 10$ is stronger than $x \le 5$ or that the input list is sorted is stronger than the list is not sorted.


\subsection{Total vs Partial Functions}

A function is \emph{total} if it is defined for all legal inputs; otherwise, it is \emph{partial}. Thus a function with no precondition is total, while a function with the strongest possible precondition is partial.  Total functions are preferred because they can be used in more situations, especially when the function is used publicly or in a library where the user may not know the input constraints. Partial functions can be used when the function is used internally, e.g., a helper or auxiliary function and the caller is knowledgeable and can ensure its preconditions are satisfied.

The functions \code{calc\_area} function in \autoref{ex:abs-parameterization} and \code{add\_to\_list} in \autoref{ex:abs-specification} are total because they can be called with any input. The \code{exists} function in \autoref{ex:abs-specification} is partial because it only works with sorted lists.


\paragraph{Turning Partial Functions into Total Functions} It is often possible to turn a partial function into a total function in two steps. First, we move preconditions into postconditions and specify the expected behavior when the precondition is not satisfied, e.g., throws an \code{Exception}. Second, we modify the function to satisfy the new specification, i.e., handling the cases when the preconditions are not satisfied. For example, the \code{exists} function in \autoref{ex:abs-specification} is turned into the total function shown in \autoref{ex:abs-total}.

\begin{figure}
\begin{lstlisting}
def exists(items: List[int], target: int) -> bool:
    """
    Find an item in a list of sorted items.

    Pre: True
    Post: If the input items are not sorted, raise an exception.
          Return True if the item is found, False otherwise.


    """

    if not is_sorted(items):
        raise Exception(...)
\end{lstlisting}
\caption{Total Specification for the program in \autoref{ex:abs-specification}}\label{ex:abs-total}
\end{figure}


\subsection{In-class Exercise: Total Function}

Consider the following code:

\begin{lstlisting}
def tail(my_list):
     result = my_list.copy()
     result.pop(0)
     return result
\end{lstlisting}

\begin{itemize}
     \item What does the implementation of \code{tail} do in each of the following cases? You might want to see the \href{https://docs.python.org/3/tutorial/datastructures.html}{Python document} for \code{pop}.  How do you know: Running the code or reading Python document?
     \begin{itemize}
         \item \code{list = None}
         \item \code{list = []}
         \item \code{list = [1]}  
         \item \code{list = [1, 2, 3]}
     \end{itemize}
     \item Write a \emph{partial specification} for \code{tail}
     \item Rewrite the specification to be \emph{total}. Use \emph{exceptions} as needed.
    \end{itemize}

\subsection{No implementation details}
The specification should not include any implementation details, such as the algorithm used or the data structures employed. This improves flexibility as it allows the function to be implemented in different ways as long as it satisfies the specification. For example, the \code{exists} function in \autoref{ex:abs-specification} does not specify the search algorithm used to find the item in the list.

Some common examples to avoid include the mentioning of specific data structures (e.g., arrays, indices), algorithms (e.g., quicksort or mergesort), and exceptions (e.g., related to IndexError). Instead, focus on the behavior of the function, such as the input and output relationships, the constraints on the input, and the expected results.
. Also avoid specifications mentioning indices because this implies the use of arrays.




%\chapter{Exception}
%Liskov 4 ,  but won't follow this because it talks about checked vs unchecked exceptions, which are not really applicable in Python.
\section{Exercise}

\subsection{Specification for Sorting}
Write the specification for the generic \code{ascending\_sort} method below. The specification should include preconditions and postconditions.
\begin{lstlisting}
    def ascending_sort(my_list):
        # REQUIRES/PRE: 
        # EFFECTS/POST: 
        ...
\end{lstlisting}
    


\subsection{Specification of Binary Search }
Come up with the specification for a \emph{binary search} implementation whose header is given below. Remember for precondition you want something as \emph{weak} as possible and for postcondition as \emph{strong} as possible. Note that binary search returns the \emph{location} (an non-neg integer) of the \code{target} value if found, and returns -1 if \code{target} is not found. 

\begin{lstlisting}
def binary_search(arr: List[int], target: int) -> int:
    """
    PRE/REQUIRES: 
    POST/EFFECTS: 
    """
    ... 
\end{lstlisting}


\subsection{Partial and Total Functions}

\begin{enumerate}
    \item Write the \emph{partial} specifications for the below two functions.
    \item Modify the specifications to make the functions \emph{total}.
    \item Modify the implementations of the two functions to satisfy the total specification.
\end{enumerate}

Recall that specifications do not deal with types (which are taken care by the function signature and enforced by the type system of compiler/interpreter).  In other words, you do not need to worry about types here and can assume conditions about types are satisfied.

\begin{lstlisting}
def divide(a:float, b:float) -> float:
    """
    PRE:
    POST:
    """
    return a / b

def get_average(numbers: list[float]) -> float:
    """
    PRE:
    POST:
    """
    total = sum(numbers)
    return divide(total, len(numbers))
\end{lstlisting}

    \chapter{Data Abstraction}
%Liskov 5

This chapter focuses on \emph{abstract data type} (ADT), a foundation of OOP and key concept in programming that allows developers to separate how data is implemented from how it behaves. Through ADT, programmers can create new data types relevant to their application. These ADTs consist of objects and associated operations.

%An ADT has two main components: \emph{parameterization} and \emph{specification}. Parameterization involves using parameters for flexibility, while specification means including operations as part of the data type, which abstracts away the underlying data representation. This ensures that even if the data structure changes, programs that rely on it remain unaffected, as they only interact with the operations rather than the data's internal structure.

%By abstracting data, developers can postpone decisions about data structures until they fully understand how the data will be used, leading to more efficient programs. ADT is also beneficial during program maintenance, as changes to the data structure affect only the type's implementation, not the modules using it.


\section{Specifications of an ADT}

As with functions (\autoref{chap:procedural-abstraction}, the specification for an ADT defines its behaviors without being tied to a specific implementation. The specification explains what the operations on the data type do, allowing users to interact with objects only via methods, rather than accessing the internal representation.


\paragraph{Structure of an ADT} In a modern OOP language such as Python or Java, data abstractions are defined using \emph{classes}. Each class defines a name for the data type, along with its constructors and methods.

\begin{figure}
    \begin{lstlisting}[language=Python, keywordstyle=\color{blue}, commentstyle=\color{green!60!black}, stringstyle=\color{red}, basicstyle=\ttfamily\scriptsize]
class DataType:
    """
    OVERVIEW: A brief description of the data type and its objects.
    """

    def __init__(self, ...):
        """
        Constructor to initialize a new object.
        """

    def method1(self, ...):
        """
        Method to perform an operation on the object.
        """
    \end{lstlisting}
    \caption{Abstract Data Type template}\label{ex:adt-template}
\end{figure}


\autoref{ex:adt-template} shows a class template in Python, which consists of three main parts. The \emph{overview} describes the abstract data type in terms of well-understood concepts, like mathematical models or real-world entities. For example, a stack could be described using mathematical sequences.
The overview can also indicate whether the objects of this type are \emph{mutable} (their state can change) or \emph{immutable}.
The \emph{Constructor} initializes a new object, setting up any initial state required for the instance.
Finally, \emph{methods} define operations users can perform on the objects. These methods allow users to interact with the object without needing to know its internal representation. In Python, \code{self} is used to refer to the object itself, similar to \code{this} in Java or C++.

Note that as with procedural specification (\autoref{chap:procedural-abstraction}), the specifications of constructors and methods of an ADT do not include implementation details. They only describe what the operation does, not how it is done. Moreover, they are written in plain English as code comment.


\subsection{Example: \code{IntSet} ADT}

\autoref{ex:intset} gives the specification for an \code{IntSet} ADT, which represents unbounded set of integers. \code{IntSet} includes a constructor to initialize an empty set, and methods to insert, remove, check membership, get the size, and choose an element from the set. \code{IntSet} is also mutable, as it allows elements to be added or removed. \emph{mutator} \code{insert} and \code{remmove} are mutator methods and have a \code{MODIFIES} clause.  In contrast, \code{is\_in}, \code{size}, and \code{choose} are \emph{observer} methods that do not modify the object.

\begin{figure}
    \begin{lstlisting}
    
class IntSet:
    """
    OVERVIEW: IntSets are unbounded, mutable sets of integers.
    This implementation uses a list to store the elements, ensuring no duplicates.

    """
    def __init__(self):
        """
        Constructor
        EFFECTS: Initializes this to be an empty set.
        """
        self.els = []  # the representation (list)

    def insert(self, x: int):
        """
        MODIFIES: self
        EFFECTS: Adds x to the elements of this set if not already present.
        """
        if not self.is_in(x): self.els.append(x)
            
    def remove(self, x: int):
        """
        MODIFIES: self
        EFFECTS: Removes x from this set if it exists.
        """
        if not(is_in(x): return
        self.els[i] = self.els[-1]  # Replace with the last element
        self.els.pop()  # Remove the last element

    def is_in(self, x: int) -> bool:
        """
        EFFECTS: Returns True if x is in this set, otherwise False.
        """
        for i, element in enumerate(self.els):
            if x == element:
                return True
        return False

    def size(self) -> int:
        """
        EFFECTS: Returns the number of elements in this set (its cardinality).
        """
        return len(self.els)

    def choose(self) -> int:
        """
        EFFECTS: If this set is empty, raises an Exception. 
        Otherwise, returns an arbitrary element of this set.
        """
        if len(self.els) == 0:
            raise Exception(...)
        return self.els[-1]  # Returns the last element arbitrarily

    def __str__(self) -> str:
        """
        Abstract function (AF) that returns a string representation of this set.
        EFFECTS: Returns a string representation of this set.
        """
        return str(self.els)
\end{lstlisting}
\caption{The IntSet ADT}\label{ex:intset}
\end{figure}

%\subsection{Example: \code{Polynomial} ADT}

\section{Implementing ADT}\label{sec:implementing-adt}

To implement an ADT, we first choose a \emph{representation} (\textbf{rep}) for its objects, then design constructors to initialize it correctly, and methods to interact with and modify the rep. 
For example, we can use a \code{list} (or vector) as the rep of \code{IntSet} in \autoref{ex:intset}. We could use other data structures, such as a \code{set} or \code{dict}, as the rep, but a list is a simple choice for demonstration.


To aid understanding and reasoning of the rep of an ADT, we use two key concepts: \emph{representation invariant} and \emph{abstraction function}.

\subsection{Representation Invariant (Rep-Inv)} Because the rep might not be necessarily related to the ADT itself (e.g., the list has different properties compared to a set), we need to ensure that our use of the rep is consistent with the ADT's behavior. 
To do this, we use \emph{representation invariant} (\textbf{rep-inv}) to specify the constraints for the rep of the ADT to capture its behavior. 

For example, the rep-inv for a stack is that the last element added is the first to be removed and the rep-inv for a binary search tree is that the left child is less than the parent, and the right child is greater. 
The rep-inv for our \code{IntSet} ADT in \autoref{ex:intset} is that all elements in the list are unique. 
\begin{lstlisting}
    # Rep-inv:
    # els is not null, only contains integers and has no duplicates.
\end{lstlisting}

The rep-inv must be preserved by all methods (more precisely, \emph{mutator} methods). It must hold true before and after the method is called. The rep-inv might be violated temporarily during the method execution, but it must be restored before the method returns. For \code{IntSet} Notice that the mutator \code{insert} method ensures that the element is not already in the list before adding it. 

The rep-inv is decided by the designer and specified in the ADT documentation as part of the specification (just like pre/post conditions) so that it is ensured at the end of each method (like the postcondition). Moreover, because rep-inv is so important, it is not only documented in comments but also checked at runtime.  This is done by invoking a \code{repOK}, discussed later, method at the start and end of each method.


\subsection{Abstraction Function (AF)} It is difficult to understand the ADT by looking at the rep directly. For example, we might not be able to visualize or reason about a binary tree or a graph ADT when using list as the rep. To aid understanding, \emph{abstraction function} (\textbf{AF}) provides a mapping between the rep and the ADT. 
Specifically, the AF maps from a \emph{concrete state} (i.e., the \code{else} \code{els}) to an \emph{abstract state} (i.e., the set). AF is also a \emph{many-to-one} mapping, as multiple concrete states can map to the same abstract state, e.g., the list \code{[1, 2, 3]} and \code{[3, 2, 1]} both map to the same set \code{\{1, 2, 3\}}. 

Just as with rep-inv, the AF is documented in the class specification. Modern OOP languages often provide methods implementing the AF, in particular developer overrides the \code{\_\_str\_\_} method in Python and \code{toString} in Java to return a string representation of the object. For example, the \code{\_\_str\_\_} method in \autoref{ex:intset} returns a string representation of the set.



\subsection{In-Class Excercise: Stack}

In this exercise, you will implement a \code{Stack} ADT. A stack is a common data structure that follows the Last-In-First-Out (LIFO) principle. You will:
\begin{enumerate}
\item Choose a Representation (rep) for the stack.
\item Define a Representation invariant (rep-inv)
\item Write a \code{repOK} method
\item Provide the specifications of basic stack operations (\code{push}, \code{pop}, \code{is\_empty}) and implement these methods accordingly.
\item Define an Abstraction Function (AF)
\item Implement \code{\_\_str\_\_()} to return a string representation of the stack based on the AF
\end{enumerate}

\begin{figure}
\begin{lstlisting}
    class Stack:
    """
    OVERVIEW: Stack is a mutable ADT that represents a collection of elements in LIFO.
    AF(c) = the sequence of elements in the stack in sorted order from bottom to top.
    rep-inv: 
        1. elements is a list (could be empty list, which represents and empty stack).
        2. The top of the stack is always the last element in the list.
    """

    def __init__(self):
        """
        Constructor
        EFFECTS: Initializes an empty stack.
        MODIFIES: self
        """
        self.elements = []

    def repOK(self):
        """
        EFFECTS: Returns True if the rep-invariant holds, otherwise False.
        The invariant checks:
        1. elements is a list.
        2. If the stack is non-empty, the top of the stack is the last element in the list.
        """
        # Check that elements is a list
        if not isinstance(self.elements, list):
            return False
        
        # If the stack is not empty, ensure that the top is the last element in the list.
        # This is implicitly guaranteed by the use of `list.append` for push and `list.pop` for pop,
        # so no further explicit check is needed for the "top as last element."
        return True

    def push(self, value):
        """
        MODIFIES: self
        EFFECTS: Adds value to the top of the stack.
        """
        self.elements.append(value)

    def pop(self):
        """
        MODIFIES: self
        EFFECTS: Removes and returns the top element from the stack. 
        Raises an exception if the stack is empty.
        """
        if self.is_empty():
            raise Exception("Stack is empty")
        return self.elements.pop()

    def is_empty(self):
        """
        EFFECTS: Returns True if the stack is empty, otherwise False.
        """
        return len(self.elements) == 0

    def __str__(self):
        """
        EFFECTS: Returns a string representation of the stack,
                 showing the elements from bottom to top.
        """
        # The abstraction function maps the list of elements to a stack view
        return f"Stack({self.elements})"
\end{lstlisting}
\caption{Stack ADT}\label{ex:stack}
\end{figure}

\section{Mutability vs. Immutability}\label{sec:mutability-vs-immutability}

An ADT can be either mutable or immutable, depending on whether their objects' values can change over time. An ADT should be immutable if the objects it models naturally have unchanging values, such as mathematical objects like integers, polynomials (Polys), or complex numbers. On the other hand, an ADT should be mutable if it models real-world entities that undergo changes, such as an automobile in a simulation, which might be running or stopped, or contain passengers, or if the ADT models data storage, like arrays or sets.

Immutability is beneficial ecause it offers greater safety and allows sharing of subparts without the risk of unexpected changes. Moreover, immutability can simplify the design by ensuring the object’s state is fixed once created. However, immutable objects can be less efficient, as creating a new object for each change can be costly in terms of memory and time.

\paragraph{Converting from mutable to immutable} 
Given a mutable ADT, it is possible to convert it to an immutable one by ensuring that the rep is not modified by any method. This can be achieved by making the rep private and only allowing read-only access to it. Moreover, for the mutator methods, they should return a new object with the updated rep, rather than modifying the existing object. If the mutator returns a value, then create two methods, one return the new object and the other return the value. For example, a mutator \code{pop} method of a Stack would result into two methods: \code{pop2} returns the top element and \code{pop3} returns the new stack with the top element removed.

Finally, it is important that while it is possible to convert a mutable ADT to an immutable one as shown, mutability or immutability should be the property of the ADT type itself, not its implementation. Thus, it should be decided at the design stage and documented in the ADT specification.

\subsection{In-class Exercise: Immutable Queue}\label{ic:immutable-queue}


\begin{figure}
    \begin{lstlisting}[language=Python, keywordstyle=\color{blue}, commentstyle=\color{green!60!black}, stringstyle=\color{red}, basicstyle=\ttfamily\scriptsize]

class Queue:
    """
    A generic Queue implementation using a list.
    """

    def __init__(self):
        """
        Constructor
        Initializes an empty queue.
        """
        self.elements = []
        self.size = 0

    def enqueue(self, e):
        """
        MODIFIES: self
        EFFECTS: Adds element e to the end of the queue.
        """
        self.elements.append(e)
        self.size += 1

    def dequeue(self):
        """
        MODIFIES: self
        EFFECTS: Removes and returns the element at the front of the queue.
        If the queue is empty, raises an IllegalStateException.
        """
        if self.size == 0:
            raise Exception(...)

        result = self.elements.pop(0)  # Removes and returns the first element
        self.size -= 1
        return result

    def is_empty(self):
        """
        EFFECTS: Returns True if the queue is empty, False otherwise.
        """
        return self.size == 0

    \end{lstlisting}
    \caption{Mutable Queue}\label{ex:mutable-queue}
\end{figure}

Consider the mutable \code{Queue} implementation in \autoref{ex:mutable-queue}.
\begin{enumerate}
\item Rewrite Queue to be \emph{immutable}. Keep the representation variables \code{elements} and \code{size}.
\end{enumerate}



% \subsection{Locality and Modifiability}\label{sec:locality-modifiability}

% \emph{Locality} (the ability to reason about an ADT indepepdently of other code) and \emph{modifiability} (the ability to change an implementation without affecting other parts of the code) are two important concepts in writing code. It applies to functions (we want the function to be independent of other functions) and certain to data abstractions. For ADT implementation, this requires that the rep should be modifiable only within the ADT implementation and not outside of the ADT. This is achieved by making the rep \emph{private} and providing methods to access and modify the rep.

% Modifiability goes further than locality. To achieve modifiability, not only must modifications be restricted to the ADT implementation, but all access to the internal representation—-even for reading immutable components--must also be confined to the implementation. If other modules can access the internal representation, then changing the representation may affect those modules, violating modifiability. To ensure modifiability, instance variables must be declared private and cannot be exposed outside the ADT.
% Thus, it is essential that access to the internal representation is restricted to the ADT implementation. %Programming languages like Python allow encapsulation, ensuring that the representation is hidden and protected. If access to the representation is unrestricted, it becomes an additional property that must be proven about the code manually.

\section{Excercise}

\subsection{HW: Polynomial ADT}
\begin{figure}
\begin{lstlisting}
from collections import defaultdict
from sortedcontainers import SortedDict

class Poly2:
    def __init__(self, c=0, n=0):
        if n < 0:
            raise ValueError("Poly2(int, int) constructor: n must be >= 0")
        self.trms = SortedDict()
        if c != 0:
            self.trms[n] = c

    def degree(self):
        if len(self.trms) > 0:
            return next(reversed(self.trms.keys()))
        return 0

    def coeff(self, d):
        if d < 0:
            raise ValueError("coeff: d must be >= 0")
        return self.trms.get(d, 0)

    def sub(self, q):
        if q is None:
            raise ValueError("sub: q is None")
        return self.add(q.minus())

    def minus(self):
        result = MapPoly()
        for n, c in self.trms.items():
            result.trms[n] = -c
        return result

    def add(self, q):
        if q is None:
            raise ValueError("add: q is None")
        
        non_zero = set(self.trms.keys()).union(q.trms.keys())
        result = MapPoly()
        for n in non_zero:
            new_coeff = self.coeff(n) + q.coeff(n)
            if new_coeff != 0:
                result.trms[n] = new_coeff
        return result

    def mul(self, q):
        if q is None:
            raise ValueError("mul: q is None")
        
        result = MapPoly()
        for n1, c1 in self.trms.items():
            for n2, c2 in q.trms.items():
                result = result.add(MapPoly(c1 * c2, n1 + n2))
        return result

    def __str__(self):
        r = "MapPoly:"
        if len(self.trms) == 0:
            r += " 0"
        for n, c in self.trms.items():
            if c < 0:
                r += f" - {-c}x^{n}"
            else:
                r += f" + {c}x^{n}"
        return r
\end{lstlisting}
\caption{Polynomial ADT}\label{ex:poly2}
\end{figure}


Use the Poly2 ADT in \autoref{ex:poly2} to answer the following question. Use the \code{Stack} ADT in \autoref{ex:stack} as an example. 

\begin{enumerate}
\item Write an Overview that describes what \code{Poly2} does. You must provide some examples to demonstrate (e.g., Poly2(2,3) means what?).  Hint: do this step as thoroughly as possible as the other questions depend on your understanding of the ADT

\item Provide the specifications for all methods in the ADT. 
\item Write the \textbf{rep} used in this code.  Describe how this rep represents \code{Poly2}.
\item Provide the \textbf{rep-inv} for the \code{Poly2} ADT. Note, this would be the constraints over the rep variable(s).
\item Write a RepOK method that checks the rep-inv.
\item Describe the AF in this code. Use \code{\_\_str\_\_} to help.

\end{enumerate}
\appendix

%\chapter{In-Class exercises}\label{sec:in-class-exercises}

\chapter{Lectures}

\section{Module 1: Overview}
\begin{itemize}
\item \href{https://nguyenthanhvuh.github.io/class-oo/syllabus.pdf}{Syllabus}  (no cheating)
\item Overview
\begin{itemize}
    \item Decomposition (\autoref{sec:decomposition})
    \item Abstraction (\autoref{sec:abstraction})
    \item Abstraction by Parameterization (\autoref{ex:abs-parameterization})
    \item Abstraction by Specification (\autoref{ex:abs-specification})
    \item Specifications (\autoref{sec:specifications})
\end{itemize}\item


\item Break 1 (25 mins):  5 min break,  20 min \href{https://nguyenthanhvuh.github.io/class-oo/assignments#ic1-a}{IC1-A} exercise

% - preconds: input is a list of /comparable/ items
% - postcond:
%   - output is sorted
%   - output is a __permutation_ of data input

\item{Correctness Overview}
\begin{itemize}
    \item Ideally: Satisfies preconditions and postconditions
    \item 4 scenarios to consider
    \begin{enumerate}
        \item Precondition is satisfied, postcondition is satisfied: correct
        \item Precondition is satisfied, but postcondition is not: incorrect
        \item Precondition not satisfied, but postcondition is: correct
        \item Precondition not satisfied, but postcondition is not: correct
    \end{enumerate}
    \item Preconditions are the responsibility of the caller (the client)
    \item Postconditions are the responsibility of the developer (the supplier, i.e., you)
    \item For many non-OOP programs, this is relatively straightforward and can be checked automatically.  Things become quite thorny when dealing with OOPs (e.g., inheritence)
\end{itemize}

\item Break 2 (25 mins) :  5 min break,  20 min \href{https://nguyenthanhvuh.github.io/class-oo/assignments#ic1-b}{IC1-B} exercise

\end{itemize}



\section{Module 2:}

\bibliographystyle{abbrv}


\end{document}
