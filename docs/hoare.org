#+begin_src txt

{True} x := 5; {x=5}   // strongest postcondition
{True} x := 5; {True}
{True} x := 5; {x >= 0}
{True} x := 5; {x >= 5} // x=5 OR x=6 or X... 


{x == y}  x:= x + 3 {y = x - 3} // strongest condition
{x == y}  x:= x + 3 {x >= y}
{x == y}  x:= x + 3 {x > y}

{x > -1}  x:= 2*x + 3  {x <= 3} // X 
{x > -1}  x:= 2*x + 3  {x >= 1}    x = 1 OR x= 2 or X=3 ......  

{x > -1}  x:= 2*x + 3  {x >= 3} // STRONGEST post condition

x = 0  ...  x = 3    x >= 3
x = 1  ...  x = 5
x = 2 ...   x = 7
.....

{x==a}  if x < 0: x = - x {x == |a|}
{True}  if x < 3: x = 10 else: x = 20  { x == 10 || x == 20 }

{False} x := 3 {x != 3}
{False} x := 3 {False}
{False} x := 3 {x= any int}

{x < 0}  while(x!=0) x:= x - 1 {X < 0}
{x < 0}  while(x!=0) x:= x - 1 {ANYTHING}

#+end_src

Partial Correctness: 
- Talk about compilers if have time   
  - assume P holds,  *if* S successfully executes, then Q holds

#+begin_src txt
{True} x := 5 {x=5 or x= 6 or x > 6}  *valid*
{True} x := 5 {x > 6}  *invalid* 
{x == 5}  x += 2  {x < 7}  # x == 7 does not imply *x < 7*


{x < y} z:= x/y  {z < 1}   *Invalid* y=0 
{x = 0} z:= x/y  {z < 1}   *Invalid* x=0, y=0 
{y != 0} z:= x/y  {z < 1}  *Invalid* x = 2 , y =1  
{x < y & y != 0} z:= x/y {z <1} *invalid*   x=-2,  y=-1

{0 < x < y & y != 0} z:= x/y {z <1} *valid*   weakest precondition 
{x = 1 & y = 2} z:= x/y  {z < 1}  *Valid*  
{x = 2 & y = 4} z:= x/y {z <1} *valid*

#+end_src

** Verification using Hoare logic
- To prove ={P}  S  {Q}=  is valid,   we check if  ~P =>  WP(S, Q)~
  - `WP`: a function returning the weakest precondition allowing the execution of S to achieve Q

- S is an ASSIGNMENT statement 
  - WP(x := E, Q) = Q[x/E]
    WP(x := 3, {x + y = 10}) =  3 + y = 10  =   y = 7
    
  - {y==7} x := 3 {x + y = 10}

    WP(x := 3, {x + y > 0) =  3 + y > 0  = y > -3
  - {y > -3}  x := 3 {x + y> 0}

- S is a LIST of Statements
  - WP(S1; S2; S3 ...;  Q)  = WP(S1, WP(S2;S3;.., Q))
  - wp(x:=x+1; y = y*x, {y=2*z})

    {y*(x+1)=2*z} x:=x+1; {y*x=2*z} ; y := y*x, {y=2*z}

    wp(y:=y*x, {y=2*z}) =  y*x=2*z
    wp(x:=x+1, {y*x=2*z}) = {y*(x+1)=2*z}

    WP(x:=x+1, y=y*x, {y=2*z}) = WP(x:=x+1,WP(y=y*x, {y=2*z}))
                               = WP(x:=x+1, {y*x=2*z})
                               = {y*(x+1)=2*z}

- S is CONDITION
  wp(...)
  
- S is a LOOP                               
  - {x <= 99 or x = 100} while (x < 100) x = x+ 1; {x=100}
  - {x <= 100} while (x < 100) x = x+ 1; {x=100}
  - WP(while, Q) = loop invariant of the while loop

     - *Loop invariant*: captures the meaning of the loop (manually provided by you)
        -  property that holds when the loop entered 
        -  is preserved after the loop body is executed  (inductive loop invariant)


#+begin_src java
  {N >= 0}

  {0 <= N}
  i := 0 ;

  {i <= N}//wp for the while loop below wrt to Q= i == N using i <= N
  {False} //wp for the while loop below wrt to Q= i == N using N >= 0

  //LOOP INV:  i <= N
  //LOOP INV: i <= 0  # NOT LOOP INV
  //LOOP /inv : i>=0 
  //LOOP INV :  N >= 0
  //LOOP INV:  TRUE

  while(i < N){
      i := N;
  }

  {i == N}

#+end_src

- WP(while[I] B do S,  {Q}) =
   1. I and
   2. (I &b) => wp(S,I)
   3. (I &!b) => Q

- using ~i <= N~ as loop invariant to prove program
  - wp(while[i<=N] i < N do i:=N, {i == N}) =
    1. ~i <= N~
    2. ~(i <= N & i < N)   => wp(i:=N, {i<=N})~
       ~i < N  =>   N <= N ~
       ~i < N =>  True~
       ~True~
       
    3. ~i <= N & !(i<N) => i == N~
        ~i == N => i == N~
        True
        
    =  ~i <= N~

~wp(while[i<=N] i < N do i:=N, {i == N}) = i <= N~


wp(i:=0; {i<=N}) = 0 <= N

P => wp(...)
N>=0  => 0 <= N

- using ~N >= 0~
- wp(while[N >= 0] i < N do i:=N, {i == N}) =
  1. ~N >= 0~
  2. ~(N >=0 & i < N) => wp(i := N, N >= 0)~
      -   ~(N >=0 & i < N) => i >= 0~
        
  3. ~N >=0 & !(i<N) => i ==N~
     ~(N >= 0 & i >= N) => i == N~
     ~i>= 0  => i == N~
     ~False~
 =  False  
 

N >= 0 => False  
False 

Demorgan Law

a => b   ==  !a or b


!a or True  == True
!a or b
!(i == N)  or (i==N)  = True

a and b and c

b == true  =>  a and c


