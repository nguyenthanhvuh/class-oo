<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-02-06 Sun 18:02 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Thanhvu Nguyen" />
</head>
<body>
<div id="content">
<p>
<span class="timestamp-wrapper"><span class="timestamp">&lt;2022-01-31 Mon&gt;</span></span>
</p>

<ul class="org-ul">
<li><p>
Specification/Contract of a program
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #b58900;">int</span> <span style="color: #268bd2;">add2numbers</span>(<span style="color: #b58900;">int</span> <span style="color: #268bd2;">x</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">y</span>){
    <span style="color: #586e75;">//</span><span style="color: #586e75;">requires/preconditions</span>
    <span style="color: #586e75;">//</span><span style="color: #586e75;">- x and y are integers</span>

    <span style="color: #586e75;">//</span><span style="color: #586e75;">effects/postconditions</span>
    <span style="color: #586e75;">//</span><span style="color: #586e75;">- z is integer</span>
    <span style="color: #586e75;">//</span><span style="color: #586e75;">- z = x + y</span>
    <span style="color: #859900; font-weight: bold;">return</span> z;
}
</pre>
</div>

<pre class="example">

List sortAscending(List&lt;Int&gt; l){
   //preconds:  l is a list of integers 
   //l cannot be null
   //l cannot contain null

   //postconditions:
   - l' has an ascending order 
   - l' is a permutation of l
   return l';
}
</pre></li>
</ul>


<div class="org-src-container">
<pre class="src src-java"><span style="color: #b58900;">User</span> <span style="color: #268bd2;">u</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">User</span>(&#8220;SWE619&#8221;);
u.equals(u); <span style="color: #586e75;">// </span><span style="color: #586e75;">contract: T, impl: T</span>
u.equals(<span style="color: #268bd2; font-weight: bold;">null</span>); <span style="color: #586e75;">//</span><span style="color: #586e75;">contract: F, impl: F</span>
u.equals(<span style="color: #2aa198;">"SWE619"</span>); <span style="color: #586e75;">//</span><span style="color: #586e75;">contract: F, impl: F</span>

<span style="color: #b58900;">User</span> <span style="color: #268bd2;">v</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">User</span>(<span style="color: #268bd2; font-weight: bold;">null</span>);
v.equals(u); <span style="color: #586e75;">//</span><span style="color: #586e75;">contract:F, impl: F</span>
u.equals(v); <span style="color: #586e75;">//</span><span style="color: #586e75;">contract:F, impl: exception</span>

</pre>
</div>


<p>
testing vs verfication
</p>
<ul class="org-ul">
<li>testing:  test if the program works over a <b>finite</b> number of inputs</li>
<li>verification: formally/mathematically show/guarantee that a program works over <b>all possible</b> inputs
<ul class="org-ul">
<li>Nasa rovers</li>
<li>A318: formally proved that no floating pt errs</li>
<li>robotic surgical arms</li>
</ul></li>
</ul>



<p>
Precondition (P):
</p>
<ul class="org-ul">
<li>client/customer: establish  P</li>
</ul>
<p>
Postcondition (Q)
</p>
<ul class="org-ul">
<li>developer/implementation:  establish Q under assumption that P is established</li>
</ul>


<ul class="org-ul">
<li>If a program is not correct
<ul class="org-ul">
<li>if precondition is wrong: blame client</li>
<li>if (precondition is met) postcondition is wrong: blame developer</li>
</ul></li>
</ul>


<ul class="org-ul">
<li><p>
sqrt example  :  y = sqrt(x)
preconditions:
</p>
<ul class="org-ul">
<li>x &gt; 0 (preferred)</li>
<li>x &gt;= 0 (preferred)</li>
<li>x is an integer (preferred)</li>
<li>100 &lt;= x  &lt;= 200  (not preferred)</li>
<li>x = 101  (not preferred)</li>

<li>best precondition: no precondition</li>
</ul>

<p>
postconditions:
</p>
<ul class="org-ul">
<li>y is a number</li>
<li>y &lt;= x</li>
<li>y*y == x (-/+ epsilon)   ~~ y = x/y  (preferred)</li>
</ul></li>
</ul>



<ul class="org-ul">
<li>partial vs total specification
<ul class="org-ul">
<li>partial specification:  has a precondition</li>
<li>total specification:  has NO precondition</li>
</ul></li>

<li><p>
how to turn a partial into a total specification?
//partial spec
sqrt(x):
   precondition: x &gt;= 0
   postcondition:  y*y == x (-/+ epsilon)
</p>

<p>
//total spec
sqrt(x):
   precondition: 
   postcondition:
       //if x &lt; 0:  raise exception
       //ow.  y*y == x (-/+ epsilon)
</p>

<p>
//div<sub>xy</sub>(x,y):   output = x/y
partial spec:
 precond:  y != 0
 post :   y*output == x
</p>

<p>
total spec:
  precond: true
  postcondition:   if y is 0, raise exception(DivByZero);
  y*output = 
</p></li>
</ul>



<p>
list = null,  NPE
list = [], IOBE
list = [1], []  *
list = [1,2,3] , [2,3] *
</p>

<p>
pre: non-empty list and non-null
post: remove the head, return the rest (tail)
</p>

<p>
//total
pre: 
post:
if  (list is []) throw IOBE
if (list is null) throw NPE
remove the head, return the rest (tail)
</p>

<p>
specification too specific to implentation (remove(0)), to fix: throws IAE instead of IOBE when list is []
</p>




<p>
<span class="timestamp-wrapper"><span class="timestamp">&lt;2022-01-24 Mon&gt;</span></span>
</p>

<p>
What does it mean to write correct software?
</p>
<ul class="org-ul">
<li>It conforms to some expectation (software contracts or specificaions)</li>
<li>Should pass its testsuite  ..</li>
<li>Should not have exception or performance issues</li>
</ul>


<ul class="org-ul">
<li>Specifications/contracts (requirements)</li>
<li>Should not have exception or error</li>

<li>Performance, maintainable, expandable :  desired qualities , but not</li>
</ul>
<p>
required for <b>correctness</b>
</p>


<p>
f (x, y):   // return output = x  / y
   //precond:  x,y are reals
</p>

<p>
if y == 0:  raise exception
&#x2026;
</p>




<p>
preconditions
</p>
<ul class="org-ul">
<li>x,y are reals</li>
<li>y != 0</li>
<li>x &gt;= 0</li>
<li>x &gt;=  100</li>
<li>we want preconditions are are as WEAK as possible
<ol class="org-ol">
<li>x could be any real numbers</li>
<li>x must be non-negative</li>
<li>x must be &gt;= 100</li>
</ol></li>
</ul>

<p>
3 is stronger than 2 is stronger 1
the best precondition is the weakest one, i.e., TRUE  (the function
has no assumption on the input)
</p>


<ul class="org-ul">
<li>output : number</li>
<li>output ~   x /y    (output * y   ~= x)</li>

<li>precondition/requirements:  a condition over the inputs ,</li>
</ul>
<p>
assumptions that we make when the function starts
</p>
<ul class="org-ul">
<li>x,y being real numbers</li>
<li>y != 0</li>
</ul>
<ul class="org-ul">
<li>postcondition/behaviors:  behavior of the function (the program),</li>
</ul>
<p>
relationshp btw inputs and outputs
</p>

<ol class="org-ol">
<li>output is a number (reals,&#x2026; )     weaker</li>
<li>output * y ~= x                     stronger</li>
</ol>

<p>
the best postcondition is the strongest one,  i.e.,   output * y ~= x
</p>

<ul class="org-ul">
<li>side-effects:
<ul class="org-ul">
<li>can change input X, &#x2026;.</li>
</ul></li>
</ul>


<p>
task: sorting a list of numbers in ascending order  (e.g., 1,5,10,&#x2026;)
</p>

<p>
g(l):
  //precondition: a list of numbers
  //same data types (comparable)
  //iterable &#x2026;
  //finite
</p>

<p>
<i>/ l is arraylist of integers
/</i> precondition over l:   none,  true
</p>

<p>
postcondition:
</p>
<ul class="org-ul">
<li>|l| == |l'|</li>
<li>l' same datatype  as l</li>
<li>[1,2,1,2]   [1,1,1,2]</li>
<li>l' is a permutation of l</li>
<li>l' ascending order</li>
</ul>


<p>
//sort l in ascending order
return l'
</p>




<p>
type checking
</p>

<ul class="org-ul">
<li>void f (int x, int y){
int o = 3;
return o;</li>
</ul>
<p>
}
</p>

<ul class="org-ul">
<li>type-checker is light-weight analysis and therefore can be built in in comilers,  just check if x and y are integers</li>
<li>assertion checking is heavy-weight because we can check expressive properties such as y = x ** 2; never built in, have to do some serious program analysis for this.</li>
</ul>
<p>
assertion(y = x**2);
</p>
</div>
</body>
</html>
