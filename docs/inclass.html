<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-07-11 Sun 19:51 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>SWE 619 In Class Exercises</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="ThanhVu (Vu) Nguyen" />
<link rel="stylesheet" href="https://nguyenthanhvuh.github.io/files/org.css">
<link rel="stylesheet" href="https://nguyenthanhvuh.github.io/files/org-orig.css">
<link rel="stylesheet" href="https://nguyenthanhvuh.github.io/files/org.css">
<link rel="stylesheet" href="https://nguyenthanhvuh.github.io/files/org-orig.css">
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">SWE 619 In Class Exercises</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org7286349">In Class Exercises</a>
<ul>
<li><a href="#org31d8dc6">In class 0</a></li>
<li><a href="#org4b555ea">In class 1A</a></li>
<li><a href="#org83b4357">In class 1B</a></li>
<li><a href="#org744843d">In class 2A</a></li>
<li><a href="#org630c076">In class 2B</a></li>
<li><a href="#org6a51d65">In class 3A</a></li>
<li><a href="#org4b24303">In class 3B</a></li>
<li><a href="#org631ae73">In class 4A</a></li>
<li><a href="#orga325563">In class 4B</a></li>
<li><a href="#orgc1ca432">In class 5A</a></li>
<li><a href="#org10e755d">In class 5B</a></li>
<li><a href="#orgb8d6414">In class 5C</a></li>
<li><a href="#orgc38f5db">In class 6</a></li>
<li><a href="#org4d049ef">In class 8A</a></li>
<li><a href="#orgf05ff2f">In class 8B</a></li>
<li><a href="#orgf8a52d1">In class 8C</a></li>
<li><a href="#org1347a48">In class 9A</a></li>
<li><a href="#orgb4fa7f4">In class 9B</a></li>
<li><a href="#org746e041">In class 10A</a></li>
<li><a href="#org998b626">In class 10B</a></li>
<li><a href="#org11d0a7b">In class 10C</a></li>
<li><a href="#org2503359">In class 11</a></li>
<li><a href="#org20d65d1">In class 12A</a></li>
<li><a href="#org2f32a1a">In class 12B</a></li>
<li><a href="#org07c73a4">In class 13</a></li>
</ul>
</li>
<li><a href="#orgd36977d">Links</a></li>
</ul>
</div>
</div>

<div id="outline-container-org7286349" class="outline-2">
<h2 id="org7286349">In Class Exercises</h2>
<div class="outline-text-2" id="text-org7286349">
</div>
<div id="outline-container-org31d8dc6" class="outline-3">
<h3 id="org31d8dc6">In class 0</h3>
<div class="outline-text-3" id="text-org31d8dc6">
<p>
Work with your group. Your group assignment is on Piazza. (You might decide to change groups later, but for today, stick with this group.) When we invoke the BB break-out function, nagivate to your assigned group.
</p>

<ol class="org-ol">
<li>Your group should spend a few minutes getting acquainted. Explain a bit about yourself: full-time student?, working in  software development?, why are you taking this class?, favorite/least favorite thing about writing software?, etc.</li>
<li>Decide on a mechanism for joint communication. Google docs? IDE with screen share? Something else?</li>
</ol>

<p>
Now address a technical topic. This exercise touches on some of the thorny issues in data abstraction and inheritance. There is a lot going on in this example. Hence don't worry if it seems confusing today. We'll revisit this example several times over the course of the semester.
</p>

<p>
Consider the following (textbook) code:
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">User</span> {
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900; font-style: italic;">String</span> <span style="color: #268bd2;">name</span>;
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">User</span> (<span style="color: #b58900; font-style: italic;">String</span> <span style="color: #268bd2;">name</span>) { <span style="color: #859900; font-weight: bold;">this</span>.name = name; }
    <span style="color: #6c71c4; font-weight: bold;">@Override</span> <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">boolean</span> <span style="color: #b58900;">equals</span> (<span style="color: #b58900; font-style: italic;">Object</span> <span style="color: #268bd2;">obj</span>) {
        <span style="color: #859900; font-weight: bold;">if</span> (<span style="color: #268bd2; font-weight: bold;">!</span>(obj <span style="color: #859900; font-weight: bold;">instanceof</span> User)) <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #6c71c4; font-weight: bold;">false</span>;
        <span style="color: #859900; font-weight: bold;">return</span> ((<span style="color: #b58900; font-style: italic;">User</span>) obj).name.equals(<span style="color: #859900; font-weight: bold;">this</span>.name);
    }
    <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">other methods omitted</span>
}
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">SpecialUser</span> <span style="color: #859900; font-weight: bold;">extends</span> <span style="color: #b58900; font-style: italic;">User</span> {
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">id</span>;
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">SpecialUser</span> (<span style="color: #b58900; font-style: italic;">String</span> <span style="color: #268bd2;">name</span>, <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">id</span>) { <span style="color: #859900; font-weight: bold;">super</span>(name); <span style="color: #859900; font-weight: bold;">this</span>.id = id; }
    <span style="color: #6c71c4; font-weight: bold;">@Override</span> <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">boolean</span> <span style="color: #b58900;">equals</span> (<span style="color: #b58900; font-style: italic;">Object</span> <span style="color: #268bd2;">obj</span>) {
        <span style="color: #859900; font-weight: bold;">if</span> (<span style="color: #268bd2; font-weight: bold;">!</span>(obj <span style="color: #859900; font-weight: bold;">instanceof</span> SpecialUser)) <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #6c71c4; font-weight: bold;">false</span>;
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">super</span>.equals(obj) &amp;&amp; ((<span style="color: #b58900; font-style: italic;">SpecialUser</span>) obj).id == <span style="color: #859900; font-weight: bold;">this</span>.id;
    }
    <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">other methods omitted</span>
}
</pre>
</div>

<ol class="org-ol">
<li>Walk though the execution of the <code>equals()</code> method in class <code>User</code> for a few well-chosen objects as the parameter. What happens at each point in the execution?</li>
<li>What does it mean for an <code>equals()</code> implementation to be <b>correct</b>? How do you know? Be as concrete as you can.</li>
<li>Is the given implementation of <code>equals()</code> in class <code>User</code> correct? Again, be concrete. If there is a problem, find a specific object (test case!) that demonstrates the problem.</li>
<li>How does inheritance complicate the correctness discussion for <code>equals()</code> in class <code>SpecialUser</code>?</li>
<li>What is your assessment of the <code>equals()</code> method in the <code>SpecialUser</code> class?</li>
</ol>
</div>
</div>


<div id="outline-container-org4b555ea" class="outline-3">
<h3 id="org4b555ea">In class 1A</h3>
<div class="outline-text-3" id="text-org4b555ea">
<p>
Consider the following specification and implementation:
</p>

<div class="org-src-container">
<pre class="src src-java">
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900; font-style: italic;">List</span>&lt;<span style="color: #b58900; font-style: italic;">Integer</span>&gt; <span style="color: #b58900;">tail</span> (<span style="color: #b58900; font-style: italic;">List</span>&lt;<span style="color: #b58900; font-style: italic;">Integer</span>&gt; <span style="color: #268bd2;">list</span>) {

    <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">REQUIRES: ???</span>
    <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">EFFECTS:  ???</span>

    <span style="color: #b58900; font-style: italic;">List</span>&lt;<span style="color: #b58900; font-style: italic;">Integer</span>&gt; <span style="color: #268bd2;">result</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">ArrayList</span>&lt;<span style="color: #b58900; font-style: italic;">Integer</span>&gt;(list);
    result.remove(0);
    <span style="color: #859900; font-weight: bold;">return</span> result;
}
</pre>
</div>

<ol class="org-ol">
<li>What does the <b>implementation</b> of <code>tail</code> do in each of the following cases? How do you know: Running the code or reading an API description?
<ul class="org-ul">
<li><code>list = null</code></li>
<li><code>list = []</code></li>
<li><code>list = [1]</code></li>
<li><code>list = [1, 2, 3]</code></li>
</ul></li>
<li>Write a partial specification that matches the "happy path" part of the implementation's behavior.</li>
<li>Rewrite the specification to be total. Use Bloch's standard exceptions.</li>
<li>The resulting specification has a problem. What is it?</li>
<li>Rewrite the specification to address this problem. Rewrite the code to match the new specification.</li>
</ol>
</div>
</div>


<div id="outline-container-org83b4357" class="outline-3">
<h3 id="org83b4357">In class 1B</h3>
<div class="outline-text-3" id="text-org83b4357">
<p>
<b>Goal</b>: Understanding Contracts 
</p>

<p>
Consider the Java <a href="https://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html">Iterator</a> interface.
</p>
<ul class="org-ul">
<li>For each method, identify all preconditions and postconditions.</li>
<li>For each precondition, identify a specific input that violates the precondition.</li>
<li>For each postcondition, identify an input specific to that postcondition.</li>
</ul>
</div>
</div>


<div id="outline-container-org744843d" class="outline-3">
<h3 id="org744843d">In class 2A</h3>
<div class="outline-text-3" id="text-org744843d">
<p>
Consider a simple generic <code>Queue</code> implementation.
</p>
<div class="org-src-container">
<pre class="src src-java">
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">Queue</span> &lt;<span style="color: #b58900; font-style: italic;">E</span>&gt; {

    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900; font-style: italic;">List</span>&lt;<span style="color: #b58900; font-style: italic;">E</span>&gt; <span style="color: #268bd2;">elements</span>;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">size</span>;

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">Queue</span>() {   
        <span style="color: #859900; font-weight: bold;">this</span>.elements = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">ArrayList</span>&lt;<span style="color: #b58900; font-style: italic;">E</span>&gt;();
        <span style="color: #859900; font-weight: bold;">this</span>.size = 0;
    }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">enQueue</span> (<span style="color: #b58900; font-style: italic;">E</span> <span style="color: #268bd2;">e</span>) {
        elements.add(e);
        size++;
    }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">E</span> <span style="color: #b58900;">deQueue</span> () {
        <span style="color: #859900; font-weight: bold;">if</span> (size == 0) <span style="color: #859900; font-weight: bold;">throw</span> <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">IllegalStateException</span>(<span style="color: #2aa198;">"Queue.deQueue"</span>);
        <span style="color: #b58900; font-style: italic;">E</span> <span style="color: #268bd2;">result</span> = elements.get(0);
        elements.remove(0);
        size--;
        <span style="color: #859900; font-weight: bold;">return</span> result;
    }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">boolean</span> <span style="color: #b58900;">isEmpty</span>() {
        <span style="color: #859900; font-weight: bold;">return</span> size == 0;
    }
}

</pre>
</div>

<ol class="org-ol">
<li>Rewrite <code>Queue</code> to be <b>immutable</b>. Keep the representation variables <code>elements</code> and <code>size</code>.</li>
<li>Do the right thing with <code>enQueue()</code>.</li>
<li>Do the right thing with <code>deQueue()</code>.</li>
</ol>
</div>
</div>




<div id="outline-container-org630c076" class="outline-3">
<h3 id="org630c076">In class 2B</h3>
<div class="outline-text-3" id="text-org630c076">
<p>
Consider Liskov's Poly example, where an abstract Poly is defined as \(c_0 + c_1x + c_2x^2 + \dots\), and is implemented with two variables:
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">deg</span>;
<span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900; font-style: italic;">int</span>[] <span style="color: #268bd2;">trms</span>;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-text">Fill in example values that are mapped by the abstraction function.
Abstract Poly State:


What is a "state"?
A "state" is an assigment of values to variables


AF
/|\
|         5 + 3x^2
|
|
|----------------------------------------------------------
|
|
|
|        (-10, null)

(2, [5,0,3,0])  Liskov says "no"

(2, [5,0,3])  Liskov says "yes"


The "rep-invariant" describes which rep states are "yes"
1) trms != null
2) deg &gt;= 0
3) deg = trms.length - 1
4) and more - see Liskov

The rep-invariant defines the domain of the abstraction function



Representation State: (deg, trms)
</pre>
</div>

<ol class="org-ol">
<li>Identify representation states that should not be mapped.</li>
<li>Try to capture these states with a rule (that is, a rep-invariant).</li>
<li>Devise a representation that is suitable for a mutable version of Poly.</li>
<li>Develop a rep-invariant for that representation.</li>
</ol>
</div>
</div>

<div id="outline-container-org6a51d65" class="outline-3">
<h3 id="org6a51d65">In class 3A</h3>
<div class="outline-text-3" id="text-org6a51d65">
<p>
Consider Liskov's immutable <code>Poly</code> example, where an abstract <code>Poly</code> is defined as \(c_0 + c_1x + c_2x^2 + \dots\), and is implemented with one variable:
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900; font-style: italic;">Map</span>&lt;<span style="color: #b58900; font-style: italic;">Integer</span>, <span style="color: #b58900; font-style: italic;">Integer</span>&gt; <span style="color: #268bd2;">map</span>;
</pre>
</div>


<p>
Fill in example values that are mapped by the abstraction function.
</p>

<div class="org-src-container">
<pre class="src src-text">
Abstract State: Poly

AF
/|\
|
|
|
|----------------------------------------------------------
|
|
|
|



Representation State: map

</pre>
</div>

<ol class="org-ol">
<li>Identify representation states that should not be mapped.</li>
<li>Try to capture these states with a rule (that is, a rep-invariant).</li>
<li>Consider implementing the <code>degree()</code> method. What code would do the job? What more specific type of map would make the implementation simpler?</li>
</ol>
</div>
</div>

<div id="outline-container-org4b24303" class="outline-3">
<h3 id="org4b24303">In class 3B</h3>
<div class="outline-text-3" id="text-org4b24303">
<p>
Consider the code:
</p>

<div class="org-src-container">
<pre class="src src-java">
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">Members</span> {
    <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Members is a mutable record of organization membership</span>
    <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">AF: Collect the list as a set</span>
    <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">rep-inv1: members != null</span>
    <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">rep-inv2: members != null &amp;&amp; no duplicates in members</span>
    <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">for simplicity, assume null can be a member...</span>

    <span style="color: #b58900; font-style: italic;">List</span>&lt;<span style="color: #b58900; font-style: italic;">Person</span>&gt; <span style="color: #268bd2;">members</span>;   <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">the representation</span>

    <span style="color: #96A7A9; font-style: italic;">//  </span><span style="color: #96A7A9; font-style: italic;">Post: person becomes a member</span>
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">join</span> (<span style="color: #b58900; font-style: italic;">Person</span> <span style="color: #268bd2;">person</span>) { members.add   (person);}

    <span style="color: #96A7A9; font-style: italic;">//  </span><span style="color: #96A7A9; font-style: italic;">Post: person is no longer a member</span>
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">leave</span>(<span style="color: #b58900; font-style: italic;">Person</span> <span style="color: #268bd2;">person</span>) { members.remove(person);}

</pre>
</div>


<ol class="org-ol">
<li>Analyze these 4 questions for rep-inv 1.
<ol class="org-ol">
<li>Does <code>join()</code> maintain rep-inv?</li>
<li>Does <code>join()</code> satisfy contract?</li>
<li>Does <code>leave()</code> maintain rep-inv?</li>
<li>Does <code>leave()</code> satisfy contract?</li>
</ol></li>
<li>Repeat for rep-inv 2.</li>
<li>Recode <code>join()</code> to make the verification go through. Which rep-invariant do you use?</li>
<li>Recode <code>leave()</code> to make the verification go through. Which rep-invariant do you use?</li>
</ol>
</div>
</div>


<div id="outline-container-org631ae73" class="outline-3">
<h3 id="org631ae73">In class 4A</h3>
<div class="outline-text-3" id="text-org631ae73">
<p>
Consider the Java <code>Iterator&lt;E&gt;</code> interface:
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">boolean</span> <span style="color: #b58900;">hasNext</span>();
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">E</span> <span style="color: #b58900;">next</span>() <span style="color: #859900; font-weight: bold;">throws</span> <span style="color: #b58900; font-style: italic;">NoSuchElementException</span>
                       <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">void</span> remove() <span style="color: #859900; font-weight: bold;">throws</span> <span style="color: #b58900; font-style: italic;">IllegalStateException</span>
</pre>
</div>

<ol class="org-ol">
<li>What is the abstract state of an iterator without the <code>remove()</code> method?</li>
<li>Work through an example iterating over a list of strings: <code>["bat", "cat", "dog"]</code></li>
<li>What is the abstract state of an iterator with a <code>previous()</code> method?</li>
<li>What is the abstract state of an iterator with the <code>remove()</code> method?</li>
<li>Design an immutable version of the iterator.
<ol class="org-ol">
<li>How is <code>hasNext()</code> handled?</li>
<li>How is <code>next()</code> handled?</li>
<li>How is <code>remove()</code> handled?</li>
</ol></li>
<li>Exercise the immutable iterator with some sample client code.</li>
</ol>
</div>
</div>

<div id="outline-container-orga325563" class="outline-3">
<h3 id="orga325563">In class 4B</h3>
<div class="outline-text-3" id="text-orga325563">
<p>
Consider the example in Bloch's Item 50 (3rd Edition):
</p>

<div class="org-src-container">
<pre class="src src-java">
<span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Broken &#8220;immutable&#8221; time period class</span>
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">Period</span> {               <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Question 3</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900; font-style: italic;">Date</span> <span style="color: #268bd2;">start</span>;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900; font-style: italic;">Date</span> <span style="color: #268bd2;">end</span>;

    <span style="color: #35a69c; font-style: italic;">/**</span>
<span style="color: #35a69c; font-style: italic;">     * </span><span style="color: #6c71c4; font-weight: bold; font-style: italic;">@param</span><span style="color: #35a69c; font-style: italic;"> start the beginning of the period</span>
<span style="color: #35a69c; font-style: italic;">     * </span><span style="color: #6c71c4; font-weight: bold; font-style: italic;">@param</span><span style="color: #35a69c; font-style: italic;"> end the end of the period; must not precede start</span>
<span style="color: #35a69c; font-style: italic;">     * </span><span style="color: #6c71c4; font-weight: bold; font-style: italic;">@throws</span><span style="color: #35a69c; font-style: italic;"> IAE if start is after end</span>
<span style="color: #35a69c; font-style: italic;">     * </span><span style="color: #6c71c4; font-weight: bold; font-style: italic;">@throws</span><span style="color: #35a69c; font-style: italic;"> NPE if start or end null</span>
<span style="color: #35a69c; font-style: italic;">     */</span>

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">Period</span> (<span style="color: #b58900; font-style: italic;">Date</span> <span style="color: #268bd2;">start</span>, <span style="color: #b58900; font-style: italic;">Date</span> <span style="color: #268bd2;">end</span>) {
        <span style="color: #859900; font-weight: bold;">if</span> (start.compareTo(end) &gt; 0) <span style="color: #859900; font-weight: bold;">throw</span> <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">IAE</span>();
        <span style="color: #859900; font-weight: bold;">this</span>.start = start; <span style="color: #859900; font-weight: bold;">this</span>.end = end;  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Question 1</span>
    }
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">Date</span> <span style="color: #b58900;">start</span>() { <span style="color: #859900; font-weight: bold;">return</span> start;}    <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Question 2</span>
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">Date</span> <span style="color: #b58900;">end</span>()   { <span style="color: #859900; font-weight: bold;">return</span> end;}      <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Question 2</span>
}
</pre>
</div>


<ol class="org-ol">
<li>Write code that shows the problem the line marked // Question 1.</li>
<li>Write code that shows the problem the lines marked // Question 2.</li>
<li><p>
Suppose that the class declaration were:
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">Period</span> { <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Question 3</span>
</pre>
</div>
<p>
Write code that shows the problem.
</p></li>
<li><p>
Bloch fixes the constructor as follows:
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">Period</span> (<span style="color: #b58900; font-style: italic;">Date</span> <span style="color: #268bd2;">start</span>, <span style="color: #b58900; font-style: italic;">Date</span> <span style="color: #268bd2;">end</span>) {
    <span style="color: #859900; font-weight: bold;">this</span>.start = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">Date</span>(start.getTime());  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Defensive copy</span>
    <span style="color: #859900; font-weight: bold;">this</span>.end   = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">Date</span>(end.getTime());    <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Defensive copy</span>

    <span style="color: #859900; font-weight: bold;">if</span> (<span style="color: #859900; font-weight: bold;">this</span>.start.compareTo(end) &gt; 0) <span style="color: #859900; font-weight: bold;">throw</span> <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">IAE</span>();
</pre>
</div>
<ol class="org-ol">
<li>Bloch states that <code>clone()</code> would be inappropriate for copying the dates. Write code that shows the problem.</li>
<li>Bloch defers the exception check until the end, which seems to violate normal practice. What's the problem with checking early?</li>
</ol></li>
</ol>
</div>
</div>


<div id="outline-container-orgc1ca432" class="outline-3">
<h3 id="orgc1ca432">In class 5A</h3>
<div class="outline-text-3" id="text-orgc1ca432">
<p>
<b>Goal</b>: Understanding dynamic dispatching
</p>

<p>
Consider Liskov's <code>MaxIntSet</code> example with explict <code>repOk()</code> calls: (Really, we'd need assertions on these calls&#x2026;)
</p>

<div class="org-src-container">
<pre class="src src-java">
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">IntSet</span> {
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">insert</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">x</span>) {...; repOk();}
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">remove</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">x</span>) {...; repOk();}
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">boolean</span> <span style="color: #b58900;">repOk</span>() {...}
}
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">MaxIntSet</span> <span style="color: #859900; font-weight: bold;">extends</span> <span style="color: #b58900; font-style: italic;">IntSet</span> {
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">insert</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">x</span>) {...; <span style="color: #859900; font-weight: bold;">super</span>.insert(x); repOk();}
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">remove</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">x</span>) {<span style="color: #859900; font-weight: bold;">super</span>.remove(x); ...; repOk();}
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">boolean</span> <span style="color: #b58900;">repOk</span>() {<span style="color: #859900; font-weight: bold;">super</span>.repOk(); ...;}
}

<span style="color: #b58900; font-style: italic;">MaxIntSet</span> <span style="color: #268bd2;">s</span> = {3, 5}; s.remove(5);  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">repOk()????</span>
</pre>
</div>

<ol class="org-ol">
<li>What does the default constructor in <code>MaxIntSet</code> do?</li>
<li>What do the <code>"..."</code> bits do?</li>
<li>How does the call work out?</li>
<li>What is the abstract state of a <code>MaxIntSet</code>? There are two options. What are they, and what are the consequences of each choice?</li>
</ol>
</div>
</div>

<div id="outline-container-org10e755d" class="outline-3">
<h3 id="org10e755d">In class 5B</h3>
<div class="outline-text-3" id="text-org10e755d">
<p>
Consider the following:
</p>

<div class="org-src-container">
<pre class="src src-java">
<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">A</span>:
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">void</span> reduce (<span style="color: #b58900; font-style: italic;">Reducer</span> <span style="color: #268bd2;">x</span>)    
        <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Effects: if x is null throw NPE </span>
        <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">else if x is not appropriate for this throw IAE</span>
        <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">else reduce this by x</span>

        <span style="color: #859900; font-weight: bold;">class</span> B:
        <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">void</span> reduce (<span style="color: #b58900; font-style: italic;">Reducer</span> <span style="color: #268bd2;">x</span>) 
        <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Requires: x is not null</span>
        <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Effects: if x is not appropriate for this throw IAE</span>
        <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">else reduce this by x</span>

        <span style="color: #859900; font-weight: bold;">class</span> C:
        <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">void</span> reduce (<span style="color: #b58900; font-style: italic;">Reducer</span> <span style="color: #268bd2;">x</span>)   
        <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Effects: if x is null return (normally) with no change to this</span>
        <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">else if x is not appropriate for this throw IAE</span>
        <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">else reduce this by x</span>
</pre>
</div>

<p>
Analyze the "methods rule" for <code>reduce()</code> in each of these cases: Note: Some analysis may not be necessary. If so, indicate that.
</p>

<div class="org-src-container">
<pre class="src src-text">
B extends A.
Precondition Part:
Postcondition Part:
-----------------------------------          
C extends A.
Precondition Part:
Postcondition Part:
-----------------------------------          
A extends B.
Precondition Part:
Postcondition Part:
-----------------------------------          
C extends B.
Precondition Part:
Postcondition Part:
-----------------------------------                    
A extends C.
Precondition Part:
Postcondition Part: 
-----------------------------------          
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb8d6414" class="outline-3">
<h3 id="orgb8d6414">In class 5C</h3>
<div class="outline-text-3" id="text-orgb8d6414">
<p>
Consider the following:
</p>
<div class="org-src-container">
<pre class="src src-java">
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">Counter</span>{   <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Liskov 7.8</span>
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">Counter</span>()     <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">EFF: Makes this contain 0</span>
        <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">int</span> get()     <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">EFF: Returns the value of this</span>
        <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">void</span> incr()   <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">MOD: this //EFF: makes this larger</span>
        }
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">Counter2</span> <span style="color: #859900; font-weight: bold;">extends</span> <span style="color: #b58900; font-style: italic;">Counter</span> { <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Liskov 7.9</span>
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">Counter2</span>()         <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">EFF: Makes this contain 0</span>
        <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">void</span> incr()       <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">MOD: this //EFF: double this</span>
        }
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">Counter3</span> <span style="color: #859900; font-weight: bold;">extends</span> <span style="color: #b58900; font-style: italic;">Counter</span> {  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Liskov 7.10</span>
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">Counter3</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">n</span>)   <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">EFF: Makes this contain n</span>
        <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">void</span> incr(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">n</span>)  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">MOD: this //EFF: if n&gt;0 add n to this</span>
        }
</pre>
</div>

<ol class="org-ol">
<li>What role do constructors play in analyzing the Liskov Substitition Principle?</li>
<li>Is there a constraint about negative/zero values for this? How do we know?</li>
<li>What methods are in the <code>Counter2</code> API?</li>
<li>Is <code>Counter2</code> a valid subtype of Counter?</li>
<li>What methods are in the <code>Counter3</code> API?</li>
<li>Is <code>Counter3</code> a valid subtype of <code>Counter</code>? In particular, does <code>incr(int n)</code> have to be consistent with <code>incr()</code>?</li>
</ol>
</div>
</div>


<div id="outline-container-orgc38f5db" class="outline-3">
<h3 id="orgc38f5db">In class 6</h3>
<div class="outline-text-3" id="text-orgc38f5db">
<p>
This is a recap exercise.
</p>

<div class="org-src-container">
<pre class="src src-java">
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">BoundedQueue</span> {
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900; font-style: italic;">Object</span> <span style="color: #268bd2;">rep</span>[];
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">front</span> = 0;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">back</span> = -1;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">size</span> = 0;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">count</span> = 0;

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">BoundedQueue</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">size</span>) {
        <span style="color: #859900; font-weight: bold;">if</span> (size &gt; 0) {
            <span style="color: #859900; font-weight: bold;">this</span>.size = size;
            rep = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">Object</span>[size];
            back = size - 1;
        }  }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">boolean</span> <span style="color: #b58900;">isEmpty</span>() { <span style="color: #859900; font-weight: bold;">return</span> (count == 0); }
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">boolean</span> <span style="color: #b58900;">isFull</span>() { <span style="color: #859900; font-weight: bold;">return</span> (count == size); }
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">getCount</span>() { <span style="color: #859900; font-weight: bold;">return</span> count; }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">put</span>(<span style="color: #b58900; font-style: italic;">Object</span> <span style="color: #268bd2;">e</span>) {
        <span style="color: #859900; font-weight: bold;">if</span> (e != <span style="color: #6c71c4; font-weight: bold;">null</span> &amp;&amp; <span style="color: #268bd2; font-weight: bold;">!</span>isFull()) {
            back++;
            <span style="color: #859900; font-weight: bold;">if</span> (back &gt;= size)
                back = 0;
            rep[back] = e;
            count++;
        } }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">Object</span> <span style="color: #b58900;">get</span>() {
        <span style="color: #b58900; font-style: italic;">Object</span> <span style="color: #268bd2;">result</span> = <span style="color: #6c71c4; font-weight: bold;">null</span>;
        <span style="color: #859900; font-weight: bold;">if</span> (<span style="color: #268bd2; font-weight: bold;">!</span>isEmpty()) {
            result = rep[front];
            rep[front] = <span style="color: #6c71c4; font-weight: bold;">null</span>;
            front++;
            <span style="color: #859900; font-weight: bold;">if</span> (front &gt;= size)
                front = 0;
            count--;
        }
        <span style="color: #859900; font-weight: bold;">return</span> result;
    }
    <span style="color: #6c71c4; font-weight: bold;">@Override</span> <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">String</span> <span style="color: #b58900;">toString</span>() {
        <span style="color: #b58900; font-style: italic;">String</span> <span style="color: #268bd2;">result</span> = <span style="color: #2aa198;">"front = "</span> + front;
        result += <span style="color: #2aa198;">"; back = "</span> + back;
        result += <span style="color: #2aa198;">"; size = "</span> + size;
        result += <span style="color: #2aa198;">"; count = "</span> + count;
        result += <span style="color: #2aa198;">"; rep = ["</span>;
        <span style="color: #859900; font-weight: bold;">for</span> (<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">i</span> = 0; i &lt; rep.<span style="color: #b58900; font-style: italic;">length</span>; i++) {
            <span style="color: #859900; font-weight: bold;">if</span> (i &lt; rep.<span style="color: #b58900; font-style: italic;">length</span>-1)
                result = result + rep[i] + <span style="color: #2aa198;">", "</span>;
            <span style="color: #859900; font-weight: bold;">else</span>
                result = result + rep[i];
        }
        <span style="color: #859900; font-weight: bold;">return</span> result + <span style="color: #2aa198;">"]"</span>;
    }
}

</pre>
</div>


<ol class="org-ol">
<li>How would Liskov describe a typical bounded queue?</li>
<li>What is wrong with <code>toString()</code>? What needs to be done to fix it? Make it so.</li>
<li>Write some sample client code to exercise the data structure. Include some non-happy-path cases. Would Bloch likely change the behavior? If so, how?</li>
<li>Write contracts for each method (as written), including the constructor.</li>
<li>Build a rep-invariant. Focus on the code in <code>get()</code>. There are also lots of constraints on the array indices; these are quite tricky to get right. The constructor also introduces some complexity.</li>
<li><p>
Suppose we removed the line
</p>
<div class="org-src-container">
<pre class="src src-java">rep[front] = <span style="color: #6c71c4; font-weight: bold;">null</span>;       
</pre>
</div>
<p>
from <code>get()</code>.
</p>
<ol class="org-ol">
<li>Informally, why is this wrong?</li>
<li>Formally, where does the correctness proof break down?</li>
<li>Could a client ever see the problem?</li>
</ol></li>
<li>Now that we've done some AF/RI analysis, what changes make the implementation better? btw - this is code straight out of a textbook.</li>
<li>Could this data structure be made immutable? If so, what would change in the contracts and method headers? What would likely change in the implementation?</li>
</ol>
</div>
</div>



<div id="outline-container-org4d049ef" class="outline-3">
<h3 id="org4d049ef">In class 8A</h3>
<div class="outline-text-3" id="text-org4d049ef">
<p>
Given the following variable declarations, independently consider the given 6 sequences of Java instructions.
</p>
<div class="org-src-container">
<pre class="src src-java">
<span style="color: #b58900; font-style: italic;">String</span>           <span style="color: #268bd2;">string</span> = <span style="color: #2aa198;">"bat"</span>;
<span style="color: #b58900; font-style: italic;">Integer</span>          <span style="color: #268bd2;">x</span> = 7;
<span style="color: #b58900; font-style: italic;">Object</span>[]         <span style="color: #268bd2;">objects</span>;
<span style="color: #b58900; font-style: italic;">List</span>             <span style="color: #268bd2;">rawList</span>;
<span style="color: #b58900; font-style: italic;">List</span> &lt; <span style="color: #b58900; font-style: italic;">Object</span> &gt;  <span style="color: #268bd2;">objectList</span>;
<span style="color: #b58900; font-style: italic;">List</span> &lt; <span style="color: #b58900; font-style: italic;">String</span> &gt;  <span style="color: #268bd2;">stringList</span>;

</pre>
</div>

<p>
Identify any code that results in a compiler error or warning.
Identify any code that raises a runtime exception.
Once a compiler error is noted, you do not need to analyze the sequence further.
</p>

<ol class="org-ol">
<li><div class="org-src-container">
<pre class="src src-java">objects = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">String</span>[1]; 
objects[0] = string;     
objects[0] = x;        
</pre>
</div></li>

<li><div class="org-src-container">
<pre class="src src-java">objects = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">Object</span>[1];
objects[0] = string;   
objects[0] = x;     
</pre>
</div></li>

<li><div class="org-src-container">
<pre class="src src-java">stringList = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">ArrayList</span> &lt; <span style="color: #b58900; font-style: italic;">String</span> &gt;();
stringList.add(string) ;
</pre>
</div></li>

<li><div class="org-src-container">
<pre class="src src-java">objectList = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">ArrayList</span> &lt; <span style="color: #b58900; font-style: italic;">String</span> &gt;();
objectList.add(string) ;
</pre>
</div></li>

<li><div class="org-src-container">
<pre class="src src-java">objectList = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">ArrayList</span> &lt; <span style="color: #b58900; font-style: italic;">Object</span> &gt;(); 
objectList.add(string) ;      
objectList.add(x) ;        
</pre>
</div></li>

<li><div class="org-src-container">
<pre class="src src-java">rawList = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">ArrayList</span>();
rawList.add(string) ;    
rawList.add(x) ;       
</pre>
</div></li>
</ol>
</div>
</div>



<div id="outline-container-orgf05ff2f" class="outline-3">
<h3 id="orgf05ff2f">In class 8B</h3>
<div class="outline-text-3" id="text-orgf05ff2f">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Chooser - a class badly in need of generics!</span>
<span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Bloch 3rd edition, Chapter 5, Item 28:  Prefer lists to arrays</span>

<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">Chooser</span> {
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900; font-style: italic;">Object</span>[] <span style="color: #268bd2;">choiceArray</span>;

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">Chooser</span> (<span style="color: #b58900; font-style: italic;">Collection</span> <span style="color: #268bd2;">choices</span>) {
        choiceArray = choices.toArray();
    }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">Object</span> <span style="color: #b58900;">choose</span>() { 
        <span style="color: #b58900; font-style: italic;">Random</span> <span style="color: #268bd2;">rnd</span> = ThreadLocalRandom.current();
        <span style="color: #859900; font-weight: bold;">return</span> choiceArray [rnd.nextInt(choiceArray.length)];
    }
}
</pre>
</div>



<ul class="org-ul">
<li>First, simply generify by adding a type to the Chooser class. What is the compiler error with this approach?</li>
<li>How can you turn the compiler error into a compiler warning?</li>
<li>Can this warning be suppressed? Should it?</li>
<li>How can you adopt Bloch's advice about arrays and lists to get a typesafe Chooser class without doing anything else that is complicated?</li>
<li>What would Liskov have to say about this class? How should it evolve to address her concerns? What is the appropriate place to deal with the problem? Does an invariant help? Is that a rep-invariant, or some other kind of invariant?</li>
</ul>
</div>
</div>


<div id="outline-container-orgf8a52d1" class="outline-3">
<h3 id="orgf8a52d1">In class 8C</h3>
<div class="outline-text-3" id="text-orgf8a52d1">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">BoundedQueue</span> {

    <span style="color: #859900; font-weight: bold;">protected</span> <span style="color: #b58900; font-style: italic;">Object</span> <span style="color: #268bd2;">rep</span>[];
    <span style="color: #859900; font-weight: bold;">protected</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">front</span> = 0;
    <span style="color: #859900; font-weight: bold;">protected</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">back</span> = -1;
    <span style="color: #859900; font-weight: bold;">protected</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">size</span> = 0;
    <span style="color: #859900; font-weight: bold;">protected</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">count</span> = 0;

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">BoundedQueue</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">size</span>) {
        <span style="color: #859900; font-weight: bold;">if</span> (size &gt; 0) {
            <span style="color: #859900; font-weight: bold;">this</span>.size = size;
            rep = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">Object</span>[size];
            back = size - 1;
        }  }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">boolean</span> <span style="color: #b58900;">isEmpty</span>() { <span style="color: #859900; font-weight: bold;">return</span> (count == 0); }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">boolean</span> <span style="color: #b58900;">isFull</span>() { <span style="color: #859900; font-weight: bold;">return</span> (count == size); }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">getCount</span>() { <span style="color: #859900; font-weight: bold;">return</span> count; }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">put</span>(<span style="color: #b58900; font-style: italic;">Object</span> <span style="color: #268bd2;">e</span>) {
        <span style="color: #859900; font-weight: bold;">if</span> (e != <span style="color: #6c71c4; font-weight: bold;">null</span> &amp;&amp; <span style="color: #268bd2; font-weight: bold;">!</span>isFull()) {
            back++;
            <span style="color: #859900; font-weight: bold;">if</span> (back &gt;= size)
                back = 0;
            rep[back] = e;
            count++;
        }  }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">Object</span> <span style="color: #b58900;">get</span>() {
        <span style="color: #b58900; font-style: italic;">Object</span> <span style="color: #268bd2;">result</span> = <span style="color: #6c71c4; font-weight: bold;">null</span>;
        <span style="color: #859900; font-weight: bold;">if</span> (<span style="color: #268bd2; font-weight: bold;">!</span>isEmpty()) {
            result = rep[front];
            rep[front] = <span style="color: #6c71c4; font-weight: bold;">null</span>;
            front++;
            <span style="color: #859900; font-weight: bold;">if</span> (front &gt;= size)
                front = 0;
            count--;
        }
        <span style="color: #859900; font-weight: bold;">return</span> result;
    }
}

</pre>
</div>


<p>
Generify!
</p>
<ul class="org-ul">
<li>Can you add a putAll() method? A getAll() method?</li>
<li>Recall that we used this same example in in-class 6 as a vehicle for applying Liskov's ideas to make code easier to understand.</li>
</ul>
</div>
</div>

<div id="outline-container-org1347a48" class="outline-3">
<h3 id="org1347a48">In class 9A</h3>
<div class="outline-text-3" id="text-org1347a48">
<p>
Consider Bloch's <code>Point/ColorPoint</code> example. For today, ignore the <code>hashCode()</code> issue.
</p>

<div class="org-src-container">
<pre class="src src-java">
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">Point</span> {  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">routine code</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">x</span>; <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">y</span>;    
    ...
        <span style="color: #6c71c4; font-weight: bold;">@Override</span> <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">boolean</span> equals(<span style="color: #b58900; font-style: italic;">Object</span> <span style="color: #268bd2;">obj</span>) {  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Standard recipe</span>
        <span style="color: #859900; font-weight: bold;">if</span> (<span style="color: #268bd2; font-weight: bold;">!</span>(obj <span style="color: #859900; font-weight: bold;">instanceof</span> Point)) <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #6c71c4; font-weight: bold;">false</span>;

        <span style="color: #b58900; font-style: italic;">Point</span> <span style="color: #268bd2;">p</span> = (<span style="color: #b58900; font-style: italic;">Point</span>) obj;
        <span style="color: #859900; font-weight: bold;">return</span> p.x == x &amp;&amp; p.y == y;
    }
}

<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">ColorPoint</span> <span style="color: #859900; font-weight: bold;">extends</span> <span style="color: #b58900; font-style: italic;">Point</span> {  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">First attempt: Standard recipe</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900; font-style: italic;">COLOR</span> <span style="color: #268bd2;">color</span>;
    ...
        <span style="color: #6c71c4; font-weight: bold;">@Override</span> <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">boolean</span> equals(<span style="color: #b58900; font-style: italic;">Object</span> <span style="color: #268bd2;">obj</span>) {
        <span style="color: #859900; font-weight: bold;">if</span> (<span style="color: #268bd2; font-weight: bold;">!</span>(obj <span style="color: #859900; font-weight: bold;">instanceof</span> ColorPoint)) <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #6c71c4; font-weight: bold;">false</span>;

        <span style="color: #b58900; font-style: italic;">ColorPoint</span> <span style="color: #268bd2;">cp</span> = (<span style="color: #b58900; font-style: italic;">ColorPoint</span>) obj;
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">super</span>.equals(obj) &amp;&amp; cp.color == color;
    }
}

<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">ColorPoint</span> <span style="color: #859900; font-weight: bold;">extends</span> <span style="color: #b58900; font-style: italic;">Point</span> {  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Second attempt: DON'T DO THIS!</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900; font-style: italic;">COLOR</span> <span style="color: #268bd2;">color</span>;
    ...
        <span style="color: #6c71c4; font-weight: bold;">@Override</span> <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">boolean</span> equals(<span style="color: #b58900; font-style: italic;">Object</span> <span style="color: #268bd2;">obj</span>) {
        <span style="color: #859900; font-weight: bold;">if</span> (<span style="color: #268bd2; font-weight: bold;">!</span>(o instance <span style="color: #b58900; font-style: italic;">of</span> <span style="color: #268bd2;">Point</span>)) <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #6c71c4; font-weight: bold;">false</span>;

        <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">If obj is a normal Point, be colorblind</span>
        <span style="color: #859900; font-weight: bold;">if</span> (<span style="color: #268bd2; font-weight: bold;">!</span>(obj <span style="color: #859900; font-weight: bold;">instanceof</span> ColorPoint)) <span style="color: #859900; font-weight: bold;">return</span> obj.equals(<span style="color: #859900; font-weight: bold;">this</span>);

        <span style="color: #b58900; font-style: italic;">ColorPoint</span> <span style="color: #268bd2;">cp</span> = (<span style="color: #b58900; font-style: italic;">ColorPoint</span>) obj;
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">super</span>.equals(obj) &amp;&amp; cp.color == color;
    }
}
</pre>
</div>

<ol class="org-ol">
<li>What is the <code>equals()</code> contract? What is the standard recipe?</li>
<li>Why does Bloch use the <code>instanceof</code> operator in the standard recipe?</li>
<li>Write client code that shows a contract problem with the first attempt at <code>ColorPoint</code>.</li>
<li>Write client code that shows a contract problem with the second attempt at <code>ColorPoint</code>.</li>
<li>Some authors recommend solving this problem by using a different standard recipe for <code>equals()</code>.
<ul class="org-ul">
<li>What's the key difference?</li>
<li><p>
Which approach do you want in the following code:
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">CounterPoint</span> <span style="color: #859900; font-weight: bold;">extends</span> <span style="color: #b58900; font-style: italic;">Point</span>
                                  <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">final</span> AtomicInteger counter =
                                  <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">AtomicInteger</span>();

<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">CounterPoint</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">x</span>, <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">y</span>) {
    <span style="color: #859900; font-weight: bold;">super</span> (x, y);
    counter.incrementAndGet();
}
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">numberCreated</span>() { <span style="color: #859900; font-weight: bold;">return</span> counter.get(); }

<span style="color: #6c71c4; font-weight: bold;">@Override</span> <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">boolean</span> <span style="color: #b58900;">equals</span> (<span style="color: #b58900; font-style: italic;">Object</span> <span style="color: #268bd2;">obj</span>) { ??? }
}


<span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Client code:</span>

<span style="color: #b58900; font-style: italic;">Point</span> <span style="color: #268bd2;">p</span> = PointFactory.getPoint();   <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">either a Point or a CounterPoint</span>
<span style="color: #b58900; font-style: italic;">Set</span>&lt;<span style="color: #b58900; font-style: italic;">Point</span>&gt; <span style="color: #268bd2;">importantPoints</span> =   <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">a set of important points</span>
    <span style="color: #b58900; font-style: italic;">boolean</span> b = PointUtilities.isImportant(p);  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">value?</span>

</pre>
</div></li>
</ul></li>
</ol>
</div>
</div>


<div id="outline-container-orgb4fa7f4" class="outline-3">
<h3 id="orgb4fa7f4">In class 9B</h3>
<div class="outline-text-3" id="text-orgb4fa7f4">
<p>
Consider a variation of Liskov's <code>IntSet</code> example (Figure 5.10, page 97)
</p>

<div class="org-src-container">
<pre class="src src-java">
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">IntSet</span> <span style="color: #859900; font-weight: bold;">implements</span> <span style="color: #b58900; font-style: italic;">Cloneable</span> {  
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900; font-style: italic;">List</span>&lt;<span style="color: #b58900; font-style: italic;">Integer</span>&gt; <span style="color: #268bd2;">els</span>;
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">IntSet</span> () { els = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">ArrayList</span>&lt;<span style="color: #b58900; font-style: italic;">Integer</span>&gt;(); }
    ...
        <span style="color: #6c71c4; font-weight: bold;">@Override</span> 
        <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">boolean</span> equals(<span style="color: #b58900; font-style: italic;">Object</span> <span style="color: #268bd2;">obj</span>) { 
        <span style="color: #859900; font-weight: bold;">if</span> (<span style="color: #268bd2; font-weight: bold;">!</span>(obj <span style="color: #859900; font-weight: bold;">instanceof</span> IntSet)) <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #6c71c4; font-weight: bold;">false</span>;

        <span style="color: #b58900; font-style: italic;">IntSet</span> <span style="color: #268bd2;">s</span> = (<span style="color: #b58900; font-style: italic;">IntSet</span>) obj;
        <span style="color: #859900; font-weight: bold;">return</span> ???
            }

    <span style="color: #6c71c4; font-weight: bold;">@Override</span> 
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">hashCode</span>() { 
        <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">see below </span>
    }

    <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">adding a private constructor</span>
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">IntSet</span> (<span style="color: #b58900; font-style: italic;">List</span>&lt;<span style="color: #b58900; font-style: italic;">Integer</span>&gt; <span style="color: #268bd2;">list</span>) { els = list; }

    <span style="color: #6c71c4; font-weight: bold;">@Override</span> 
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">IntSet</span> <span style="color: #b58900;">clone</span>() { 
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">IntSet</span> ( <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">ArrayList</span>&lt;<span style="color: #b58900; font-style: italic;">Integer</span>&gt;(els));
    }

}
</pre>
</div>

<ol class="org-ol">
<li>How should the <code>equals()</code> method be completed?</li>
<li>Analyze the following ways to implement <code>hashCode()</code>? If there is a problem, give a test case that shows the problem.
<ol class="org-ol">
<li>not overridden at all</li>
<li>return 42;</li>
<li>return <code>els.hashCode()</code>;</li>
<li><code>int sum = 0; for (Integer i : els) sum +</code> i.hashCode(); return sum;=</li>
</ol></li>
<li>What's the problem with <code>clone()</code> here? Give a test case that shows the problem.</li>
<li>Fix <code>clone()</code> in two very different ways.</li>
</ol>
</div>
</div>

<div id="outline-container-org746e041" class="outline-3">
<h3 id="org746e041">In class 10A</h3>
<div class="outline-text-3" id="text-org746e041">
<p>
Consider Bloch's <code>InstrumentedHashSet</code>, <code>InstrumentedSet</code>, and <code>ForwardingSet</code> examples:
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">InstrumentedHashSet</span>&lt;<span style="color: #b58900; font-style: italic;">E</span>&gt; <span style="color: #859900; font-weight: bold;">extends</span> <span style="color: #b58900; font-style: italic;">HashSet</span>&lt;<span style="color: #b58900; font-style: italic;">E</span>&gt;{
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">addCount</span> = 0;   
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">InstrumentedHashSet</span>() {}

    <span style="color: #6c71c4; font-weight: bold;">@Override</span> <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">boolean</span> <span style="color: #b58900;">add</span>(<span style="color: #b58900; font-style: italic;">E</span> <span style="color: #268bd2;">e</span>){ 
        addCount++; 
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">super</span>.add(e); 
    }
    <span style="color: #6c71c4; font-weight: bold;">@Override</span> <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">boolean</span> <span style="color: #b58900;">addAll</span>(<span style="color: #b58900; font-style: italic;">Collection</span>&lt;? <span style="color: #859900; font-weight: bold;">extends</span> <span style="color: #b58900; font-style: italic;">E</span>&gt; <span style="color: #268bd2;">c</span>){ 
        <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">What to do with addCount?</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">super</span>.addAll(c); 
    }
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">getAddCount</span>(){ <span style="color: #859900; font-weight: bold;">return</span> addCount; }
}
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">InstrumentedSet</span>&lt;<span style="color: #b58900; font-style: italic;">E</span>&gt; <span style="color: #859900; font-weight: bold;">extends</span> <span style="color: #b58900; font-style: italic;">ForwardingSet</span>&lt;<span style="color: #b58900; font-style: italic;">E</span>&gt;{
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">addCount</span> = 0;   

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">InstrumentedSet</span>(<span style="color: #b58900; font-style: italic;">Set</span>&lt;<span style="color: #b58900; font-style: italic;">E</span>&gt; <span style="color: #268bd2;">s</span>){ <span style="color: #859900; font-weight: bold;">super</span>(s); }
    <span style="color: #6c71c4; font-weight: bold;">@Override</span> <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">boolean</span> <span style="color: #b58900;">add</span>(<span style="color: #b58900; font-style: italic;">E</span> <span style="color: #268bd2;">e</span>){ addCount++; <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">super</span>.add(e); }
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">getAddCount</span>(){ <span style="color: #859900; font-weight: bold;">return</span> addCount; }
}
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">ForwardingSet</span>&lt;<span style="color: #b58900; font-style: italic;">E</span>&gt; <span style="color: #859900; font-weight: bold;">implements</span> <span style="color: #b58900; font-style: italic;">Set</span>&lt;<span style="color: #b58900; font-style: italic;">E</span>&gt; {
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900; font-style: italic;">Set</span>&lt;<span style="color: #b58900; font-style: italic;">E</span>&gt; <span style="color: #268bd2;">s</span>;

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">ForwardingSet</span>(<span style="color: #b58900; font-style: italic;">Set</span>&lt;<span style="color: #b58900; font-style: italic;">E</span>&gt; <span style="color: #268bd2;">s</span>){ <span style="color: #859900; font-weight: bold;">this</span>.s = s; }
    <span style="color: #859900; font-weight: bold;">public</span>           <span style="color: #b58900; font-style: italic;">boolean</span> <span style="color: #b58900;">add</span>(<span style="color: #b58900; font-style: italic;">E</span> <span style="color: #268bd2;">e</span>)        { <span style="color: #859900; font-weight: bold;">return</span> s.add(e);     }
    <span style="color: #859900; font-weight: bold;">public</span>           <span style="color: #b58900; font-style: italic;">boolean</span> <span style="color: #b58900;">remove</span>(<span style="color: #b58900; font-style: italic;">Object</span> <span style="color: #268bd2;">o</span>){ <span style="color: #859900; font-weight: bold;">return</span> s.remove(o);  }
    <span style="color: #6c71c4; font-weight: bold;">@Override</span> <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">boolean</span> <span style="color: #b58900;">equals</span>(<span style="color: #b58900; font-style: italic;">Object</span> <span style="color: #268bd2;">o</span>){ <span style="color: #859900; font-weight: bold;">return</span> s.equals(o);  }
    <span style="color: #6c71c4; font-weight: bold;">@Override</span> <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">int</span>     <span style="color: #b58900;">hashCode</span>()      { <span style="color: #859900; font-weight: bold;">return</span> s.hashCode(); }
    <span style="color: #6c71c4; font-weight: bold;">@Override</span> <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">String</span>  <span style="color: #b58900;">toString</span>()      { <span style="color: #859900; font-weight: bold;">return</span> s.toString(); }
    <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Other forwarded methods from Set interface omitted</span>
}

Consider also the following <span style="color: #b58900; font-style: italic;">client</span> <span style="color: #268bd2;">code</span>:

<span style="color: #b58900; font-style: italic;">Set</span>&lt;<span style="color: #b58900; font-style: italic;">String</span>&gt; r = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">HashSet</span>&lt;<span style="color: #b58900; font-style: italic;">String</span>&gt;();
r.add(<span style="color: #2aa198;">"ant"</span>); r.add(<span style="color: #2aa198;">"bee"</span>);

<span style="color: #b58900; font-style: italic;">Set</span>&lt;<span style="color: #b58900; font-style: italic;">String</span>&gt; <span style="color: #268bd2;">sh</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">InstrumentedHashSet</span>&lt;<span style="color: #b58900; font-style: italic;">String</span>&gt;();
sh.addAll(r);

<span style="color: #b58900; font-style: italic;">Set</span>&lt;<span style="color: #b58900; font-style: italic;">String</span>&gt; <span style="color: #268bd2;">s</span> =  <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">InstrumentedSet</span>&lt;<span style="color: #b58900; font-style: italic;">String</span>&gt;(r);
s.add(<span style="color: #2aa198;">"ant"</span>); s.add(<span style="color: #2aa198;">"cat"</span>);

<span style="color: #b58900; font-style: italic;">Set</span>&lt;<span style="color: #b58900; font-style: italic;">String</span>&gt; <span style="color: #268bd2;">t</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">InstrumentedSet</span>&lt;<span style="color: #b58900; font-style: italic;">String</span>&gt;(s);
t.add(<span style="color: #2aa198;">"dog"</span>);

r.remove(<span style="color: #2aa198;">"bee"</span>);
s.remove(<span style="color: #2aa198;">"ant"</span>);
</pre>
</div>


<ol class="org-ol">
<li>How do you think the <code>addCount</code> variable should be updated in the <code>addAll()</code> method in <code>InstrumentedHashSet</code>?
<ol class="org-ol">
<li>Why is this a hard question?</li>
<li>What does the answer say about inheritance?</li>
<li>Does <code>equals()</code> behave correctly in <code>InstrumentedHashSet?</code></li>
</ol></li>
<li>Given your previous answer, what is the value of <code>sh.addCount</code> at the end of the computation?</li>
<li>Consider the <code>InstrumentedSet</code> solution. Besides being correct (always a plus!) why is it more general than the <code>InstrumentedHashSet</code> solution?</li>
<li>At the end of the computation, what are the values of: <code>r</code>, <code>s</code>, and <code>t</code>?</li>
<li>What would a call to <code>s.getAddCount()</code> return at the end of the computation?</li>
<li>At the end of the computation, what are the values of: <code>r.equals(s)</code>, <code>s.equals(t)</code>, and <code>t.equals(s)</code>?
<ul class="org-ul">
<li>Are there any problems with the <code>equals()</code> contract?</li>
</ul></li>
<li>Would this still work if you globally replaced sets with lists?</li>
<li>Would this still work if you globally replaced sets with collections?</li>
</ol>

<p>
<b>Note</b>: There is a lot going on in this example. I highly recommend that you play with the code until you understand it.    
</p>
</div>
</div>

<div id="outline-container-org998b626" class="outline-3">
<h3 id="org998b626">In class 10B</h3>
<div class="outline-text-3" id="text-org998b626">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">Super</span> {
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">Super</span>() {
        overrideMe();
    }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">overrideMe</span> () {
    }
}
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">Sub</span> <span style="color: #859900; font-weight: bold;">extends</span> <span style="color: #b58900; font-style: italic;">Super</span> {

    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900; font-style: italic;">Date</span> <span style="color: #268bd2;">date</span>;  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">filled in by constructor</span>

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">Sub</span>() {
        date = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">Date</span>();
    }
    <span style="color: #6c71c4; font-weight: bold;">@Override</span> <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">overrideMe</span> () {
        System.out.println(date);
    }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">main</span> (<span style="color: #b58900; font-style: italic;">String</span>[] <span style="color: #268bd2;">args</span>) {
        <span style="color: #b58900; font-style: italic;">Sub</span> <span style="color: #268bd2;">sub</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">Sub</span>();
        sub.overrideMe();
    }
}
</pre>
</div>

<ol class="org-ol">
<li>What is the pattern, and how common is it?</li>
<li>What does the main method do, and why?</li>
<li>Which of Bloch's rules does this example break?</li>
<li>What does this example mean for <code>Cloneable</code> interface and the <code>clone()</code> method?</li>
<li>What does this example mean for <code>Serializable</code> interface and the <code>readObject()</code> method?</li>
<li>To what extent does this rule generalize to producer methods?</li>
</ol>
</div>
</div>

<div id="outline-container-org11d0a7b" class="outline-3">
<h3 id="org11d0a7b">In class 10C</h3>
<div class="outline-text-3" id="text-org11d0a7b">
<p>
Consider a mutable complex number class:
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">MComplex</span> {
    <span style="color: #b58900; font-style: italic;">double</span> <span style="color: #268bd2;">re</span>; <span style="color: #859900; font-weight: bold;">protected</span> <span style="color: #b58900; font-style: italic;">double</span> <span style="color: #268bd2;">im</span>;

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">MComplex</span> (<span style="color: #b58900; font-style: italic;">double</span> <span style="color: #268bd2;">re</span>, <span style="color: #b58900; font-style: italic;">double</span> <span style="color: #268bd2;">im</span>) { <span style="color: #859900; font-weight: bold;">this</span>.re = re; <span style="color: #859900; font-weight: bold;">this</span>.im = im; }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">double</span> <span style="color: #b58900;">getReal</span>()      { <span style="color: #859900; font-weight: bold;">return</span> re; }
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">double</span> <span style="color: #b58900;">getImaginary</span>() { <span style="color: #859900; font-weight: bold;">return</span> im; }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">setReal</span>(<span style="color: #b58900; font-style: italic;">double</span> <span style="color: #268bd2;">re</span>)      { <span style="color: #859900; font-weight: bold;">this</span>.re = re; }
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">setImaginary</span>(<span style="color: #b58900; font-style: italic;">double</span> <span style="color: #268bd2;">im</span>) { <span style="color: #859900; font-weight: bold;">this</span>.im = im; }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">add</span> (<span style="color: #b58900; font-style: italic;">MComplex</span> <span style="color: #268bd2;">c</span>) { re += c.re; im += c.im; }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">subtract</span> (<span style="color: #b58900; font-style: italic;">MComplex</span> <span style="color: #268bd2;">c</span>) { re -= c.re; im -= c.im; }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">multiply</span> (<span style="color: #b58900; font-style: italic;">MComplex</span> <span style="color: #268bd2;">c</span>) {
        <span style="color: #b58900; font-style: italic;">double</span> <span style="color: #268bd2;">r</span> = re * c.re - im * c.im;
        <span style="color: #b58900; font-style: italic;">double</span> <span style="color: #268bd2;">i</span> = re * c.im + im * c.re;
        re = r; im = i;
    }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">divide</span> (<span style="color: #b58900; font-style: italic;">MComplex</span> <span style="color: #268bd2;">c</span>) {
        <span style="color: #b58900; font-style: italic;">double</span> <span style="color: #268bd2;">den</span> = c.re * c.re + c.im * c.im;
        <span style="color: #b58900; font-style: italic;">double</span> <span style="color: #268bd2;">r</span> = (re * c.re - im * c.im) / den;
        <span style="color: #b58900; font-style: italic;">double</span> <span style="color: #268bd2;">i</span> = (re * c.im + im * c.re) / den;
        re = r; im = i;
    }

    <span style="color: #6c71c4; font-weight: bold;">@Override</span> <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">boolean</span> <span style="color: #b58900;">equals</span> (<span style="color: #b58900; font-style: italic;">Object</span> <span style="color: #268bd2;">o</span>) {
        <span style="color: #859900; font-weight: bold;">if</span> (o == <span style="color: #859900; font-weight: bold;">this</span>)               <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #6c71c4; font-weight: bold;">true</span>;
        <span style="color: #859900; font-weight: bold;">if</span> (<span style="color: #268bd2; font-weight: bold;">!</span>(o <span style="color: #859900; font-weight: bold;">instanceof</span> MComplex)) <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #6c71c4; font-weight: bold;">false</span>;
        <span style="color: #b58900; font-style: italic;">MComplex</span> <span style="color: #268bd2;">c</span> = (<span style="color: #b58900; font-style: italic;">MComplex</span>) o;

        <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">See Bloch page 43 to find out why to use compare() instead of ==</span>
        <span style="color: #859900; font-weight: bold;">return</span> Double.compare(re, c.re) == 0 &amp;&amp;
            Double.compare(im, c.im) == 0;
    }

    <span style="color: #6c71c4; font-weight: bold;">@Override</span> <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">hashCode</span> () {
        <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">result</span> = 17 + hashDouble(re);
        result = 31 * result + hashDouble(im);
        <span style="color: #859900; font-weight: bold;">return</span> result;
    }

    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">hashDouble</span> (<span style="color: #b58900; font-style: italic;">double</span> <span style="color: #268bd2;">val</span>) {
        <span style="color: #b58900; font-style: italic;">long</span> <span style="color: #268bd2;">longBits</span> = Double.doubleToLongBits(val);
        <span style="color: #859900; font-weight: bold;">return</span> (<span style="color: #b58900; font-style: italic;">int</span>) (longBits ^ (longBits &gt;&gt;&gt;32));
    }

    <span style="color: #6c71c4; font-weight: bold;">@Override</span> <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">String</span> <span style="color: #b58900;">toString</span>() { <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">"("</span> + re + <span style="color: #2aa198;">" + "</span> + im + <span style="color: #2aa198;">"i)"</span>; }
}

</pre>
</div>

<p>
Before we get to immutability, consider the method contracts. Where do the various contracts "come from", and is there anything in the (missing) JavaDoc that might require a bit of research?
</p>

<p>
Apply each of Bloch's 5 rules for making a class immutable:
</p>
<ol class="org-ol">
<li>Don't provide any methods that modify the object's state. How do you handle the mutators?</li>
<li>Ensure that no methods can be overridden.
<ul class="org-ul">
<li>Why is this a problem? Show me!</li>
<li>Fix the problem:
<ul class="org-ul">
<li>Change the class declaration, or</li>
<li>Change the method declarations, or</li>
<li>Change the constructor visibility.</li>
</ul></li>
</ul></li>
<li>Make all fields final.</li>
<li>Make all fields private.
<ul class="org-ul">
<li>Is there a significant difference in visibility between re and im?</li>
</ul></li>
<li>Ensure exclusive access to any mutable components.</li>
</ol>
</div>
</div>

<div id="outline-container-org2503359" class="outline-3">
<h3 id="org2503359">In class 11</h3>
<div class="outline-text-3" id="text-org2503359">
<p>
This is a JUnit theory exercise.
</p>

<ol class="org-ol">
<li>Write a JUnit theory that captures the symmetry property of the <code>equals()</code> method.</li>
<li>Create <code>@DataPoints</code> from Bloch's <code>Point</code>, <code>ColorPoint</code> classes. So that we're all on the same page, create 1 <code>null</code> reference, 1 <code>Point</code> object and 2 <code>ColorPoint</code> objects.</li>
<li>Given this set of data points:
<ul class="org-ul">
<li>How many combinations are considered by the theory?</li>
<li>How many combinations make it past the preconditions of the theory?</li>
<li>How many combinations make it to the postcondition of the theory?</li>
</ul></li>
<li>What happens to this theory and the accompanying data points when favoring composition over inheritance?</li>
<li>Repeat the exercise for the transitive property for <code>equals()</code>.</li>
<li>Recall the <code>equals()</code> and <code>hashCode()</code> discussion in Bloch. Write a JUnit theory that encodes the consistency property between <code>equals()</code> and <code>hashCode()</code>.</li>
<li>Build a toy example that violates the theory. Fix the toy example so that the theory is no longer violated.</li>
<li>Consider the <code>Comparable</code> interface: what properties should be checked with theories?</li>
</ol>
</div>
</div>

<div id="outline-container-org20d65d1" class="outline-3">
<h3 id="org20d65d1">In class 12A</h3>
<div class="outline-text-3" id="text-org20d65d1">
<p>
Consider the following (bad) Java, implementing the "C style" enum pattern:
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">Coins</span> {
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">PENNY</span> = 1;
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">NICKLE</span> = 5;
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">DIME</span> = 10;
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">QUARTER</span> = 25;
}

</pre>
</div>

<ol class="org-ol">
<li>Give example code that illustrates a type safety problem with <code>Coins</code>. Work through a range of expressions from "probably ok" to "clearly wrong".</li>
<li>What code would you need to turn a nickel into a string? Explain how this could go wrong at runtime.</li>
<li>What code would you need to iterate through the coins?</li>
<li>Would extensions to this particular enum be likely to require recompilation of client code? Explain.</li>
<li>Write a decent Java Enum for coins.</li>
<li>Turn a nickle into a string.</li>
<li>Iterate though the coins.</li>
</ol>


<p>
Consider Bloch's example:
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Abuse of ordinal to derive an associated value &#8211; DON&#8217;T DO THIS</span>
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">enum</span> <span style="color: #b58900; font-style: italic;">Ensemble</span> {
    <span style="color: #268bd2;">SOLO</span>,   <span style="color: #268bd2;">DUET</span>,   <span style="color: #268bd2;">TRIO</span>,  <span style="color: #268bd2;">QUARTET</span>, <span style="color: #268bd2;">QUINTET</span>, 
    <span style="color: #268bd2;">SEXTET</span>, <span style="color: #268bd2;">SEPTET</span>, <span style="color: #268bd2;">OCTET</span>, <span style="color: #268bd2;">NONET</span>,   <span style="color: #268bd2;">DECTET</span>;

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">numberOfMusicians</span>() { <span style="color: #859900; font-weight: bold;">return</span> ordinal() + 1; }
}
</pre>
</div>

<p>
Explain why it's wrong, fix it, and add another enum with an overlapping number of musicians.
</p>
</div>
</div>

<div id="outline-container-org2f32a1a" class="outline-3">
<h3 id="org2f32a1a">In class 12B</h3>
<div class="outline-text-3" id="text-org2f32a1a">
<p>
This is a recap exercise based on the map-based implementation of Liskov's polynomial example: <a href="./files/MapPoly.java">MapPoly</a>
</p>

<ol class="org-ol">
<li>How are the following polynomials represented?
<ul class="org-ul">
<li>\(0\)</li>
<li>\(3-7x^4\)</li>
</ul></li>
<li>Bloch would not accept that the MapPoly class is immutable. Why not? Show how it would be possible to provide mutable behavior with the class if Bloch's problem isn't fixed. Fix the problem, and implement any other changes Bloch suggests, even if they don't compromise immutability in this particular example.</li>
<li>Write a reasonable rep-invariant for <code>MapPoly</code>. How would this rep-invariant change if the zero <code>Poly</code> had an alternate representation.</li>
<li>Provide reasonable implementations of <code>equals()</code> and <code>hashCode()</code>. Explain why you believe your implemetations are appropriate.</li>
<li>As written, the contract for the <code>coeff()</code> method is inconsistent with other contracts in the class.
<ul class="org-ul">
<li>What is the inconsistency with the contract?</li>
<li>Fix the inconsistency with the contract.</li>
<li>Fix the code to match the revised contract.</li>
</ul></li>
<li>Argue that the implementation of the <code>coeff()</code> method is correct (with respect to your repaired contract, of course.)</li>
<li>Consider implementing <code>Cloneable</code> for this class. Decide whether Bloch would think this is a good idea and provide justification for your answer. Note: You don't have to actually implement anything for this question.</li>
<li>See if you can come up with a theory about Polys and implement it in JUnit. (Polys are math objects, so there should be theories!) Here's a suggestion: Think about the relationship between the degrees of two Polys being multiplied and the resulting degree.</li>
</ol>
</div>
</div>

<div id="outline-container-org07c73a4" class="outline-3">
<h3 id="org07c73a4">In class 13</h3>
<div class="outline-text-3" id="text-org07c73a4">
<p>
How well are you prepared for the final? This exercise should help you find out. Piazza discussions encouraged!
</p>

<div class="org-src-container">
<pre class="src src-java">
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900; font-style: italic;">Stack</span> {
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900; font-style: italic;">Object</span>[] <span style="color: #268bd2;">elements</span>; <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">size</span> = 0;

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">Stack</span>() { <span style="color: #859900; font-weight: bold;">this</span>.elements = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">Object</span>[0]; }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">push</span> (<span style="color: #b58900; font-style: italic;">Object</span> <span style="color: #268bd2;">e</span>) {
        <span style="color: #859900; font-weight: bold;">if</span> (e == <span style="color: #6c71c4; font-weight: bold;">null</span>) <span style="color: #859900; font-weight: bold;">throw</span> <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">NullPointerException</span>(<span style="color: #2aa198;">"Stack.push"</span>);
        ensureCapacity(); elements[size++] = e;  
    }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">pushAll</span> (<span style="color: #b58900; font-style: italic;">Object</span>[] <span style="color: #268bd2;">collection</span>) { <span style="color: #859900; font-weight: bold;">for</span> (<span style="color: #b58900; font-style: italic;">Object</span> <span style="color: #268bd2;">obj</span>: collection) { push(obj); } }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">Object</span> <span style="color: #b58900;">pop</span> () {
        <span style="color: #859900; font-weight: bold;">if</span> (size == 0) <span style="color: #859900; font-weight: bold;">throw</span> <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900; font-style: italic;">IllegalStateException</span>(<span style="color: #2aa198;">"Stack.pop"</span>);
        <span style="color: #b58900; font-style: italic;">Object</span> <span style="color: #268bd2;">result</span> = elements[--size];
        <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">elements[size] = null;</span>
        <span style="color: #859900; font-weight: bold;">return</span> result;
    }

    <span style="color: #6c71c4; font-weight: bold;">@Override</span> <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900; font-style: italic;">String</span> <span style="color: #b58900;">toString</span>() {
        <span style="color: #b58900; font-style: italic;">String</span> <span style="color: #268bd2;">result</span> = <span style="color: #2aa198;">"size = "</span> + size;
        result += <span style="color: #2aa198;">"; elements = ["</span>;
        <span style="color: #859900; font-weight: bold;">for</span> (<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">i</span> = 0; i &lt; elements.<span style="color: #b58900; font-style: italic;">length</span>; i++) {
            <span style="color: #859900; font-weight: bold;">if</span> (i &lt; elements.<span style="color: #b58900; font-style: italic;">length</span>-1)
                result = result + elements[i] + <span style="color: #2aa198;">", "</span>;
            <span style="color: #859900; font-weight: bold;">else</span>
                result = result + elements[i];
        }
        <span style="color: #859900; font-weight: bold;">return</span> result + <span style="color: #2aa198;">"]"</span>;
    }
}


</pre>
</div>

<ol class="org-ol">
<li>Write a contract for <code>push(Object e)</code>.</li>
<li>What is wrong with <code>toString()?</code> Fix it.</li>
<li>What rep-invariant is likely broken? Fix it. This includes writing a suitable rep-invariant.</li>
<li>How would Bloch's Item 25: <i>Prefer Lists to Arrays</i> apply here? Would it make the rep-invariant simpler?</li>
<li>How would you argue that that <code>pop()</code> is correct (or not)?</li>
<li>As <code>Stack</code> is written, <code>pushAll()</code> requires special documention? Why? What would Bloch suggest as an alternative?</li>
<li>Override <code>equals()</code>. What else do you have to do? Do that too.</li>
<li>Generify. What should happen to the parameter for <code>pushAll()</code>? Why?</li>
<li>Suppose we decide to implement the <code>Cloneable()</code> interface. In what ways would Bloch think we would likely get it wrong? What would Bloch recommend instead?</li>
</ol>
</div>
</div>
</div>


<div id="outline-container-orgd36977d" class="outline-2">
<h2 id="orgd36977d">Links</h2>
<div class="outline-text-2" id="text-orgd36977d">
<ul class="org-ul">
<li><a href="./index.html">Syllabus</a></li>
<li><a href="./schedule.html">Schedule</a></li>
</ul>
</div>
</div>
</div>
</body>
</html>
