#+TITLE: SWE 619 In Class Exercise Number 6

#+HTML_HEAD: <link rel="stylesheet" href="https://nguyenthanhvuh.github.io/files/org.css">
#+HTML_HEAD: <link rel="stylesheet" href="https://nguyenthanhvuh.github.io/files/org-orig.css">

* Instructions

  This is a recap exercise.

  #+begin_src java

    public class BoundedQueue {
        private Object rep[];
        private int front = 0;
        private int back = -1;
        private int size = 0;
        private int count = 0;

        public BoundedQueue(int size) {
            if (size > 0) {
                this.size = size;
                rep = new Object[size];
                back = size - 1;
            }  }

        public boolean isEmpty() { return (count == 0); }
        public boolean isFull() { return (count == size); }
        public int getCount() { return count; }

        public void put(Object e) {
            if (e != null && !isFull()) {
                back++;
                if (back >= size)
                    back = 0;
                rep[back] = e;
                count++;
            } }

        public Object get() {
            Object result = null;
            if (!isEmpty()) {
                result = rep[front];
                rep[front] = null;
                front++;
                if (front >= size)
                    front = 0;
                count--;
            }
            return result;
        }
        @Override public String toString() {
            String result = "front = " + front;
            result += "; back = " + back;
            result += "; size = " + size;
            result += "; count = " + count;
            result += "; rep = [";
            for (int i = 0; i < rep.length; i++) {
                if (i < rep.length-1)
                    result = result + rep[i] + ", ";
                else
                    result = result + rep[i];
            }
            return result + "]";
        }
    }

  #+end_src
  

  1. How would Liskov describe a typical bounded queue?
  1. What is wrong with =toString()=? What needs to be done to fix it? Make it so.
  1. Write some sample client code to exercise the data structure. Include some non-happy-path cases. Would Bloch likely change the behavior? If so, how?
  1. Write contracts for each method (as written), including the constructor.
  1. Build a rep-invariant. Focus on the code in =get()=. There are also lots of constraints on the array indices; these are quite tricky to get right. The constructor also introduces some complexity.
  1. Suppose we removed the line
     #+begin_src java
       rep[front] = null;       
     #+end_src
     from =get()=.
     1. Informally, why is this wrong?
     1. Formally, where does the correctness proof break down?
     1. Could a client ever see the problem?
  1. Now that we've done some AF/RI analysis, what changes make the implementation better? btw - this is code straight out of a textbook.
  1. Could this data structure be made immutable? If so, what would change in the contracts and method headers? What would likely change in the implementation? 



* Links
  - [[./index.html][Syllabus]]
  - [[./schedule.html][Schedule]]

