#+TITLE: Module 5 - Reasoning about Data Abstraction


#+HTML_HEAD: <link rel="stylesheet" href="https://dynaroars.github.io/files/org.css">

* Overview and Objectives 
** OVERVIEW 

** COURSE LEVEL OBJECTIVES (CLO) 
Upon completion of this course, you should be able to:

1. Construct modern high quality software systems and reason about them. 
2. Properly define software specifications and rep-invariants. 
3. Leverage immutability to properly construct threat safe programs. 
4. Explain object-oriented concepts such as information hiding, encapsulation, data and type abstraction, and polymorphism. 
5. Properly use exception handling 
6. Identify when it is appropriate to use inheritance and generics.  
 
** TODO MODULE LEVEL OBJECTIVES (MLO) 
Upon completion of this module’s activities, you should be able to: 

1. Able to explain and compare the key concepts of software decomposition and abstraction
2. Able to to describe and demonstrate specification concepts, e.g., requires and effects of program
3. Able to find and apply formal specifications for existing software (e.g., through Javadocs)

* Module Video (Wiley-Produced w/Dan Ramos) [3-5 minutes]
#+begin_comment
#+end_comment
  

* Learning Materials [~100 pages, ~3.5 hours]
** TEXTBOOK READINGS
- Barbara Liskov with John Guttag. Program Development in Java. Addison Wesley, 2001, ISBN 0-201-65768-6. 
  - Chapter 1: Introduction

* Learning Unit 1 – Intro (MLO 1) [0.5 hour]

* Learning Unit 2 – (MLO 1, 2) [~2 hour]
  

  
** Instructor Screencast: TITLE
** Interactive Element: TITLE  
** Instructor Screencast: TITLE 


* In Class 1 (MLO 1, 2, 3) [1 hours] 
   Consider the code:

   #+begin_src java

     public class Members {
         // Members is a mutable record of organization membership
         // AF: Collect the list as a set
         // rep-inv1: members != null
         // rep-inv2: members != null && no duplicates in members
         // for simplicity, assume null can be a member...

         List<Person> members;   // the representation

         //  Post: person becomes a member
         public void join (Person person) { members.add(person);}

         //  Post: person is no longer a member
         public void leave(Person person) { members.remove(person);}

   #+end_src


   1. Analyze these 4 questions for rep-inv 1.
      1. Does =join()= maintain rep-inv?   (Answer: YES)
      1. Does =join()= satisfy contract?   (Answer: YES)
      1. Does =leave()= maintain rep-inv?  (Answer: YES)
      1. Does =leave()= satisfy contract?  (Answer: NO)
   1. Repeat for rep-inv 2.
      1. Does =join()= maintain rep-inv?  (Answer: NO)
      1. Does =join()= satisfy contract?  (Answer: YES, but does not matter because already violate rep-inv)
      1. Does =leave()= maintain rep-inv?  (Answer: YES)
      1. Does =leave()= satisfy contract? (Answer: YES)

      
   1. Recode =join()= to make the verification go through. Which rep-invariant do you use?
      ... add condition to check for duplication
   1. Recode =leave()= to make the verification go through. Which rep-invariant do you use? 



*** Instructor Screencast: TITLE 
*** Interactive Element: TITLE 
*** Instructor Screencast: TITLE 
Link to MP4 File 

* Assignment – (MLO 1, 2) [~2 hours]  
 
** Purpose 

Understand and practice rep-invariants, contracts, tests

** Instructions
   Consider following Poly example
   #+begin_src java
     /*
      ,* MapPoly:  Liskov's Poly class, converted to a (Tree)Map rep.
      ,* Notes:
      ,*   0) Relies on TreeMap (not just Map) for efficiently finding max nonzero coefficient
      ,*   1) Private constructor not useful, so deleted
      ,*   2) No-arg constructor implemented with 2-arg constructor
      ,*   3) Empty map represents the 0 MapPoly (very different from Poly)
      ,*   4) Uses TreeMap descending iterator to find degree(); hence no deg variable
      ,*   5) Code generally shorter.
      ,*/
     import java.util.*;

     public class MapPoly {

         private TreeMap<Integer, Integer> trms;

         // Effects: Initializes this to be the zero polynomial
         public MapPoly() {
            this(0,0);
         }

         // Effects: If n < 0 throws IllegalArgumentException
         // else initializes this to be the polynomial c*x^n
         public MapPoly(int c, int n) throws IllegalArgumentException {
            if (n < 0) {
               throw new IllegalArgumentException("MapPoly(int, int) constructor");
            }
            trms = new TreeMap<Integer, Integer> ();
            if (c != 0) { trms.put(n, c); }
         }

         // Effects: returns the degree of this
         public int degree() {
            int result  = 0;
            if (trms.size() > 0) {
               result = trms.descendingKeySet().iterator().next();
            }
            return result;
         }

         // Effects: if degree is < 0 then throws IAE;
         // returns the coefficent of the term of this whose exponent is d (otherwise return 0)
         public int coeff(int d) {
            if (d < 0) throw new IllegalArgumentException("MapPoly.coeff");
            if (trms.containsKey(d)) return trms.get(d);
            return 0;
         }

         // Effects: If q is null throw NullPointerException
         // else return the MapPoly this - q
         public MapPoly sub(MapPoly q) {
            return add(q.minus());
         }

         // Effects: return the MapPoly -this
         public MapPoly minus() {
            MapPoly result = new MapPoly();
            for (Integer i : trms.keySet()) {
               result.trms.put (i, -trms.get(i));
            }
            return result;
         }

         // Effects: If q is null throw NullPointerException
         // else return the MapPoly this + q
         public MapPoly add(MapPoly q) {
       
            // find all the nonzero coefficients in either this or q
            Set<Integer> nonZero = new HashSet<Integer>(q.trms.keySet());
            nonZero.addAll(trms.keySet());

            // Add the coefficients together; store the nonzero results
            MapPoly result = new MapPoly();
            for (Integer i : nonZero) {
               int newCoeff = coeff(i) + q.coeff(i);
               if (newCoeff != 0) result.trms.put(i, newCoeff);
            }
            return result;
         }

         // Effects: If q is null throw NullPointerException
         // else return the MapPoly this * q
         public MapPoly mul(MapPoly q) {
            MapPoly result = new MapPoly();

            for (Integer i:  trms.keySet()) {
               for (Integer j:  q.trms.keySet()) {
                   result = result.add(new MapPoly (coeff(i) * q.coeff(j), i+j));
               }
            }
            return result;
         }

         @Override public String toString() {   // Note that TreeMap gets the order right
            String r = "MapPoly:";

            if (trms.size() == 0) {   // special case for empty Map
                r += " " + 0;
            }

            for (Integer i: trms.keySet()) {
               if (coeff(i) < 0) { r += " - " + -coeff(i) + "x^" + i; }
               else              { r += " + " +  coeff(i) + "x^" + i; }
            }
            return r;
         }

         public static void main(String[] args) { 
            System.out.println("Hello");
            MapPoly mp = new MapPoly();
            System.out.println("MapPoly mp = " + mp);
            mp = mp.add(new MapPoly(3,5));
            System.out.println("MapPoly mp = " + mp);
            mp = mp.add(new MapPoly(-3,5));
            System.out.println("MapPoly mp = " + mp);
            mp = mp.add(new MapPoly(-3,5));
            System.out.println("MapPoly mp = " + mp);
            mp = mp.add(new MapPoly(-2,2));
            System.out.println("MapPoly mp = " + mp);
            System.out.println("MapPoly -mp = " + mp.minus());
            System.out.println("MapPoly mp*mp = " + mp.mul(mp));
         }
     }

   #+end_src

  
    1. Implement =repOk()=.
    1. Introduce a fault (i.e. "bug") that breaks the rep-invariant. Try to do this with a small (conceptual) change to the code. Show that the rep-invariant is broken with a JUnit test.
    1. Analyzed your bug with respect to the various contracts/methods in Poly. Are all/some/none of the contracts violated?
    1. Do you think your fault is realistic? Why or why not?

    Your deliverable should be a *story*. Take screenshots (e.g. of failing JUnit tests) as necessary to make your case.

*** Grading Criteria
    - Correctness of solution
    - Clarity of story
    Note: If your group had trouble with the previous assignment, feel free to appeal to your classmates to post a sample solution on Piazza.


** Deliverable 
- Submit a =.java= file for your implementation. 



** Due Date 
Your assignment is due by Sunday 11:59 PM, ET. 

* Module 1 Quiz (MLO 1, 2) [~.5 hour] 
 
** Purpose 
Quizzes in this course give you an opportunity to demonstrate your knowledge of the subject material. 

** Instructions 
Note the following instructions for your quiz:

  
  1. Consider the following (supposedly) immutable class:

     #+begin_src java
       public final class Immutable { 
           private final String string;
           private final int x;
           private final List<String> list;

           public Immutable(String string, int x, List<String> list) {
               this.string = string;                     // Line A
               this.x = x;                               // Line B
               this.list = new ArrayList<String> (list); // Line C
           }

           public String getString() { return string; }  // Line D
           public int getInt()    { return x; }       // Line E
           public List<String> getList() { return list; }    // Line F
       }
     #+end_src
    Which of the lines (A--F) has a problem wrt the immutability of class Immutable?
  2. For each of the above lines that has problem with immutability, write pseudocode code to demonstrate the issue

    #+begin_comment
     Only line F (because list is muttable)

     List<String> list = //... supppose list is [cat, dog]
     Immutable im = new Immutable("bat", 7, list);
     list = im.getList();
     list.add("elephant");   // now I've changed the internal state of Immutable
                             // from
                             // <bat, 7, [cat, dog]>
                             // to
                             // <bat, 7, [cat, dog, elephant]>
    #+end_comment



The quiz is 20 minutes in length. 
The quiz is closed-book.

** Deliverable 
Use the link above to take the quiz.

** Due Date 
Your quiz submission is due by Sunday 11:59 PM, ET. 

