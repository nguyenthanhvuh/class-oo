#+TITLE: Module 4 - Data Abstraction; Mutability 

#+HTML_HEAD: <link rel="stylesheet" href="https://dynaroars.github.io/files/org.css">

* Overview and Objectives 
** OVERVIEW 

** COURSE LEVEL OBJECTIVES (CLO) 
Upon completion of this course, you should be able to:

1. Construct modern high quality software systems and reason about them. 
2. Properly define software specifications and rep-invariants. 
3. Leverage immutability to properly construct threat safe programs. 
4. Explain object-oriented concepts such as information hiding, encapsulation, data and type abstraction, and polymorphism. 
5. Properly use exception handling 
6. Identify when it is appropriate to use inheritance and generics.  
 
** MODULE LEVEL OBJECTIVES (MLO) 
Upon completion of this module’s activities, you should be able to: 

* Module Video (Wiley-Produced w/Dan Ramos) [3-5 minutes]
#+begin_comment
#+end_comment
  

* Learning Materials [~100 pages, ~3.5 hours]
** TEXTBOOK READINGS
- Barbara Liskov with John Guttag. Program Development in Java. Addison Wesley, 2001, ISBN 0-201-65768-6. 
  - Chapter 5:  5.1--5.4
  
* Learning Unit 1 – Intro (MLO 1) [~0.5 hour]



* Learning Unit 2 – Data Abstraction(MLO 1, 2) [~2.5 hour]


** Instructor Screencast: TITLE

* Learning Unit 3 – Mutability (MLO 1, 2) [~2.5 hour]

* Exercise (MLO 1, 2, 3) [.5 hours] 

* Exercise (MLO 1, 2, 3) [.5 hours]


* Module 3 Assignment – (MLO 1, 2) [~2 hours]  
 
** Purpose 
   Get familiar with mutability and review method specifications.

** Instructions

Given the following =MapPoly= class, a map-based version of Liskov's =Poly=

#+begin_src java
  /*
   ,* MapPoly:  Liskov's Poly class, converted to a (Tree)Map rep.
   ,* Notes:
   ,*   0) Relies on TreeMap (not just Map) for efficiently finding max nonzero coefficient
   ,*   1) Private constructor not useful, so deleted
   ,*   2) No-arg constructor implemented with 2-arg constructor
   ,*   3) Empty map represents the 0 MapPoly (very different from Poly)
   ,*   4) Uses TreeMap descending iterator to find degree(); hence no deg variable
   ,*   5) Code generally shorter.
   ,*/
  import java.util.*;

  public class MapPoly {

      private TreeMap<Integer, Integer> trms;

      // Effects: Initializes this to be the zero polynomial
      public MapPoly() {
         this(0,0);
      }

      // Effects: If n < 0 throws IllegalArgumentException
      // else initializes this to be the polynomial c*x^n
      public MapPoly(int c, int n) throws IllegalArgumentException {
         if (n < 0) {
            throw new IllegalArgumentException("MapPoly(int, int) constructor");
         }
         trms = new TreeMap<Integer, Integer> ();
         if (c != 0) { trms.put(n, c); }
      }

      // Effects: returns the degree of this
      public int degree() {
         int result  = 0;
         if (trms.size() > 0) {
            result = trms.descendingKeySet().iterator().next();
         }
         return result;
      }

      // Effects: if degree is < 0 then throws IAE;
      // returns the coefficent of the term of this whose exponent is d (otherwise return 0)
      public int coeff(int d) {
         if (d < 0) throw new IllegalArgumentException("MapPoly.coeff");
         if (trms.containsKey(d)) return trms.get(d);
         return 0;
      }

      // Effects: If q is null throw NullPointerException
      // else return the MapPoly this - q
      public MapPoly sub(MapPoly q) {
         return add(q.minus());
      }

      // Effects: return the MapPoly -this
      public MapPoly minus() {
         MapPoly result = new MapPoly();
         for (Integer i : trms.keySet()) {
            result.trms.put (i, -trms.get(i));
         }
         return result;
      }

      // Effects: If q is null throw NullPointerException
      // else return the MapPoly this + q
      public MapPoly add(MapPoly q) {
       
         // find all the nonzero coefficients in either this or q
         Set<Integer> nonZero = new HashSet<Integer>(q.trms.keySet());
         nonZero.addAll(trms.keySet());

         // Add the coefficients together; store the nonzero results
         MapPoly result = new MapPoly();
         for (Integer i : nonZero) {
            int newCoeff = coeff(i) + q.coeff(i);
            if (newCoeff != 0) result.trms.put(i, newCoeff);
         }
         return result;
      }

      // Effects: If q is null throw NullPointerException
      // else return the MapPoly this * q
      public MapPoly mul(MapPoly q) {
         MapPoly result = new MapPoly();

         for (Integer i:  trms.keySet()) {
            for (Integer j:  q.trms.keySet()) {
                result = result.add(new MapPoly (coeff(i) * q.coeff(j), i+j));
            }
         }
         return result;
      }

      @Override public String toString() {   // Note that TreeMap gets the order right
         String r = "MapPoly:";

         if (trms.size() == 0) {   // special case for empty Map
             r += " " + 0;
         }

         for (Integer i: trms.keySet()) {
            if (coeff(i) < 0) { r += " - " + -coeff(i) + "x^" + i; }
            else              { r += " + " +  coeff(i) + "x^" + i; }
         }
         return r;
      }

      public static void main(String[] args) { 
         System.out.println("Hello");
         MapPoly mp = new MapPoly();
         System.out.println("MapPoly mp = " + mp);
         mp = mp.add(new MapPoly(3,5));
         System.out.println("MapPoly mp = " + mp);
         mp = mp.add(new MapPoly(-3,5));
         System.out.println("MapPoly mp = " + mp);
         mp = mp.add(new MapPoly(-3,5));
         System.out.println("MapPoly mp = " + mp);
         mp = mp.add(new MapPoly(-2,2));
         System.out.println("MapPoly mp = " + mp);
         System.out.println("MapPoly -mp = " + mp.minus());
         System.out.println("MapPoly mp*mp = " + mp.mul(mp));
      }
  }

#+end_src

    - Rewrite =MapPoly= so that it is /mutable/. Keep the same representation.
    - Rewrite the overview, the method signatures, the method specifications, and the methods themselves. You do not need to rewrite the abstraction function and representation invariant for this exercise.

     - Turn in a *story*. This means that it is possible to grade your assignment simply by reading it, as if it were part of a textbook. In particular, every place you make a decision to change something in the code (or not), you should have a description of what you did (or didn't do) and why you did (or didn't do) it.
     - Remember that part of your group is responsible for synthesizing a solution, and part of your group is responsible for checking the result.

*** Grading Criteria
    - Correct transformation of Poly
    - Clarity of your story.
    - Reasonable division of synthesis vs. checking.  

** Deliverable 
- Submit a =.java= file for your implementation. 

** Due Date 
Your assignment is due by Sunday 11:59 PM, ET. 

* Module 4 Quiz (MLO 1, 2) [~.5 hour] 
 
** Purpose 
Quizzes in this course give you an opportunity to demonstrate your knowledge of the subject material. 

** Instructions 
*Immutatiblity*: Consider a partial version of a /mutable/ ~Stack~ class:
   #+begin_src java
     public class Stack {

         private Object[] elements;
         private int size = 0;

         public Stack() { this.elements = new Object[0]; }

         public void push (Object e) {
             ensureCapacity();      // implementation omitted from quiz
             elements[size++] = e;
         }

         public Object pop () {
             if (size == 0) throw new IllegalStateException("Stack.pop");
             Object result = elements[--size];
             elements[size] = null;
             return result;
         }
     }

   #+end_src
   Also consider the following client interaction with ~Stack~
   #+begin_src java
     Stack s = new Stack();
     s.push("cat");
     s.push("dog");
     System.out.println(s.pop());
   #+end_src
   
     *Q*: What methods would be needed to convert the client interaction into an equivalent interaction with an /immutable/ version called ~IStack~? For each method, give *just the method header* - not the contract or implemetation. Note:  the mutable version of ~pop~ has two behaviors: modifies the ~Stack~ *and* returns the top element.

   
#+begin_center SOLUTION
     public class IStack{
     public IStack push(Object e){
     // return new IStack() .... 
     }

     public IStack pop (){
     // return new IStack object
     }

     public Object top(){
     // return the top of the stack 
     }

     }
#+end_center



The quiz is 30 minutes in length. 
The quiz is closed-book.

** Deliverable 
Use the link above to take the quiz.

** Due Date 
Your quiz submission is due by Sunday 11:59 PM, ET. 

 
