#+TITLE: Module 8 - Polymorphic Abstractions; Lambdas

#+HTML_HEAD: <link rel="stylesheet" href="https://dynaroars.github.io/files/org.css">

* Overview and Objectives 
** OVERVIEW
In this module we will learn about polymorphism, an important concept in Object Oriented programming.  We will learn about the benefits of using polymorphism, in particular how they overcome issues when polymorphism was not used. We will also learn about using anonymous classes and especially lambda functions to write more precise and shorter code.    

** COURSE LEVEL OBJECTIVES (CLO) 
Upon completion of this course, you should be able to:

1. Construct modern high quality software systems and reason about them. 
2. Properly define software specifications and rep-invariants. 
3. Leverage immutability to properly construct threat safe programs. 
4. Explain object-oriented concepts such as information hiding, encapsulation, data and type abstraction, and polymorphism. 
5. Properly use exception handling 
6. Identify when it is appropriate to use inheritance and generics.  
 
** MODULE LEVEL OBJECTIVES (MLO) 
Upon completion of this module’s activities, you should be able to: 

* Module Video (Wiley-Produced w/Dan Ramos) [3-5 minutes]
#+begin_comment
#+end_comment
  

* Learning Materials [~100 pages, ~3.5 hours]
** TEXTBOOK READINGS
- Barbara Liskov with John Guttag. Program Development in Java. Addison Wesley, 2001, ISBN 0-201-65768-6. 
  - Chapter 8: Polymorphic Abstractions

- Joshua Bloch. Effective Java. Third Edition. Addison-Wesley Professional, 2017, ISBN 978-0-13-468599-1.
  - Chapter 7 - Item 42 
  

* Learning Unit 1 – Motivation (MLO 1) [~0.5 hour]
- Previously we define collections of =ints= or =doubles=.  This is rather limiting because they are restricted to specific types (=ints= or =string=).
- It would be better to define the collection type just once yet have it work for all types of elements
- *Polymorphic abstractions* is the solution for this. These abstractions are called polymorphic because they work for many types, e.g., =Vector= is polymorphic to its element.
  - Polymorphism generalizes abstractions so that they work for many types. It allows us to avoid having to redefine abstractions when we want to use them for more types; instead, a single abstraction becomes much more widely useful.
  - A procedure or iterator can be polymorphic with respect to the types of one or more arguments. A data abstraction can be polymorphic with respect to the types of elements its objects contain.

    
* TODO  Learning Unit 2 – (MLO 1, 2) [~2.5 hour]
**  Polymorphic Data Abstraction
- Fig. 8.1 (Liskov 8) provides a specification of a =Set= abstraction.
  - =Set= objects contain /heterogeneous/ collections of elements (similar to =Vector=).
  - The specification of =Set= is similar to =IntSet= except that =Set='s methods (such as =insert= and =isIn=) take =Objects= as arguments or return them as results.
  - Because objects can be compared in various ways (using either == or =equals=), the overview states what equality test is being used.


** Equality Revisited
- Several ways to check if two objects are equal
  - *Object identity* [A==B] (same object)
  - *Object state* [A.counter = B.counter] (similar objects)
  - *Object property* [A.area() = B.area()] (practically same)

-  Some trouble when storing mutable types in collections
  - assume a collection that does not allow publication (e.g., =Set=)
  - Aim: to store mutable types =Vector=
    #+begin_src java
      void insert (Object x) {
          for all elements in collection{
                  if (element[i].equals(x)) return; // no duplicates
              } 
          collection.addElement(x);
    #+end_src
    - so far looks fine
  - Now let's try this client code (using the Set code in Fig. 8.1 of Liskov 8 which uses Vector)
    - =equals= for Vector returns true if 2 vectors have the same state
      
#+begin_src java
  Set s = new HashSet();  // 
  Vector x = new Vector(); // 
  Vector y = new Vector(); // 
  s.insert(x);		 // 
  s.insert(y);		 //  y is not added to s because  
  s.contains(y)            //  true
  x.add(new Integer(3))   ;
  s.isIn(y); // false
#+end_src    

- The solution to this problem is using =immutable= object
  - Consider Fig. 8.3 where we declare an immutable =Container= with
    #+begin_src java
      public boolean equals (Object x) {
         if (! x instanceOf Container) return false;
         return (el == ((Container) x.el)); }
    #+end_src
  - then this client code works fine
#+begin_src java
  Set s = new Set( );
  Vector x = new Vector( );
  Vector y = new Vector( );
  s.insert(new Container(x));
  s.insert(new Container(y));
  x.add(new Integer(3));
  if (s.isIn(new Container(y))) // will get here
#+end_src


** Additional Methods
- Suppose we want to define an =OrderedList= type.  We need a way to /order/ the element.
  - We can achieve this using the =Comparable= interface, where argume and results are now =Comparable=, e.g., In Fig. 8.5
    #+begin_src  java
      boolean isIn (Comparable el)
      // effects: if el is in this returns true else false
    #+end_src
- =Comparable=:
  - comparable object is capable of comparing itself with another object (override =compareTo=)
    - e.g., compare =age= of a =Person=
    - what if in addition, we also want to compare the =name= of a =Person=?  Not possible, already implement =compareTo=
  - requires /pre-planning/  

- =Comparator=
  - /post-planning/

- Example: Comparable vs Comparator

  #+begin_src java
    //comparable
    class Person implements Comparable{
        int age;
        String name;
        int years_of_experiences;

        public int compareTo(Person p){//restricted to age
            age.compare(p.age);
        }
    }


    //comparator
    class NamePerson implements Comparator{
        public int compare (Person p1, Person p2){
            //can do by  name
        }
    }
    class ExperiencePerson implements Comparator{
        public int compare (Person p1, Person p2){
            //can do by experience
        }
    }


    Coolections.sort(collection_of_person, new NamePerson())
  #+end_src

  


* Learning Unit 2 – Lambdas (MLO 1, 2) [~1 hour]

- Block 7 Item 42: Prefer lambdas to anonymous classes
  
  - Sorting a list of string using anonymous class
    #+begin_src java
      // Anonymous class instance as a function object - obsolete!
      Collections.sort(words, new Comparator<String>() {
          public int compare(String s1, String s2) {
              return Integer.compare(s1.length(), s2.length());
          }
      });
    #+end_src
  - Works ok, but too verbose. In Java 8, we can use lambda
#+begin_src  java
// Lambda expression as function object (replaces anonymous class)
Collections.sort(words,
        (s1, s2) -> Integer.compare(s1.length(), s2.length()));
#+end_src    
    

* In-class Exercise (MLO 1, 2, 3) [.5 hours]
   #+begin_src java
     public class Person {

         public enum Sex {
             MALE, FEMALE
         }

         String name;
         Sex gender;
         String emailAddress;

         public int getAge() {
             // ...
         }

         public void printPerson() {
             // ...
         }
     }

   #+end_src
**** Approach 1: Create Methods That Search for Members That Match One Characteristic.

     One simplistic approach is to create several methods; each method searches for members that match one characteristic, such as gender or age. *Create a method that prints members that are older than a specified age*.
     
     Limitation: This approach can potentially make your application brittle, which is the likelihood of an application not working because of the introduction of updates (such as newer data types). Suppose that you upgrade your application and change the structure of the Person class such that it contains different member variables; perhaps the class records and measures ages with a different data type or algorithm. You would have to rewrite a lot of your API to accommodate this change. In addition, this approach is unnecessarily restrictive; what if you wanted to print members younger than a certain age, for example?
   
**** Approach 2: Create More Generalized Search Methods.

     Create a method is more generic than the one in the previous approach. It prints members within a specified range of ages.
     
     Limitation: What if you want to print members of a specified sex, or a combination of a specified gender and age range? What if you decide to change the Person class and add other attributes such as relationship status or geographical location? Although this method is more generic, trying to create a separate method for each possible search query can still lead to brittle code. You can instead separate the code that specifies the criteria for which you want to search in a different class.
   
**** Approach 3: Specify Search Criteria Code in a Local Class

     Instead of writing filtering functions, use a new interface and class for each search you plan. Use the following filtering criteria for example:  filters members that are eligible for Selective Service in the United States: those who are male and between the ages of 18 and 25:
     
     Limtation: Although this approach is less brittle—you don't have to rewrite methods if you change the structure of the Person—you still have additional code: a new interface and a local class for each search you plan to perform in your application. Because one of the class implements an interface, you can use an anonymous class instead of a local class and bypass the need to declare a new class for each search.
     
**** Approach 4: Specify Search Criteria Code in an Anonymous Class
     Use an anonymous class to address the issue with Approach 3.

     Limtation: This approach reduces the amount of code required because you don't have to create a new class for each search that you want to perform. However, the syntax of anonymous classes is bulky considering that the CheckPerson interface contains only one method. In this case, you can use a lambda expression instead of an anonymous class, as described in the next section.

**** Approach 5: Specify Search Criteria Code with a Lambda Expression

     Use lambda expression to address the limitation the previous approach.



* In-class Exercise (MLO 1, 2, 3) [.5 hours]


*  Assignment – (MLO 1, 2) [~2 hours]  
 
** Purpose 
Practing lambdas and anonymous functions

** Instructions
   #+begin_src java
     public class Person {

         public enum Sex {
             MALE, FEMALE
         }

         String name;
         Sex gender;
         String emailAddress;

         public int getAge() {
             // ...
         }

         public void printPerson() {
             // ...
         }
     }

   #+end_src
**** Approach 1: Create Methods That Search for Members That Match One Characteristic.


     One simplistic approach is to create several methods; each method searches for members that match one characteristic, such as gender or age. *Create a method that prints members that are older than a specified age*.
     
     Limitation: This approach can potentially make your application brittle, which is the likelihood of an application not working because of the introduction of updates (such as newer data types). Suppose that you upgrade your application and change the structure of the Person class such that it contains different member variables; perhaps the class records and measures ages with a different data type or algorithm. You would have to rewrite a lot of your API to accommodate this change. In addition, this approach is unnecessarily restrictive; what if you wanted to print members younger than a certain age, for example?
   
**** Approach 2: Create More Generalized Search Methods.

     Create a method is more generic than the one in the previous approach. It prints members within a specified range of ages.
     
     Limitation: What if you want to print members of a specified sex, or a combination of a specified gender and age range? What if you decide to change the Person class and add other attributes such as relationship status or geographical location? Although this method is more generic, trying to create a separate method for each possible search query can still lead to brittle code. You can instead separate the code that specifies the criteria for which you want to search in a different class.
   
**** Approach 3: Specify Search Criteria Code in a Local Class

     Instead of writing filtering functions, use a new interface and class for each search you plan. Use the following filtering criteria for example:  filters members that are eligible for Selective Service in the United States: those who are male and between the ages of 18 and 25:
     
     Limtation: Although this approach is less brittle—you don't have to rewrite methods if you change the structure of the Person—you still have additional code: a new interface and a local class for each search you plan to perform in your application. Because one of the class implements an interface, you can use an anonymous class instead of a local class and bypass the need to declare a new class for each search.
     
**** Approach 4: Specify Search Criteria Code in an Anonymous Class
     Use an anonymous class to address the issue with Approach 3.

     Limtation: This approach reduces the amount of code required because you don't have to create a new class for each search that you want to perform. However, the syntax of anonymous classes is bulky considering that the CheckPerson interface contains only one method. In this case, you can use a lambda expression instead of an anonymous class, as described in the next section.

**** Approach 5: Specify Search Criteria Code with a Lambda Expression

     Use lambda expression to address the limitation the previous approach.

** Deliverable 
- Submit a =.java= file for your implementation. 

** Due Date 
Your assignment is due by Sunday 11:59 PM, ET. 

* TODO Module 1 Quiz (MLO 1, 2) [~.5 hour] 
 
** Purpose 
Quizzes in this course give you an opportunity to demonstrate your knowledge of the subject material. 

** Instructions 
  #+begin_src java
    Set<String> t = //  See questions below

    t.add("antelope");
    t.add("dog");
    t.add("cat");

 // t.toString() is ???
  #+end_src  


1. Suppose ~t~ is instantiated as ~Set<String> t = new TreeSet<String>();~.  At the end of the computation, what is ~t.toString()?~ 
*Answer*: [antelope, cat, dog]
2. Suppose ~t~ is instantiated as ~Set<String> t = new TreeSet<String>((x,y) -> x.length() - y.length());~. At the end of the computation, what is ~t.toString()?~
*Answer*: [dog, antelope]
3. Suppose ~t~ is instantiated as ~Set<String> t = new TreeSet<String>((x,y) -> y.compareTo(x));~. At the end of the computation, what is ~t.toString()?~
*Answer*: [dog, cat, antelope]
4. Which of the above ~Comparator~ implementations is problematic? and why?
*Answer*: 2, compare(a,b)  is not consistent with a.equals(b).

The quiz is 30 minutes in length. 
The quiz is closed-book.

** Deliverable 
Use the link above to take the quiz.

** Due Date 
Your quiz submission is due by Sunday 11:59 PM, ET. 

 gaerdff
