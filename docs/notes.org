#+TITLE: SWE 419 Notes

#+OPTIONS: ^:nil toc:1

#+HTML_HEAD: <link rel="stylesheet" href="https://dynaroars.github.io/files/org.css">
#+HTML_HEAD: <link rel="alternative stylesheet" href="https://dynaroars.github.io/files/org-orig.css">

* Lecture 2 (<2022-09-02 Fri>)
- Groups: next time:  1 submission per group
  
- Reconsider In-class 1B (class =User=)
#+begin_src java
  User u1 = new u1("hello");
  User u2 = new User(null);
  u2.equals(u1); //contract:F, impl: F
  u1.equals(v2); //contract:F (Javadoc does not say it should raise exception), impl: exception

  //how to fix this?
  //Check for null and return False
#+end_src  

- Another example on how to obtain specs from documentation
  - consider =remove= from =iterator=: https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html
    - Removes from the underlying collection the last element returned by this iterator (optional operation). This method can be called only once per call to next(). The behavior of an iterator is unspecified if the underlying collection is modified while the iteration is in progress in any way other than by calling this method.
    - Getting contracts/specs from the English description.
        - 1st sentence: postcondition, specifying behavior 
        - 2nd:  post  or detail implementation
        - 3rd:  post, side effects,  but could be a *precondition*:  statement that the collection should not be modified


- Strong Post vs Weak Pre

Precondition (P):
  - client/customer: establish  P
Postcondition (Q)
  - developer/implementation:  establish Q under assumption that P is established


- If a program is not correct
  - if precondition is wrong: blame client
  - if (precondition is met) postcondition is wrong: blame developer

  - Reconsider the intdiv example from previous class
    
#+begin_src java
  int intdiv(int x, int y){
    /*
    Return the integer division result x/y. 

    precond:
    - x and y are integers # (already given in type)
    - y cannot be zero   # better if we can remove this

    postcond:
    - z is a number  # weak
    - z is an integer  # weak
    - z = x // y  # strong
    */

    return z
  }
#+end_src



- Total vs Partial contract
  - partial specification:  has a precondition
  - total specification:  has NO precondition

- how to turn a partial into a total specification?
  //partial spec
  sqrt(x):
     precondition: x >= 0
     postcondition:  y*y == x (-/+ epsilon)

  //total spec
  sqrt(x):
     precondition: 
     postcondition:
         //if x < 0:  raise exception
         //ow.  y*y == x (-/+ epsilon)

  //div_xy(x,y):   output = x/y
  partial spec:
   precond:  y != 0
   post :   y*output == x

  total spec:
    precond: true
    postcondition:   if y is 0, raise exception(DivByZero);
    y*output = 

- In-class 2A (=tail= implementation)
  - Discussion

- If have time, do 2B    

- If have more time,  do basic logic terminologies
    

* Lecture 1 (8/26)

** Specification Example

Sorting (e.g., quicksort)
- Input: a list of integers numbers, e.g., [2,1,5,10]

- Output:  
  - *output is a permutation of input* and *output is in sored sorder (e.g., ascending)*
  
- Alg:
  - additional requirements, e.g., (involving pivot, worst case complexity n^2, amortized nlg n)
   
** Definitions 
Software Specifications (e.g., specification of a program/methoad/function)
 - *Preconditions*: properties of the Inputs
 - *Postconditions*: properties of the Outputs
   - Typically will have some relationships with the inputs
   
- Additional properties/specifications that are common for all software (desirable, but very hard to achieve)
  - secured
  - robust
  - bugs-free
  - efficiently
  
- Specification of a program: precondition + postcondition
- Correctness: A program (implementation) is *correct* if it satifies the given specifications (i.e., pre/post conditions).

** Another example

#+begin_src python
int intdiv(int x, int y):
  /*
  precond: x and y are integers, y cannot be zero
  postcond: z = x // y
  */
  

  return z

#+end_src



** In class Exercise (User, equals)
*** Truth table for Implication (=>)

| X | Y | X => Y |
|---+---+--------|
| T | T | T      |
| T | F | F      |
| F | T | T      |
| F | F | T      |

- Be careful about implication, the formula `X => Y` is only False when `X` is True but `Y` is False, in every other cases, the formula is True.


*** Expected properties for an implementation of `equals` (according to [[https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)]])
1. reflexive: `a == a`
1. symmetry:   `a == b <=>  b == a`
1. transitive: `a == b && b == c  =>  a == c`
 

- Examples

#+begin_src java
User u1 = new User("hello");
User u2 = new User("world")
User u3 = new User("swe419");

User u1a = new User("hello");
User u1b = new User("hello");
User u2a = new User("world");

SpecialUser s1 = new SpecialUser("hello", 1)
#+end_src


For the equal implementation in In-class 1B for =User=.

- Reflexive: OK
  - e.g., =u1.equals(u1): contract: T   impl: T=

- symmetry: OK
  - e.g., =u1.equals(u2): False  && u2.equals(u1): False    contract: F   impl: F=
  - =u1.equals(u1a): T  && u1a.equals(u1): T  contract: T  impl: T=

- Transitive: OK
  - e.g., =u1.equals(u2) &&  u2.equals(u3) =>  u1.equals(u3) contract: T impl: T=, 
  - =u1.equals(u2a) &&  u2a.equals(u2b)  contract: T   impl: T=
          
          
Things become more complicated when involving inheritence

- Symmetry: Not OK
  - =u1.equals(s1)    impl:  T=
  - =s1.equals(u1)    impl:  F=

- A potential fix (suggested by a student)
  #+begin_src java
SpecialUser
      @Override public boolean equals (Object obj) {
      if (!(obj instanceof SpecialUser)) return super.equal(obj); //obj.equals(this)
       return super.equals(obj) && ((SpecialUser) obj).id == this.id;
      }

  #+end_src

