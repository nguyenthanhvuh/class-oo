Type-Checking or Type-Safety


Greyhound extends Dog extends Animal

Dog f(dog d){
 ...
 return g(d);
}

What is the signature of g?

T2 g(T1 x)

T1 :  Dog or Animal
T2:  Dog  or Greyhound




Greyground g (Greyhound x)  ?   NO (not TYPE-SAFE)
Greyhound g (Animal x)  ?   YES



Dog d =  Greyhound f(...)   
Animal a  = Greyhound f(...)








Inclass 5B

#+begin_src java
  class A:
      public void reduce (Reducer x)    
          // Effects: if x is null throw NPE 
          // else if x is not appropriate for this throw IAE
          // else reduce this by x

  class B:
      public void reduce (Reducer x) 
          // Requires: x is not null
        
          // Effects: if x is not appropriate for this throw IAE
          // else reduce this by x

  class C:
      public void reduce (Reducer x)   
          // Effects: if x is null return (normally) with no change to this
          // else if x is not appropriate for this throw IAE
          // else reduce this by x
#+end_src
        



B extends A.   Fail
Precondition Part:  B has stronger pre:  Fail
Postcondition Part: B has weaker post:  Fail  

-----------------------------------          
C extends A. 
Precondition Part: both have no preconds:  OK   
Postcondition Part:
- incompatible behaviors (a => b ,  b => a) :  Fails
- throwing NPE is stronger than return normally:  Fails
- return normally is better / stronger than giving an exception:  OK   
-----------------------------------          
A extends B.  
Precondition Part: OK, A has no precondition 
Postcondition Part: OK, A is stronger
OK, A == B

P        Q    (supertype)
 P'   Q'      (subtype)

P -> P'  -> Q' -> Q
P is stronger than P'
Q' is stronger than Q

-----------------------------------          
C extends B.  OK
Precondition Part: OK,  C has no precondition so weakest 
Postcondition Part:
- same postconditions (because of B's precond forbidding null) OK
- C's post is stronger (because it handles more cases)  OK
-----------------------------------                    

A extends C.
Precondition Part: none has precond OK
Postcondition Part: A is stronger OK
A is weaker :  Fail
-----------------------------------          






Liskov Substitution Principle (LSP)

If B is a subtype of A, B can always be subsituted for A

- B extends A  (B is a subtype of A  ,  A is a supertype of B)

- foo(A) =>  foo(B)


B should be more preicse than A,  strengthen properties of A
- if A has some N methods,  B will have those methods,  B can have extra ones,  B overrides those N methods
- An overriding method must have a stronger (or equal to) specification the the original method of A.
- Precondition (requires)
- Postcondition (effects)
- Specification: Precondition => Postcondition (partial correctness specification, total)    
- A's original method ~foo~   ~p => q~
- B's ~foo~:   ~p' => q'~ 

- more requires,  more preconditions

 ~p'~ has more constraints/requires than ~p~, then  ~p'~ is stronger. 


p' is stronger than p  ,     p' => q'  is stronger or weaker than p => q ? 


p -> q

p' -> q


p' -> p   DOES NOT MEAN p' -> q =>  p -> q


p -> q =>  p' -> q


1. WEAKEN the precondition p' of foo in B (i.e., make the precondition p' of B foo weaker than the precondion p of A's foo) (and keep the postconditions of both the same)

p -> p'  MEANS (p' -> q) -> (p -> q)

weakening the precondition of B's foo, allows B's foo to deal with MORE inputs than A's foo, thus B's is "better" or stronger than A's.

OR
2. STRENGTHEN the postcondition of foo in B (i.e., make the postcondition of B's foo stronger than A's foo) (keep the preconditions of both the same)

q' -> q  MEANS (p -> q') -> (p -> q)

   
A's foo return some animal , and B's foo return a cat  ,   thus B's foo is stronger than that of A



if A has a function
#+begin_src java
  A_foo(int x){
    //requires x as an integer
    //effects: returns a positive int
    }

  B_foo(int x){
      //requires x as a postive integer :  BAD (stronger precondition)
      //effects:  return an integer:  BAD (weaker postcondition)
    }
#+end_src




A:
foo() returns animal


B:
foo() returns a mamal


class Shape

class Triangle extend Shape




just types, then the Compiler will automatically checks and enforces LSP for us

T1' extends T1
T2' extends T2

--- contravariance and covariance
supertype       T1 foo (T2 x)
subtype         T1 foo (T2 x)
                   foo (T2' x)   #would violate Liskov principle 




T1x.foo()

T1'x.foo()


bar(T1x)
bar(T1'x)














































<2021-10-12 Tue>

Liskov Substitution principle

-  If B is a subtype of A,a B can always be substituted for an A

- B is permitted to strengthen properties and add properties
  – Fine to add new methods (that preserve invariants)
  – An overriding method must have a stronger (or equal) spec
B is not permitted to weaken a spec
  – No method removal
  – No overriding method with a weaker spec

Constraints on methods
– For each supertype method, subtype must have such a method
  • Could be inherited or overridden
Each overriding method must strengthen (or match) the spec: –
   Ask nothing extra of client (“weaker precondition”)
      - Requires clause is at most as strict as in supertype’s method
      -  Guarantee atleast as much(“stronger post condition”)
         • Effects clause is at least as strict as in the supertype method
         • No new entries in modifies clause
         • Promise more (or the same) in returns clause
         • Throws clause must indicate fewer (or same) possible exception types

*TYPE*
      Contra vs co-variance
supertype    T1 foo(T2)
subtype      T1' foo(T2')
      T2' is supertype of T2 (as T2' is weaker, contravariance)
      T1' is subtype of T1 (as T1 is stronger, covariance)

class A{
   A foo(A x);
}

class B extends A{
   A foo(B x); // Bad, strengthening precond
   B foo(A x); // OK,  strenthening postcond
   A foo(Object x); // OK , weakening precond
}
      
Object o = new Date() ;// OK,   new Date() returns a Date() which is stronger than Object
Date d = new Object(); // Not OK, compile time error 

dog a = ..
dog b = f(a)


dog f(dog d):
   ...
   return g(d)


can f returns greyhound ?  YES,    
can f returns animal ?  NO

can f takes greyhound ?  yes
can f takes germanshephard? yes

g: animal -> greyhound



*SPECIFICATION*
- Any property (e.g., invariants or specification) guaranteed by supertype must be guaranteed by subtype
  – The subtype is permitted to strengthen & add properties
  – Anything provable about an A is provable about a B
- No specification weakening
  - No method removal
  - An overriding method has
    - a weaker precondition:
      - cannot ask anything extra more from the client
      - if super_pre  is x < 5,
        - then sub_pre can be x < 4 ? no, bc x<4 => x<5
      -  then sub_pre can be x < 10? yes, bc x<5 => x<10
    - a stronger postcondition:
      - give result at least as strong as the overriden one


-supertype has a method f that takes in an int, and returns a positive int (e.g., absolute)
-subtype overrides f and
  - take positive int:  so strenghthen precond, this is bad because what used to work with negative is now broken
  - returns an int: so weakening postcond,  also bad because the return should be positive int, but now could return a neg



  



https://www.youtube.com/watch?v=PZlD39cd4Wk


Counter vs Counter2:

2 methods in Counter
Also 2 in Counter2 (get is inherit)
precondition: OK,  same (both True)
postcondition: NOT OK double doesn't make it bigger (incr), so this is not at least stronger than post of Counter.  (if we have some precondition saying this >= 0, then we are OK)




Method rules
- Subtype has all methods from supertype and more
- Client only has access to the methods (overriden or extra) of the subtypes, they cannot access methods of the supertype directly     

- Subtype Precondition:
  - can be weaken than supertype precond
    - i.e, ~presuper -> presub~
  - e.g., supertype precond : x > 5
  - subtype precond,  x > 4   (x > 5 => x> 4)
  - 

- Subtype Post:
  - can stregthen supertype post
    - i.e., ~presuper & postsub => postsuper~ 
    


In-class 5B

B extends A:  fails
Precond:  BAD
Post: really doesn't matter, already fail pre

C extends A: fails
Precond: Ok, no precond for both
Post: BAD,  supertype A does more (e.g., return NP when x is null)

A extends B: OK
precond:  OK,  A has no precond
post: Ok, A is stronger, throws exception (actually they are the same if we consider the precond of B)

C extends B: OK
precond: OK, C's precond is arguebly weaker
post: Ok, same post


A extends C: OK
precond: OK, none has precond
postcond:  A post is stronger if we consider returning exception is stronger.  But not OK if we reason that in C we expect a return but in A we don't get anything.
We can also say the postcondition is not compatible,  neither one is stronger or weaker,  so in that case it also not satisfies the requirement that sub post has to be stronger than super post

---

In-class 5A

<2021-10-04 Mon>


Iterator 

List<String> list  = new List<>();

list = [bat, cat, dog] ;

Iterator<STring> itr = list.iterator();   // iter = [b,c,d]

itr.next();    //return b ,   iter = [c,d]  so iter's contents can be stored in a STACK ADT 
itr.next();   // return c ,   iter = [d]
iter.hasNext(); return True,  iter =[d]
iter.next(); //return d ,   iter = []
iter.hasNext(); return False,  iter =[]
iter.next(); // raise Exception NSEE



next()
hasNext()
prev()
hasPrev() 

Iterator<STring> itr = list.iterator();     // itr.X = [b,c,d] itr.Y = []
itr.next(); // return b ,   itr.X = [c,d]   itr.Y = [b]
itr.next(); // return c ,   itr.X = [d]     itr.Y = [c,b]
itr.prev(); // return c,    itr.X = [c,d]   itr.Y = [b]
itr.prev(); // return b,    itr.X = [b,c,d] itr.Y = []
itr.prev() ; // raise NSEE ...


Iterator<STring> itr = list.iterator();     // itr.X = [b,c,d],  itr.nextCalled = False
itr.next() ;  // return b ,   itr.X = [c,d],   list = [b,c,d],  itr.nextCalled = True
itr.next() ;  // return c,   itr.X [d],  list = [b,c,d], itr.nextCalled = True

itr.remove(); //   itr.X = [d],  list = [a, d],  itr.nextCalled = False
itr.remove(); // raise ISE


public class Period {              
    private final Date start;
    private final Date end;

    /**
     * @param start the beginning of the period
     * @param end the end of the period; must not precede start
     * @throws IAE if start is after end
     * @throws NPE if start or end null
     */

    public Period (Date start, Date end) {
        if (start.compareTo(end) > 0) throw new IAE();
        this.start = start; this.end = end;  // Question 1
    }
    public Date start() { return start;}    // Question 2
    public Date end()   { return end;}      // Question 2

}


public class MyMaliciousClass extends Period{
    private Date myDate = new Date(0)

@override public Date start(){
    if (itsTime()){
        return myDate;  // this is mutable !
    }
    else{
        return super.start()
    }
}


public class LoanProvider{
    Period p;

    public LoanProvider (Period p, other stuff){
        this.p = p ; // no defense copy, Because Period is supposed to be immutable 
    }
}


Period m = new myMaliciousClass(); 
LoanProvider lp = new LoanProvider(m, ...) // will have start from myClass

















<2021-09-27 Mon>


F
F'

F == F'    F => F'  && F' => F


F =    x >= 5  && True && x >= 4
F' =   x >= 5  && x >= 4
F'' =  x >= 4  not correct
F''' = x >= 5

F = i >= 0 && N >= i
F' =   N >= 0

(i >= 0 && N >= i)  =>  N >= 0
N >=0  =>  (i >= 0 && N >= i)    (N=5,  i = 100)




(x >= 5 && x >= 4)   =>   x >= 4     TRUE
x >= 4   => (x >= 5 && x >= 4)   ? x = 4 
4 >= 4  =>  4 >= 5 && 4 >= 4
True =>  (False &&  True)
True =>  (False)

False


(x >= 5 && x >= 4)   =>   x >= 5   TRUE
(x >= 5)  => (x >= 5 && x >= 4)   TRUE 


"3-SAT" 

Convert Java/C++/Rust  => a (BIG) formula => 3-SAT (Verification condition)

Theorem Proving (SAT Solver,  SMT solver)


assignment
loop ()
...


NP-COMPLETE


Objects/ Classes

- analyze / verify method in ISOLATION
- M1,  M2, M3   ...
- M1,  M2,  M3   ... will not scale 

- Rep Inv

  IntSet, Poly

  Binary Tree
  - if a child != null (not leaf), then it will have 2 children
  - if a child == null (leaf), ...
  - constructor ,  ...  =>  valid BT (rep-inv will hold)
  - delete/add ,     => valid BT

  Binary Search Tree
  - content of the left child (node)  <= content of parent (node)
  -


class BinSearchTree:
    bool is_valid(...){
       ... 
    }
    
  
#+begin_src java
  public class Members {
      // rep-inv1: members != null

      // rep-inv2: members != null & no duplicates in members

      List <Person> members;   // the representation

      //  Post: person becomes a member
      public void join (Person person){
        if (!members.contain(person)){
          members.add(person);
        }
      }

      //  Post: person is no longer a member
      public void leave(Person person) {
        //rep-inv2 
          members.remove(person);

      }

    ...
  }

#+end_src

for each method : join and leave 
1. does it satisfy rep-inv1 ?  
   join: yes
   leave: yes
   
2. does it satisfy rep-inv2 ?
   join: no
   leave: yes

3. does it satisfy postcondition ?
   join: yes
   
   leave: NO if do not assume rep-inv2 (or no assumption)
          YES if do assume rep-inv2

3b.  if a method DOESNOT satisfy given rep, then do we need to check if satisfy the postcondition?
     no, if rep inv is broken, the code is wrong,  no need to check anything else
    
4. if the method doesn't method a rep inv,  modify the code so it does





abstract function:  toString()

Poly:


toString:  internal/concrete -> abstract  5x^4 + 3x^2




















Verifying methods class
- when analyzing a method, do not attempt to analyze other methods and their interactions
- will not scale
- should analyze each method in isolation
- use rep inv !

- Does the method establish and maintain rep-inv  ?
  - similar to inductive invariant (hold before and preserve through loop)
  - constructor: return obj satisfies the repr
  - mutator:  assume repr, maintain it 

Example :  Members.java

#+begin_src java
  public class Members {
      // Members is a mutable record of organization membership
      // AF: Collect the list as a set 
      // rep-inv1: members != null
      // rep-inv2: members != null & no duplicates in members

      List <Person> members;   // the representation

      //  Post: person becomes a member
      public void join (Person person) { members.add(person);}

      //  Post: person is no longer a member
      public void leave(Person person) { members.remove(person);}

  }
#+end_src
  - does method maintain rep-inv ?   does it satisfy the contract?
    - if the first one fails,  no point to do the rest

  - ~members != null~
    - join:  yes,  no assignment to members, we just add things to it,  so if it was not null when we enter the method then not null when we exit the method.
      - yes, satisfy the contract, because person becomes a member
    - leave: yes, maintain inv;
      - no, does not satisfy the contract (we haven't looked at or assume the duplicate repr inv)
      - to "repair" this,  we can do something like
        while (members.contains(person)){
           members.remove(person);
        }
      
  - ~members !=null and no duplicates~  (stronger)
    - join:  NO,  doesn't check if input person already a member. Counterexample ?
      - since doesn't preserve the repr, so don't care about contract 
      - repair: check if a person already a member, 

        
    - leave: yes, maintain repr inv
      - yes, satisfy the contract (using the repr,  person only in the list no more than once)


- Poly example
  #+begin_src java

    public class Poly {
    // Polys are immutable polynomial c0+c1x + c2x^2 + ..
    
        private int[] trms;
        private int deg;

        // Effects: returns the degree of this
        public int degree() {
           return deg;
        }
  #+end_src
  
<2021-09-20 Mon>
* Lecture 4-1



Verification

- Testing
  - Dynamic Analysis: analyze the program runs
  - Run the program on some inputs ...
  - Strength: Fast, does not need to analyze complex code , ...
  - Weakeness:  could miss corner cases, ...
    
- Verification
  - Static Analysis: analyze the source code (AST, Bytecode ...)
  - Do not run the program 
  - Strenghths: attemp to reason about the program on *all* possible inputs
  - Weakenesses: slow, infeasible, analyze the program source code
  - For certain domains or applications, failure is not an option
    - Airbus :  ASTREE
    - NASA:  ...
    - Facebook
    - Amazon AWS: Amazon Formal Methods
    ... 
    
- Facebook INFER
  - Verification tool 
  

"Program testing are used to show the presence of bugs, but never to show their absence"  -- Dijkstra 1972 

- Hoare Logic
  {P} S {Q}    : Hoare tripple
  - Read:  assume P holds,  if S successfully executes, then Q holds
  - (Sir) Tony Hoare
    - Quick sort
    - NULL Pointer (billion dollar mistake)
    - Dining Philosopher / Monitor

{True} x := 5; {x=5}   // strongest postcondition
{True} x := 5; {True}
{True} x := 5; {x >= 0}
{True} x := 5; {x >= 5} // x=5 OR x=6 or X... 


{x == y}  x:= x + 3 {y = x - 3} // strongest condition
{x == y}  x:= x + 3 {x >= y}
{x == y}  x:= x + 3 {x > y}

{x > -1}  x:= 2*x + 3  {x <= 3} // X 
{x > -1}  x:= 2*x + 3  {x >= 1}    x = 1 OR x= 2 or X=3 ......  

{x > -1}  x:= 2*x + 3  {x >= 3} // STRONGEST post condition

x = 0  ...  x = 3    x >= 3
x = 1  ...  x = 5
x = 2 ...   x = 7
.....

{x==a}  if x < 0: x = - x {x == |a|}
{True}  if x < 3: x = 10 else: x = 20  { x == 10 || x == 20 }

{False} x := 3 {x != 3}
{False} x := 3 {False}
{False} x := 3 {x= any int}

{x < 0}  while(x!=0) x:= x - 1 {X < 0}
{x < 0}  while(x!=0) x:= x - 1 {ANYTHING}

Partial Correctness: 
- Talk about compilers if have time   
  - assume P holds,  *if* S successfully executes, then Q holds


{True} x := 5 {x=5 or x= 6 or x > 6}  *valid*
{True} x := 5 {x > 6}  *invalid* 
{x == 5}  x += 2  {x < 7}  # x == 7 does not imply *x < 7*


{x < y} z:= x/y  {z < 1}   *Invalid* y=0 
{x = 0} z:= x/y  {z < 1}   *Invalid* x=0, y=0 
{y != 0} z:= x/y  {z < 1}  *Invalid* x = 2 , y =1  
{x < y & y != 0} z:= x/y {z <1} *invalid*   x=-2,  y=-1

{0 < x < y & y != 0} z:= x/y {z <1} *valid*   weakest precondition 
{x = 1 & y = 2} z:= x/y  {z < 1}  *Valid*  
{x = 2 & y = 4} z:= x/y {z <1} *valid*



** Verification using Hoare logic
- To prove ={P}  S  {Q}=  is valid,   we check if  ~P =>  WP(S, Q)~
  - `WP`: a function returning the weakest precondition allowing the execution of S to achieve Q

- S is an ASSIGNMENT statement 
  - WP(x := E, Q) = Q[x/E]
    WP(x := 3, {x + y = 10}) =  3 + y = 10  =   y = 7
    
  - {y==7} x := 3 {x + y = 10}

    WP(x := 3, {x + y > 0) =  3 + y > 0  = y > -3
  - {y > -3}  x := 3 {x + y> 0}

- S is a LIST of Statements
  - WP(S1; S2; S3 ...;  Q)  = WP(S1, WP(S2;S3;.., Q))
  - wp(x:=x+1; y = y*x, {y=2*z})

    {y*(x+1)=2*z} x:=x+1; {y*x=2*z} ; y := y*x, {y=2*z}

    wp(y:=y*x, {y=2*z}) =  y*x=2*z
    wp(x:=x+1, {y*x=2*z}) = {y*(x+1)=2*z}

    WP(x:=x+1, y=y*x, {y=2*z}) = WP(x:=x+1,WP(y=y*x, {y=2*z}))
                               = WP(x:=x+1, {y*x=2*z})
                               = {y*(x+1)=2*z}

- S is CONDITION
  wp(...)
  
- S is a LOOP                               
  - {x <= 99 or x = 100} while (x < 100) x = x+ 1; {x=100}
  - {x <= 100} while (x < 100) x = x+ 1; {x=100}
  - WP(while, Q) = loop invariant of the while loop

     - *Loop invariant*: captures the meaning of the loop (manually provided by you)
        -  property that holds when the loop entered 
        -  is preserved after the loop body is executed  (inductive loop invariant)


#+begin_src java
  {N >= 0}

  {0 <= N}
  i := 0 ;

  {i <= N}//wp for the while loop below wrt to Q= i == N using i <= N
  {False} //wp for the while loop below wrt to Q= i == N using N >= 0

  //LOOP INV:  i <= N
  //LOOP INV: i <= 0  # NOT LOOP INV
  //LOOP /inv : i>=0 
  //LOOP INV :  N >= 0
  //LOOP INV:  TRUE

  while(i < N){
      i := N;
  }

  {i == N}

#+end_src

- WP(while[I] B do S,  {Q}) =
   1. I and
   2. (I &b) => wp(S,I)
   3. (I &!b) => Q

- using ~i <= N~ as loop invariant to prove program
  - wp(while[i<=N] i < N do i:=N, {i == N}) =
    1. ~i <= N~
    2. ~(i <= N & i < N)   => wp(i:=N, {i<=N})~
       ~i < N  =>   N <= N ~
       ~i < N =>  True~
       ~True~
       
    3. ~i <= N & !(i<N) => i == N~
        ~i == N => i == N~
        True
        
    =  ~i <= N~

~wp(while[i<=N] i < N do i:=N, {i == N}) = i <= N~


wp(i:=0; {i<=N}) = 0 <= N

P => wp(...)
N>=0  => 0 <= N

- using ~N >= 0~
- wp(while[N >= 0] i < N do i:=N, {i == N}) =
  1. ~N >= 0~
  2. ~(N >=0 & i < N) => wp(i := N, N >= 0)~
      -   ~(N >=0 & i < N) => i >= 0~
        
  3. ~N >=0 & !(i<N) => i ==N~
     ~(N >= 0 & i >= N) => i == N~
     ~i>= 0  => i == N~
     ~False~
 =  False  
 

N >= 0 => False   N= 5    = True => False     !True or False  = False or False  = False
False 

Demorgan Law

a => b   ==  !a or b


!a or True  == True
!a or b
!(i == N)  or (i==N)  = True

a and b and c

b == true  =>  a and c















  
  

* Lecture 4
**  Reflection
   - Invariants
   - Invariants vs Precondition
   - toString:  abstraction function that takes internal representation (e.g., arrays, vectors) and abstract it for the client (e.g., polynomials)
   -  Correctness
     - Testing vs Verification
     - Dijsktra
     - Satisfy contracts (specifications)
** Verification
   - Verification vs Testing: very different
   - Testing: correct over sample inputs
     - number of inputs is infinite ,  so can only sample a small finite set
   - Verification: the implementation is correct with respect to the specification.
     - Correctness: Mathematical definition, a proof
     - Theorem proving ..

** Abstract Function and RepInv
      - Abstraction Function:  maps rep internal data to the astract object
        - e.g., Liskov's PolyClass (uses arrays)  => mathematical polynomial objects
        - =toString= is often used as an abstraction function
      - Rep invariant:
        - Example:  binary tree (2 children),  binary search tree (binary tree and lc <= rc),
        - IntSet:
          #+begin_src java
            // c.els ≠ null &&
             // (all elements of c.els are integers)
            // for all integers i. c.els[i] is an Integer && 
            // for all integers i , j. (0 <= i < j < c.els.size ⇒
            // no duplicates in c.els
            //     c.els[i].intValue ≠ c.els[j].intValue )
          #+end_src
        - =repOK= use to check rep invariant (used in various constructors and methods to check if the rep invs are establish or preserved)

          
** OO Verification
    - Main keys to verification
      - verify each method one by one,  once verified wrt to the contract,  we can now just use the contract
   
   - establish or maintain rep invariant
          - constructor: establish rep invariants
          - mutator:  maintain/preserves the rep invariants
          - inductive :  constructor(base) inductive case (muttator)
      - Contract:
        - given rep inv as assumption, given preconditions as assumptions, does postcondition hold?

    - Verification diagram
      Abstract Stage (Poly, Set)

        
<2021-09-13 Mon>

Lecture 3
RECORD
HW2:
- Pick some volunteer  (example code: https://www.youtube.com/watch?v=dacJdCgm-dM  5:31)

TEAM 2

- should not have checks or code for precondition (it’s assumed )
- contracts format
    - javadoc (preferred)
    - Liskov (effects, modifies etc)
- Report all errors at once or one by one 
    - no standard
    - one by one (compilers style)
- Reflections
    - Immutable: Many mention threat safe as an advtange of immutable;  also easy to compare
    - Mutable: may be faster, doesn't have to recreate the whole thing when changing something

*immutability over mutability?*
1. Prevents corruption of objects and the data they hold as the object cannot be updated.
2. Data is predictable. Once created cannot be modified.
3. Comparing two immutable objects is easier. We can just compare the reference of the object.
4. Immutable objects are thread safe and is useful to share data in multithreaded applications.
5. Testing: Testing will be easy for immutable objects.

*o mutability over immutability?*
1. Mutable objects can be used when we do not know the actual size of the input data. Size can be
variable which is an advantage of mutable objects over immutable objects.
2. Objects can be modified post its creation. This memory efficient as we just update the reference
instead of creating a new object.
3. Mutable classes provide methods to update the data.


# - Data abstraction
#     - Creators: create objects (constructors are special kinds of creators)
#     - Producers: (???)
#         - create objects of their type based on existing objects
#         - typically used in immutable data types
#     - Mutators:
#         - modify objects of their type
#         - typically used in mutable data types
#     - Observers
#         - 
# - Disadvantage: Performance
#     - typically approach:  provide both Immutable and muttation. 
#     - E.g., Java library:
#         - String (Immutatble)
#         - StringBuilder (companion mutable class)

- Poly.java :  show the code
    - What is a polynomial ? Ask student
        - Should describe high level (client perspective), not implemented
        - Wikipedia: expressions consisting of terms, which are variables and coefficients
        - Also involve operations such as mult, addition, subtraction, non-neg int exponentiation
    - How to implement polynomial?  
        - Coef:  integer coef
        - Exponent:  non-neg ints
        - 1 variable (just x) 
    - Poly code
        - Effects (Poly constructor):  would it be ok if we say “initialize array to 0 and such”,  no it’s wrong,  it’s implementation level,  not specification 
        - Think about this as “if I change my code,  would the specification still hold?”  If yes, then specification is good, otherwise,  incorrect 
    - ADD:
        - why so ugly?
        - Because she has a constraint such that doesn’t trailing zeros …
        - last thing in array is a non-negative coefficient
- In class exercise: 2A QUEUE 
    - Queue is currently mutable
    - convert it to immutable
    - ALSO put/change the contracts on both the ORIGINAL (mutable version) and immutatable version
    - 30 mins
    - 
   #+begin_src java

     public class Queue <E> {

         private List<E> elements;
         private int size;

         public Queue() {   
             this.elements = new ArrayList<E>();
             this.size = 0;
         }

         public void enQueue (E e) {
             elements.add(e);
             size++;
         }

         public Queue<E> enQueue_producer (E e) {
             Queue<E> queue = new Queue<>();
             queue.elements.addAll(this.element);
             queue.elements.add(e);
             queue.size = this.size + 1;
             return queue;
         }

         //Effect: remove and return the front element of queue (this)
         //Modifies: contents of queue
         //@throw ISE if queue is empty  (DO NOT USE SIZE)
         public E deQueue () {
             if (size == 0) throw new IllegalStateException("Queue.deQueue");
             E result = elements.get(0);
             elements.remove(0);
             size--;
             return result;
         }

         //Effect: return a queue that is like this but without the front element
         //Modifies: none 
         //@throw ISE if queue is empty  (DO NOT USE SIZE)
         public Queue<E> deQueue_producer () {
             if (size == 0) throw new IllegalStateException("Queue.deQueue");

             Queue<E> queue = new Queue<>();
             queue.elements.addAll(this.element);
             //E result = queue.elements.get(0);
             queue.elements.remove(0);
             queue.size--;
             return queue;//return result


         }

         public boolean isEmpty() {
             return size == 0;
         }

     }

     public static void main(String [] args){
         Queue <String> q = new Queue<>();
         q.enQueue("cat");
         q.enQueue("dog");
         q.deQueue();// return cat 
     }
   #+end_src


*** Invariants:
**** definition    
**** Invariant locations :
     - at the end,  post condition 
     - loop invariant
       - hold at the loop entrance
       - preserves through the loop body
         
     #+begin_src 
      {N >= 0}

      i = 0
      while (i < N):
         i++

# loop invs
# i < N   # not a loop invariant because at first loop entrance, when N = 0  ,  i is NOT < N
# i >= 0 # YES , loop inv
# N >= 0   #  YES, loop inv
# i <= N   # YES, loop inv 

#  N >= -10
#  N >= -11000

     #+end_src



AF:  mapping from (concrete state) representation state to abstract state  (often many to 1,  why, because abstractions forget details)

    e.g.,  (2, [5,0,3])  ->  5 + 3x^2
           (2, [5,0,3,0])  -> 5 + 3x^2   ... but Liskov's implementation not allows this

     rep-inv: implementation details !!!! talk about the specific representation (programmer/Liskov's choice)
     
     #+begin_src txt
     trms != null
     terms.length >= 1
     deg = trms.length - 1
     deg >= 0  =>  c.terms[deg] != 0

     #+end_src

     
Option to 
- Multiple Share screen
- Allow people to join to break out rooms

<2021-08-26 Thu>
** Quiz:
   binary search
   - write pre/post/modifies
   - total vs **

partial Reflection:
   - precondition (purely specification):  undefine behavior
   - exception (more implementation): turn undefine behavior into defined ones
   - checked exception (i.e. these that you should explicitly catch or rethrow):
     - Block: To summarize, throw checked exceptions for recoverable conditions and unchecked exceptions for programming errors. When in doubt, throw unchecked exceptions.
     - Liskov:
       - You should use an unchecked exception only if you expect that users will usually write code that ensures the exception will not happen, because
        • There is a convenient and inexpensive way to avoid the exception.
        • The context of use is local.
       - Otherwise, use checked

Otherwise, you should use a checked exception.
     Most prefer Bloch's ...
   - security:
     - some group mention about parseHttpRequestLine ..
     - fuzzing : generating weird, unexpected inputs ... hoping for weird/undefined/unexpected behaviors that can be exploited

** Contract
   (powerpoint)
   - {P} S{Q}:  Hoare tripple
     - P , S, Q
     - assume terminaton
     - customer (client) needs to establish P
     - Implementer (service) assume P
     - Implementer needs to establish Q (assume P)
     - Customer assumes Q
     - Bug: if both client/server do their job: good
     - if precondition is not satisfied, customer is wrong (client has bug)
     - if postcond is not satisfied, implementer is wrong (service has a bug)

   - sqrt example:
     sqrt(x):
        pre:  x >= 0
        what if x is negative?
        post:  r*r = x +/ epsilon

   - Precondition:
     - as weak as possible  (True is the weakest)
     - but lots of work, so Server prefers STRONGER (e.g., sqrt example:  if pre is weak/nothing, then SERVER has to handle more corner cases,  if if pre is stronger (e.g., x >= 0) , then SERVER doesn't have to handle as much
       
   - Postcondition:
     - as strong as possible  (False is the strongest)
     - but lots of work !  so Server prefers WEAKER post conditions (less things to do),  e.g.,  if post for sqrt is just return a number, then very easy


     
** Abstraction
   - focuses on what (not how)
     - signature: formal parameters, return types, etc
     - isPrime:  detemrine if arg is prime is important ,   how this is determine is irrelevant
** Specifications/Contracts
   
   - Informal (English, remove example): easier to write but vague
** Signatures/Header
   - requires/modifies/effects   in comments
   - requires/precond: partial vs total  (partial: only for certain input so have require/preconditions,  total: for all correct type inputs, so precondition is TRUE, i.e. no precondition/require clause)
   - modifies: input modification -> side-effect
   - effects/postcond:  under assumption that requires are satisfied  (x' or x_post)
   - Precondition: weakest is best,  nothing (i.e., True) is even better
   - weaker vs stronger

** Implementation
   - Adhere to specifications
   - weaker vs stronger  , e.g., if specification says return a number, then always return 3 is ok.  but if specification says return an odd number, then cannot return any number.
   - 
     
** Exception (Bloch item 69)

** Checkvs vs Unchecked (Bloch item 70)
   - check exception:  recoverable
     - force the caller to handle the exception
     - IOException:  file not found,  well probably can have a backup , default one       
   - unchecked exception:
     - recovery not possible
     - NPE: if you pass me a null pointer, and I try to dereference it, well then I should get NPE.  Not much I can do to turn a null pointer into a non-null pointer.  
       



** Item76: Strive for Failure Atomicity
   - failed method invocation should leave the object in the state that it was prior to the invocation
   - ways to achieve this
     - design immutable objects (tuples, string vs arrays, set)
       - performance, easy to reason about that (will spend more time later)
     - check the inputs
     - order the computation : parts that fail come before modification
     - write recovery code:  allow objecet to roll back its state
     - perform the operations on temporary copy of the object



** WARNING: will make people share your answers ...
   Look at Javadoc for ArrayList
   

** in class 1A

#+begin_src java
public static List<Integer> tail (List<Integer> list) {

    // REQUIRES: ???
    // EFFECTS:  ???
  if(list.size() == 0) throw new IllegalAccessException() ..
    List<Integer> result = new ArrayList<Integer>(list);
    result.remove(0);
    return result;
}
#+end_src


https://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html


- what does it do?

- write partial specs for happy paths (where it works) ,
  A: last 2 cases
- rewrite to be total.  A: add addition things to postconditions so that we can remove preconditions
  @throws NPE if list is null
  @throws IOOBE if list is empty (because of remove in javadoc)

  
- IOBE :  does not match the exception (if list is empty, throw IOB)

- instead of IOBE,  throw IllegalAccessException

- no need to do nullpointer exception because .size() will throw   

  
** In class 1B (20 mins)



-----


- turn on recording

- introducing myself (in NE, taught compilers etc)

- SCHEDULE
  - give plenty of time to read the assignment,  might have few pages, but lots of stuff in there


** <2021-08-23 Mon>
   - Correctness:
     -- specification  or contract ...
     -- code is correct if it satisfies the contract
     -- if you give it no contract, well then anything would be correct
     -- so you want strong and precise contract

     
     
   - Pre/Post conditions

   - sort list  : 
     - preconds:  input is a list of *comparable* items
     - postcond:
       - output is sorted
       - output is a permutation of data input






   - =void remove()=
     Removes from the underlying collection the last element returned by this iterator (optional operation). This method can be called only once per call to next(). The behavior of an iterator is unspecified if the underlying collection is modified while the iteration is in progress in any way other than by calling this method.

   Throws:
   - UnsupportedOperationException - if the remove operation is not supported by this iterator
   - IllegalStateException - if the next method has not yet been called, or the remove method has already been called after the last call to the next method


   List<String>l = ... // [cat, dog, mouse]
   Iterator<String> itr = l.iterator();

   itr.next();    // cat
   itr.next(); // dog


   itr.next();  // cat
   l.add("elephant");
   itr.next();  // anything can happen, depends on Java implementation,  probably return an exception (Concurrent modification)

* INCLASs object   
  - Group break out , do in-class ,  45 mins
  - turn recording OFF

  - after break,  turn on recording



