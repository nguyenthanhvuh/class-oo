#+TITLE: SWE 419 Notes
#+OPTIONS: ^:nil toc:1

#+HTML_HEAD: <link rel="stylesheet" href="https://dynaroars.github.io/files/org.css">
#+HTML_HEAD: <link rel="alternative stylesheet" href="https://dynaroars.github.io/files/org-orig.css">

* Lecture 12: Review and Eval

- problems with grades -> contact Advait immediately (do not wait until the final exam)
- final exam time and format
- final exam topics


  NO COLLABORATION OF ANY KIND
- LOOK at in-class exercise

*** ~5 questions

- specifications
  - total vs partial contracts
  - repr invs
  - know when the code violates/satisfies contracts
    
- Liskov principle of substitution
     
- Hoare logic
  - pre/post conditions
  - weakest precondition rules
  - verification condition (precondition => wp)
  - sufficiently strong loop invariants
    
- Unit Test/Theories
  
- in class/group practice

In-class exam practice (Stack implementation)


[1,null]  .size = 1 

[1] 

   
[1,2,3,4,5,6,7,8,9,10]      .length = 10,  size=10
[1,2,3,4,5,6,7,8,9,null]    .length =10,  size = 9

toString()  ->   [1,2,3,4,5,6,7,8,9,null]   //incorrect (because toString was using .length instead of size)

contents of elements are not null :  //not a repr 
contents of elements from 0 to size-1  are not null  //is a repr

*Sols*

1. Contract for push
   
// Effects: If the Object is null, throw NPE
Expand the array if more space is needed
add Object e to the top of the stack (elements)  

^^^ too detail:  specific to *array*, increase capacity mainly due to the use of array  (imagine someone else try to reimplement this, they might use a different data structure)


// Effects:  throw NPE if attempt to add a null element, else add element to the top of the stack  


// Modifies: elements, size  # don't go into implementation details,

// Modifies: this (or modifies the stack representation)

// Do we want Require (Precondition) ?  In this example, no need (code already include if e == null throw ... ).  In general, if you can, avoid having require/precondition ,  you want the weakest precond (i.e., nothing)

2. toString()

   code: incorrect: print the whole contents (.length);  in this implementation, we just just want contents up to size  and not elements.length (which outputs everything in the array)

   fix: print "stack" , chanbge from elements.length to size

3. repr inv
   1. elements != null   ... Correct

     
   - contents of elements are not null (NOT a Repr Inv, doesn't work for pop)
     size = 2 
     ["cat", "dog", null]

     
   2. 0 <= size <= elements.length()     # size != elems.length

   # The number of elements that are not null equals the size.
   
   3. If size > 0 then elements from 0 to size should not be null


4. Prefer ArrayList to Array
   If we use ArrayList,
   - pop() doesn't need to set elemennts[size] = null
   - don't even need a separate variable `size` to keep track of Stack size
   - ensureCapacity()  :  no need

5.  Argue pop() is correct (or not)?
   - correct =  satisfy repr and the contract
   - contract:

     //effects:  if this (or stack) is already empty, throw ISE
     //else remove the top of the stack and return it

     
6. pushAll:
   contract: if any element is null , then raise exception, otherwise, add everything to this (or the stack):  either successfull add everything, or don't add anything at all
   #+begin_src java
           public void pushAll (Object[] collection) {
               //check for null element
               for (Object obj: collection) {if obj == null throw NPE;}
               for (Object obj: collection) { push(obj); }
     }

   #+end_src
   //require: all elements are non-null

   //add vs addAll()

7. equals:

   - if elements is array, use size (cannot use equal because ["dog", null] != ["dog"])

     size = 1           size = 1
     ["dog", null]  ==  ["dog"]


   - if elements is arraylist, reuse .equals() ..


   - if need to do separate equal for array and arraylist, then also need to do for =hashCode=,
      for arrays: use  Bloch's recipe,   hash()*32 + ..
      for arrayList  use hashCode()


* Lecture 11: Testing/ Unit Testing

- Good testing:
  - high statement coverage
  - branch coverage
- Flakiness testing 
- Test oracle
  - E.g., post conditions
- Most developers would manual write tests
  - We want to automate the task of writing tasks

#+begin_src java
  //Calc.java
  public class Calc
  {
      static public int add (int a, int b)
      {
          return a + b;
      }
  }
#+end_src

#+begin_src java
  //CalcTest.java
  import org.junit.*;
  import static org.junit.Assert.*;

  public class CalcTest
  {
     @Test public void testAdd()
     {
        assertTrue ("Calc sum incorrect", 5 == Calc.add (2, 3));
     }
  }
#+end_src



** JUnit Theories
- *property-based* testing
  - E.g., ~forall x,y :  result = sum(x,y)~
  - ~for all stacks str == pop(push(str))~
    


JUnit Theories
#+begin_src java

    @RunWith(Theories.class)
    public class MyJunitTheories {

        @DataPoints
        public static int[] dataPoints() {
            return new int[]{
                    71, 82, 53, -1
            };
        }

        //For a and b where a,b > 0
        //(a+b)^2 = a^2+b^2+2ab 
        //a+b > a and a+b > b

        @Theory
        public void squareTheory(Integer a, Integer b){

            // (a+b)^2 (LEFT) = a^2 + 2*a*b + b^2 (RIGHT)
            // precondition:  a , b > 0
            // postconditions (properties):
            //  - LEFT == RIGHT
            //  - LEFT , RIGHT > 0
            //  - LEFT >= RIGHT
            //  - a + b > a
            //  - a + b > b
            //Below assume statement ensures that we are testing only positive numbers
            Assume.assumeTrue(a > 0 && b > 0);

            System.out.println("Running with Data points - " + a + " , "+ b);

            Double leftSide = Math.pow(a+b,2);
            Double rightSide = Double.valueOf(a * a + b * b + 2 * a * b);

            //postconditions
            assertEquals(leftSide,rightSide);
            assertTrue(a + b > a);
            assertTrue(a + b > b);
        }


        @DataPoints
        public static int[] dataPoints() {
            return new int[]{
                71, 82, 53, -1
            };
        }        
  }      
#+end_src

- 16 tests in total

  #+begin_src txt
-1,-1
53,53
82,82
71,71
71,82
82,71
82,53
53,82
53,-1
-1,53
71,53
53,71
71,-1
-1,71
82,-1
-1,82

7 would fail the precondition

16 tests would pass (7 failed the precondition and the other 9)

how many possible pairs(2) over 4 numbers?
- Not(2^4)
- 4^2  

how many possible tripplets(3) over 4 numbers?
- 4^3
- Not(3^4)  


k inputs,  n  =    n^k possible tuple of size k


#+begin_src java
      @DataPoints
       public static Point[] points = {
       null, //a
       new Point(2,2),  //b
       new ColorPoint(2,2,COLOR.BLACK), //c
       new ColorPoint(2,2 ,COLOR.RED) //d
       }; 
       
      @Theory
      public void testEqualsSymmetry(Object a, Object b) {  // can also use Point, but
         // symmetry
         // if (a==b) then  b == a   Version 1    a == b  ->  b == a
         // Version 2     a == b -> b == a  and   b == a ->   a == b

         assumeTrue(a!=null && b != null);
         
         if(a.equals(b)){assertTrue(b.equals(a));}  // TRUE
         if(b.equals(a)){assertTrue(a.equals(b));} // TRUE

         return true;


      @Theory
      public void testEqualsTransitivity(Object a, Object b, Object c) {  // can also use Point, but         
         // transivity

        assumeTrue(a!=null && b != null && c != null);
        if(a.equals(b) && b.equals(c)){
            assertTrue(a.equals(c))
        }
      }
      
#+end_src

- 16 tests (e.g.,        (a,b) ,  (a,c) ... 
- null, *  -> pass ;   *, null -> pass
- c.equals(d) =>  d.equals(c)     (c,d ) => test pass
     FALSE    =>  FALSE     =  TRUE
-  d.equals(c) =>  c.equals(d)
     FALSE   => FALSe      =  TRUE

-  b.equals(c)  = TRUE   c.equals(b) = > FALSE   // (b,c) => test fail


** Some common Testing techniques

- *Fuzzing* :  random testing (adversarial attack)
  - rfuwekjfsal;kj09234809234u0398fsJLKDFdxkfjlkdj

- *Mutational Testing*
  - evaluate / score test cases
  - mutate the program P -> P'
  - runs testsuite A on P'   ->   I found 3 mutations in P'   *better*
  - runs testuite B on P'    ->   I found 0 mutations  in P'  
  
- Stochastic techniques:  *Genetic Algorithm*
  - AFL: American Fuzzing LOP 



* In class 2 (MLO 1, 2, 3) [.5 hours] 

This is a JUnit theory exercise.

1. Write a JUnit theory that captures the symmetry property of the =equals()= method.
   1. Create =@DataPoints= from Bloch's =Point=, =ColorPoint= classes. So that we're all on the same page, create 1 =null= reference, 1 =Point= object and 2 =ColorPoint= objects.
   1. Given this set of data points:
      - How many combinations are considered by the theory?
      - How many combinations make it past the preconditions of the theory?
      - How many combinations make it to the postcondition of the theory? 
   1. What happens to this theory and the accompanying data points when favoring composition over inheritance?
1. Repeat the exercise for the transitive property for =equals()=.
1. Recall the =equals()= and =hashCode()= discussion in Bloch. Write a JUnit theory that encodes the consistency property between =equals()= and =hashCode()=.
1. Build a toy example that violates the theory. Fix the toy example so that the theory is no longer violated.
1. Consider the =Comparable= interface: what properties should be checked with theories?


*SOLUTION:*
#+begin_src java
      @DataPoints
       public static Point[] points = {null, //a
           new Point(2,2),  //b
           new ColorPoint(2,2,COLOR.BLACK), //c
           new ColorPoint(2,2 ,COLOR.RED)}; //d

      @Theory
      public void testEquals(Object a, Object b) {  // can also use Point, but Object is more general and just
          // symmetry
          // *if* (a==b) then b==a AND

          // if (b==a) then a==b
          //  a==b iff b==a

          // NOT correct : too strong
          // a==b AND b==a
          // a.equals(b) == FALSE  =>  b.equals(a) == FALSE

          assumeTrue(a!= null && b != null);

          if(a.equals(b)){assertTrue(b.equals(a));}
          if(b.equals(a)){assertTrue(a.equals(b));}

          //or , a shorter version
          assertTrue(a.equals(b) == b.equals(a));

          //# of tests = 4*4 = 16
          //# of tests passing the preconds: 9
          // fail preconds(null,null;  *,null, null,*)

          //passing tests
          // a,a
          // a,*
          // *,a
          // b,b
          // c,c
          // d,d
          // c,d because c.equals(d) == FALSE  == d.equals(c) == FALSE 
          // d,c because d.equals(c) == FALSE  == c.equals(d) == FALSE

          //failing tests
          // b,c  b.equals(c)  == T
          // c.equals(b)  == F
          // c,b  ....
      }

    @Theory
    public void equalsTransitivity(Object x, Object y, Object z){
        //(x.equals(y) and y.equals(z)) => x.equals(z)
        //if (x.equals(y) and y.equals(z)) then  x.equals(z)

        assumeTrue(x!=null && y!=null && z!= null);
        if(x.equals(y) && y.equals(z)){
            assertTrue(x.equals(z))
        }

        assumeEquals(x,y);
        assumeEquals(y,z);
        assertTrue(x,z);
    }


    @Theory
    public void equalsHashCode(Object x, Object y){
        //if(x==y) then x.hash == y.hash

      assumeTrue(x != null);
      assumeTrue(y != null);

      assumeTrue(x.equals(y));
      assertTrue(x.hashCode() == y.hashCode());
        
    }

#+end_src
>>>>>>> f70393f3d43828f207d1c04f19517629e7d87160


* Lecture 10
- Constructor must not invoke overridable methods

#+begin_src java
     public class Super {
         public Super() {m();}
         public void m() {
          //initialization code
          print("Super m");
         }

     public class Sub extends Super {
         private final Date date;
         public Sub() {
             //Super()
             date = new Date();
         }
         public void m() {
             //access date variable
             print("Sub m");
         }

     Sub s = new Sub();
     //"Sub m"
   ,#+end_src java


   - Favor composition over inheritence

   ,#+begin_src java 
   public class InstrumentedHashSet<E> extends HashSet<E>    {
           // The number of attempted element insertions
           private int addCount = 0;
           public InstrumentedHashSet() { 	}
           public InstrumentedHashSet(int initCap, float loadFactor) {
                   super(initCap, loadFactor);
           }
           @Override public boolean add(E e) {
                   addCount++;
                   return super.add(e);
           }
           @Override public boolean addAll(Collection<? extends E> c) {
                   //addCount += c.size();
                   return super.addAll(c);
           }
           public int getAddCount() { 	return addCount; }
   }

  //client code
  InstrumentedHashSet<String> s = new InstrumentedHashSet<>();
  s.addAll(Arrays.asList("Snap", "Crackle", "Pop"));
  print(s.getAddCount()); // ??

#+end_src  
  


#+begin_src java
    // Wrapper class - uses composition in place of inheritance
    public class InstrumentedSet<E> extends ForwardingSet<E> {
        private int addCount = 0;

        public InstrumentedSet(Set<E> s) {
            super(s);
        }
        @Override public boolean add(E e) {
            addCount++;
            return super.add(e);
         }
         @Override public boolean addAll(Collection<? extends E> c) {
             addCount += c.size();
             return super.addAll(c);
         }
         public int getAddCount() {
             return addCount;
         }
    }

    // Reusable forwarding class
    public class ForwardingSet<E> implements Set<E> {
        private final Set<E> s;
        public ForwardingSet(Set<E> s) {
            this.s = s;
        }

        public void clear()               { s.clear();            }
        public boolean contains(Object o) { return s.contains(o); }
        public boolean isEmpty()          { return s.isEmpty();   }
        public int size()                 { return s.size();      }
        public Iterator<E> iterator()     { return s.iterator();  }
        public boolean add(E e)           { return s.add(e);      }
        public boolean remove(Object o)   { return s.remove(o);   }
        public boolean containsAll(Collection<?> c)
                                       { return s.containsAll(c); }
        public boolean addAll(Collection<? extends E> c)
                                       { return s.addAll(c);      }
        public boolean removeAll(Collection<?> c)
                                       { return s.removeAll(c);   }
        public boolean retainAll(Collection<?> c)
                                       { return s.retainAll(c);   }
        public Object[] toArray()          { return s.toArray();  }
        public <T> T[] toArray(T[] a)      { return s.toArray(a); }
        @Override public boolean equals(Object o)
                                           { return s.equals(o);  }
        @Override public int hashCode()    { return s.hashCode(); }
        @Override public String toString() { return s.toString(); }
    }
#+end_src



- From Mac Os Notes: Item 17
- Constructor must not invoke overridable methods
  - super, sub code from notesS22
- Prefers composition over Inheritence
  - Wes's slides
    - show incorrect count due by Inheritance
    - show how it can be fixed with forwarding class
  - Inclass 12A
    - - IC A
    - keep track of how many times add has been called (directly from add() or indirectly from addAll())
    - Composition instead of inheritence
    - *Sol*
        - don’t do anything with addAll in InstrumentedHashSet so that it inherits addAll from HashSet which calls adds() which will call the InstrumentedHashSet’s adds (and therefore increment correctly).  
        - why hard question: depends on implementations
        - equals:  does not consider addCount, only considers the contents of the set
        - Q2: value of sh.addAll()  :   2  
        - Q3: InstrumentedSet is better because it uses composition instead of inheritence (so doesn’t require knowledge of how things are implemented in details; also can work on any kind of Set (ForwardSet implements Set) whereas InstrumentedHashSet only extends HashSet)
        - Q4: all true (cat and dog).  Set’s equal contracts require if both are instances of set and they both have same things in them (cat and dog) and so they must be all equal.  
        - Q5
    - 11:  s=r=[ant,bee,cat]
    - 15: s=r=t=[ant,bee,cat,dog]
    - 18:s=r=t=[bee,ant]
        - sh.addCount=2
        - r.addCount = 2
        - s.addCount=4
        - t.addCount=1

* Lecture 9 (<2022-11-04 Fri>)
- Go over Quiz
- Common Java methods (methods in class Object that should be extended from classes extending Object)
  - equals
  - toString
  - hashCode
  - clone ...
- objective of this class: able to overrride these methods correctly


o1
o2
o3

equivalence relationship
- reflexive:
  o1.equals(o1) // TRUE
- symmetry:
  o1.equals(o2) == o2.equals(o1)
- transitive:
  o1.equals(o2) & o2.equals(o3)  => o1.equals(o3)


#+begin_src java
  Point p1 = p(3,4);
  ColorPoint p2 = ColorPoint(3,4,RED);
  ColorPoint p3 = ColorPoint(3,4,BLUE);

  p1.equals(p2); //TRUE
  p2.equals(p1); //FALSE
  // symmetry: if p1 = p2 then p2 = p1

  p1.equals(p2); //TRUE
  p2.equals(p1); //TRUE   //OK for symmetry

  p2.equals(p1); // TRUE
  p1.equals(p3); // TRUE
  p2.equals(p3); // FALSE  //breaks transitivity

#+end_src


* Lecture 8 (<2022-10-28 Fri>)
- Prev Homework
  int compare(x,y){
  -1,0,1
  }

  Set s= HashSet()
  s.add(3)
  s.add(-3)
  compare(3,-3)
  //s = [3,-3]

  int AbsCompare(int x, int y){
    return abs(x).compare(abs(y))
  }
  Set s' = HashSet((x,y) -> AbsCompare)
  s.add(3)
  s.add(-3)
  //s = [3]
  
- Generics (templates)

  Generics and the *subtype polymorphism* (thing that we did last lecture)
  - Generics gives a compile time error
  - subtype polymorphism gives runtime error

  #+begin_src java
    // Before Java 5
    public interface Comparable{
        public int compareTo (Object o)
    }
    Comparable c = new Date();
    c.compareTo("red");  // RUNTIME ERROR

    // Java 5
    public interface Comparable<T>{
        public int compareTo (T o)
    }
    Comparable<Date> c = new Date();
    c.compareTo("red");  // COMPILE ERROR
  #+end_src      
  

- Item 26: don't use Raw Types in New Code
  List
  List<String>
  Listing<T>

#+begin_src java
  // Now a raw collection type – don’t do this
     private final Collection stamps = ; // Intention: Contains only Stamps
  // Erroneous insertion of coin into stamp collection
     stamps.add(new Coin(...));   // Oops!  We’re set up for ClassCastException later

  // Parameterized collection type - typesafe 
       private final Collection<Stamp> stamps = ...;
       stamps.add(new Coin(...));  // result is instead a compile time error, which is good

  // Now a raw iterator type – don’t do this!
     for (Iterator I = stamps.iterator(); i.hasNext(); ) {
        Stamp s = (Stamp) i.next();       // might throw a ClassCastException
         ...//  Do something with the stamp
      }
  // for-each loop over parameterized collection – typesafe
     for (Stamp s: stamps) {   // No (explicit) cast – same code as above
         ...// Do something with the stamp
  }
#+end_src   
  
#+begin_src java
      List<String> strings = new ArrayList<String>();
      unsafeAdd(strings, new Integer(42));
      String s = strings.get(0);  //can cause error at runtime

       // note use of raw types
       private static void unsafeAdd(List list, Object o) {
          list.add(o);
       }

      private static void unsafeAdd( List<Object> list, Object o) {
          list.add(o);
      }
#+end_src

Item 27: Eliminate Unchecked Warnings
#+begin_src java
    Set<Lark> exaltation = new HashSet();              // warning
    Set<Lark> exaltation = new HashSet<Lark>();              // no warning


    public <T> T[] toArray (T[] a) {
      if (a.length < size)
         @SuppressWarnings(“unchecked”)
             //copyOf copyes Objects so it would warn that Objects[] is not the same as T[]
         T[]results = (T[]) Arrays.copyOf(elements, size, a.getClass());
         return results

      System.arraycopy(elements, 0, a, 0, size);
      if (a.length > size)  a[size] = null;
      return a; }
  
  /*
    ArrayList.java:305: warning [unchecked] unchecked cast
  found   : Object[], required T[]    
      return (T[]) Arrays.copyOf(elements, size, a.getClass());
   ,*/

#+end_src  

Item 28: Prefer Lists over Arrays

#+begin_src java
// Fails at runtime
Object[] objectArray = new Long[1];
objectArray[0] = “I don’t fit in!”;           // Throws ArrayStoreException

// Won’t compile
List<Object> o1 = new ArrayList<Long>();
o1.add(“I don’t fit in!”);                           //  Incompatible types
#+end_src


covariant vs invariance (not related to loop invariant)
- Arrays is covariance: Arrays enforces checking at *runtime*

- List is invriance :  List enforces checking at *compile time*



   #+begin_src java
     // Chooser - a class badly in need of generics!
     // Bloch 3rd edition, Chapter 5, Item 28:  Prefer lists to arrays

     public class Chooser {
         private final Object[] choiceArray;

         public Chooser (Collection choices) {
             choiceArray = choices.toArray();
         }

         public Object choose() {
             Random rnd = ThreadLocalRandom.current();
             return choiceArray [rnd.nextInt(choiceArray.length)];
         }
     }
   #+end_src



- Generify

#+begin_src java
  public class Chooser<T> {
      private final T[] choiceArray;

      public Chooser (Collection<T> choices) {
          choiceArray = choices.toArray(); // compiler errors: cannot convert to T,

          @supresswarning..
          choiceArray = (T[]) choices.toArray();  //cast to (T[]),  got a warning, supress it because we know it is safe because choiceArray is of type T
      }

      public T choose() { 
          Random rnd = ThreadLocalRandom.current();
          return choiceArray [rnd.nextInt(choiceArray.length)];
#+end_src  
   
#+begin_src java
  public class Chooser {
      private final List<T> choiceArray;

      //RepInv: choicearray is not Null and not empty

      //POST: @throw IAE if choices is empty
      //POST: @throw NPE if choice contains null
      //Post: create a chooser with choices
      public Chooser (Collection<T> choices) {
          if (choices.size() == 0)  throw new IllegalArgumentException(); // ADD
          if (choices.contains(null)) throw new NullPointerExeption();//ADD
          choiceArray = new ArrayList<>();
      }

      //POST: @throws ISE if empty, else return random choice
      //CHECK: choiceArray never changed so RI maintained,
      public Object choose() {
          if(choiceList.size() == 0) throw IllegalStateException(); // NEW CODE
          Random rnd = ThreadLocalRandom.current();
          return choiceArray [rnd.nextInt(choiceArray.length)];
      }

      //Post @throw NPE if choice is null
      //POST: add choice to this
      public void addChoice(T choice){
          if (choice == null) throw new NullPointerException();
          choiceList.add(choice);
      }
  }
#+end_src


- Item 29 : Prefer Generic Types

  private Object[] elements ->  private T[] elements  -> private List<E> elements


- Item 30: Prefer Generic Methods

#+begin_src java
  // Uses raw types – unacceptable! (Item 23)
  public static Set union (Set s1, Set s2)  {  
     Set result = new HashSet(s1);              // Generates a warning              
     result.addAll(s2);                                 // Generates a warning
     return result;
  }


  // Generic method 
     public static <E> Set <E> union (Set <E> s1, Set <E> s2)  {
         Set <E> result = new HashSet <E> (s1);              
         result.addAll(s2);                                 
         return result;
  }
  
#+end_src


* Lecture 7 (<2022-10-21 Fri>)
- Previous Quiz  on Repr Inv

Suppose =C= is an abstract data type that has two =String= fields:
#+begin_src java
class C {
    private String s;
    private String t;
    ...
}
#+end_src

Assuming you don’t know anything about C, which of the following might be statements in a rep invariant for C?

s contains only letters
s.length() == t.length()
s represents a set of characters
s is the reverse of t
s+t  

  
- Recap
  - Liskov's Principle of Substitution


- Polymorphic Abstractions; Lambda's

1. Int sum (Int a, Int b) {....}
2. Double sum2 (Double a, Double b) {...}
...

Number
 /   \
Int Double 

Number sum (Number a, Number b) ...

Object sum (Object a, Object b) ..


- Polymorphic data type
  - Iterator


- Equality can be problematic
  
#+begin_src 
  Set s = new HashSet();
  Vector x = new Vector();
  s.insert(x)
  Vector y = new Vector();

  x.isEqual(y) // True

  s.insert(y) ; // at this point,  s has 1 element
  s.isIn(x)  ; // True
  s.isIn(y)  ; // True
  x.insert(3)
  s.isIn(y)  ; // No
#+end_src

  - because the way HashSet implements insert and equality
    - change how HashSet implements insert/equality
      
  - mutable data
    - Sol: change to immutable data


- Comparator and Comparable
  #+begin_src java
    class Person implements Comparable{
        int age;
        String name;
        int years_of_experiences;

        public int compareTo(Person p){
            age.compare(p.age);
        }
    }
    //pre-planning


    class NamePerson implements Comparator{
        public int compare (Person p1, Person p2){
            //compare name
        }
    }
    Collections.sort(collection_of_person, new NamePerson())
    //post-planning    

  #+end_src

  
- Lambda (Bloch 7-Item 42)
  
  Turing Machine  == Lambda Calculus
  
  
#+begin_src java
    // class SortbyLength implements Comparator{
    //     ...
    //     }
    Collections.sort(words, new Comparator<String>() {
        public int compare(String s1, String s2) {
            return Integer.compare(s1.length(), s2.length());
        }
    });
    //very verbose

  Collections.sort(words,
                   (s1, s2) -> Integer.compare(s1.length(), s2.length()));



#+end_src

#+begin_src python
  mylist = [x*2 for x in mylist]
  mylist = map(mylist, lambda x: x*x)    
#+end_src



In-class 9
   #+begin_src java
     public class Person {

         public enum Sex {
             MALE, FEMALE
         }
         String name;
         Sex gender;
         String emailAddress;
         public int getAge() {
             // ...
         }
         public void printPerson() {
             // ...
         }
     }
   #+end_src
**** Approach 1: Create Methods That Search for Members That Match One Characteristic.

     One simplistic approach is to create several methods; each method searches for members that match one characteristic, such as gender or age. *Create a method that prints members that are older than a specified age*.

#+begin_src java
  public static void findPersonOlderThan(List<Person> listOfPerson, int age) {
      for (Person p : listOfPerson) {
          if (p.getAge() >= age) p.printPerson();
      }
  }
#+end_src     
     
     Limitation: This approach can potentially make your application brittle, which is the likelihood of an application not working because of the introduction of updates (such as newer data types). Suppose that you upgrade your application and change the structure of the Person class such that it contains different member variables; perhaps the class records and measures ages with a different data type or algorithm. You would have to rewrite a lot of your API to accommodate this change. In addition, this approach is unnecessarily restrictive; what if you wanted to print members younger than a certain age, for example?
   
**** Approach 2: Create More Generalized Search Methods.

     Create a method is more generic than the one in the previous approach. It prints members within a specified range of ages.

#+begin_src java
  public static void findPersonOlderThan(List<Person> listOfPerson, int lower, upper) {
          for (Person p : listOfPerson) {
                  if (p.getAge() >= lower && p.getAge() <= upper) p.printPerson();
          }
  }
#+end_src

     Limitation: What if you want to print members of a specified sex, or a combination of a specified gender and age range? What if you decide to change the Person class and add other attributes such as relationship status or geographical location? Although this method is more generic, trying to create a separate method for each possible search query can still lead to brittle code. You can instead separate the code that specifies the criteria for which you want to search in a different class.
   
**** Approach 3: Specify Search Criteria Code in a Local Class

     Instead of writing filtering functions, use a new interface and class for each search you plan. Use the following filtering criteria for example:  filters members that are eligible for Selective Service in the United States: those who are male and between the ages of 18 and 25:
     #+begin_src java
       public static void printPersons(List<Person> roster, CheckPerson tester) {
                for (Person p : roster) {
                    if (tester.test(p)) {
                        p.printPerson();
                    }
                }
            }
        interface CheckPerson {
            boolean test(Person p);
        }
        class CheckPersonEligibleForSelectiveService implements CheckPerson {
            public boolean test(Person p) {
                return p.gender == Person.Sex.MALE &&
                    p.getAge() >= 18 &&
                    p.getAge() <= 25;
            }
        }

     #+end_src
     
     
     Limtation: Although this approach is less brittle—you don't have to rewrite methods if you change the structure of the Person—you still have additional code: a new interface and a local class for each search you plan to perform in your application. Because one of the class implements an interface, you can use an anonymous class instead of a local class and bypass the need to declare a new class for each search.
     
**** Approach 4: Specify Search Criteria Code in an Anonymous Class
     Use an anonymous class to address the issue with Approach 3.

#+begin_src java
  public static void printPersons(List<Person> roster,
                                new CheckPerson{
                                  public boolean test(Person p){
                                      return p.gender == Person.Sex.MALE &&
                                          p.getAge() >= 18 &&
                                          p.getAge() <= 25;
                                    }
                                  }
                                )
#+end_src     

     Limtation: This approach reduces the amount of code required because you don't have to create a new class for each search that you want to perform. However, the syntax of anonymous classes is bulky considering that the CheckPerson interface contains only one method. In this case, you can use a lambda expression instead of an anonymous class, as described in the next section.

**** Approach 5: Specify Search Criteria Code with a Lambda Expression
#+begin_src java
  public static void printPersons(List<Person> roster,
                                (Person p) -> p.getGender() == Person.Sex.MALE &&
                                  p.getAge() >= 18 &&
                                  p.getAge() <= 25
                                )
#+end_src

     Use lambda expression to address the limitation the previous approach.



* Lecture 6 (<2022-10-07 Fri>)
Recap
- ADT
  - Repr invs
    - invariant:  something that is always true
      - Binary tree repr inv:  has 2 nodes
  - Abstract Function
    - toString()
    - polynomial:   5x*2 + 10  (array, ... )

- Iterator
  - hasNext(); next(); remove()

#+begin_src java
  List<String> list = new List<>(["b", "c", "d"]);
  Iterator<String> itr = list.iterator(); //list = [b,c,d],  itr=[b,c,d]
  itr.hasNext() // return True
  itr.next();  // return b ,  list = [b,c,d], itr=[c,d]
  itr.next(); //  return c,   list = [b,c,d], itr=[d]
  itr.hasNext() // return True  
  itr.next(); // return d,    list = [b,c,d], itr=[]
  itr.hasNext() // return False
  itr.next(); // raise NSEE ,  list = [b,c,d], itr=[]  

  //prev()   hasPrev()
  List<String> list = new List<>(["b", "c", "d"]);
  Iterator<String> itr = list.iterator(); //list = [b,c,d],  itrN=[b,c,d] iterY=[]
  itr.next() ;  //return B, itrN=[c,d],  iterY=[b]
  itr.next();  // return C, itrN=[d], iterY =[c,b]
  itr.prev() ; // return C, iterN=[c,d], iterY=[b]
  itr.prev() ; // return B, iterN=[b,c,d], iterY=[]
  iter.hasPrev(); // return False
  iter.prev() ; // raise NSEE

  //remove()
  List<String> list = new List<>(["b", "c", "d"]);
  Iterator<String> itr = list.iterator(); //list = [b,c,d],  itrN=[b,c,d] iterY=[], nextCalled=False
  itr.next();  //return B, itrN=[c,d], list =[b,c,d ], nextCalled=True
  itr.next();  //return C, itrN=[d], list=[b,c,d],  nextCalled=True
  itr.remove(); //itrN=[d], list=[b,d], nextCalled=False
  itr.remove(); //raise ISE
#+end_src


    
- Immutable vulnerabilities
  - lots of benefits for immutable objects
  - but if we do it wrong, and it is not immutable

#+begin_src java
  // Broken “immutable” time period class
  public class Period {               // Question 3
      private final Date start;
      private final Date end;
      /**
       ,* @param start the beginning of the period
       ,* @param end the end of the period; must not precede start
       ,* @throws IAE if start is after end
       ,* @throws NPE if start or end null
       ,*/

      public Period (Date start, Date end) {
          if (start.compareTo(end) > 0) throw new IAE();
          this.start = start; this.end = end;  // Question 1
      }
      public Date start() { return start;}    // Question 2
      public Date end()   { return end;}      // Question 2
  }


  public class MyClass extends Period{
      private Date myDate = new Date(0); //bad, problematic value

      @override public Date start(){
          if (itsTime()){
              return myDate;   // returning some(bad)thing I define 
          }
          return super.start()
      }

    public class LoanProvider{
        Period p;
        public LoanProvider(Period p, other stuff){
            this.p = p; // no defense copy because Period is immutable

          this.p.start()
        }
    }

  Period m = new myClass(); // instead of the start define in class Period,  this uses start method from my class which uses myDate
  LoanProvider lp = new LoanProvider(m, ..) //will have start from my class
      

#+end_src

- LSP:
  Language server protocol (Python, Java, C#, Rust ...)
  

- Liskov Substitution Principle (LSP)
  - if B is a subtype of A (B inherits A  or B extends A), then whenever you use an object of type A, you should be able to use an object of type B instead.
    
  - class Mammal  // A
  - class Human extends Mammal // Human(B) is a subtype of Mammal(A)
    - speak()
      
  - class Whale extends Mammal
    - echo_location()

  MammalObj1.grow_hair()
  HumanObj2.grow_hair()
  WhaleMamal.grow_hair()

  //reverse of LSP is not correct
  Whale.echo_location()
  Mamal.echo_location()


- if B is a subtype of A, then its specification must be at least stronger than A (B's behaviors is a SUPERSET of A's behaviors)

  A has a method m 
  B overrides m  :  m'
  method m' has to be at least as precise as m

  m: pre(takes in an integer)   post (returns an integer)
  m':  pre'(anything)     post' (return 3)

  want m' to be at least as precise as m
  post' should be at least as strong
  pre' should at most as weak
  
  
#+begin_src java
  class A:
      public void reduce (Reducer x)
          // Effects: if x is null throw NPE
          // else if x is not appropriate for this throw IAE
          // else reduce this by x
   class B:
       public void reduce (Reducer x)
          // Requires: x is not null
        
          // Effects: if x is not appropriate for this throw IAE
          // else reduce this by x
   class C:
       public void reduce (Reducer x)
          // Effects: if x is null return (normally) with no change to this
          // else if x is not appropriate for this throw IAE
          // else reduce this by x
#+end_src
  
B extends A.
Precondition Part:  not satisfied LSP because B has stronger pre than A
Postcondition Part:  not statisfied because A has stronger post
-----------------------------------
C extends A.   
Precondition Part: C's pre <= A's pre ,  satisfied 
Postcondition Part: C's post >= A's post, 
- A's post is stronger than C's post because NPE is preferred:  LSP is violated
- C's post is stronger than A's post because normal return is preferred: LSP is satisfied
- A and C's behaviors are not comparable :  LSP is violated

-----------------------------------
A extends B.
Precondition Part:  A has no pre and therefore is weaker than B -- satisfies LSP     
Postcondition Part:
    - Since A is stronger because it handles null (throwing NPE), but B does not -- satisfies LSP
    - If taken into account the precond of B, which disallow x being null, then the posts of A and B are the same , satisfies LSP

-----------------------------------
C extends B.

  - preconds: C is weaker than B - satisfies LSP
  - postconds:
    - since C can handle null input, C is stronger than B
    - since for non-null cases as required by the pre of B, both C and B hae same 

-----------------------------------
A extends C.
Precondition Part:
Postcondition Part:
-----------------------------------    




* Lecture 5 (<2022-09-30 Fri>)
#+begin_src 
{y=7} x:=3 {x + y = 10)   y=7 is the weakest precondition

{y=7 AND x= 100} x:=3 {x + y = 10)


WP(x := E, Q) = Q[x/E]
WP(x:=3 , x +y = 10)  
=  x +y = 10[x/3]
=  3 +y = 10
=  y = 7

WP(z:=3, z + y > 0)
= 3 +y > 0
{3+y >0} z := 3 {z + y >0}



WP([x:=x+1; y:=y*x], y = 2*z)
= WP(x:=x+1, WP(y:=y*x, y=2*z))
= WP(x:=x+1,  y*x = 2*z)
= y*(x+1)=2*z

WP(if b then S1 else S2, Q)  =  (b => WP(S1,Q))  &  (!b => WP(S2, Q))

WP(if x > 0 then y := x + 2  else y := y + 1,  y > x)
x > 0 => WP(y:=x+2, y>x)  & x<=0 => WP(y:=y+1, y>x)
x > 0 => x+2 > x    & x<=0 => WP(y:=y+1, y>x)
x > 0 => True       & x<=0 => WP(y:=y+1, y>x)
True                & x<=0 => WP(y:=y+1, y>x)
x<=0 => WP(y:=y+1, y>x)
x<=0 => y+1 > x


// {N >= 0}  #P
i = 0;
while (i < N){
    i = i + 1;
}
//{i == N}  #Q


WP([i:=0; while(i<N) do i:=i+1], i=N)
WP(i:=0,  WP(while(i<N) do i:=i+1, i=N))

WP(while [I] b do S, Q) =  I & (I & b => WP(S,I) & (I & !b)  => Q)
let I =   *i<=N*

WP(while(i<N) do i:=i+1, i=N)
= i<=N  &  i<N => WP( i:=i+1, i<=N)  & (i<=N & i>=N)  => i=N
= i<=N  &  i<N => i+1 <= N    &  i=N  => i=N
= i<=N  &  i<N => i+1 <= N    &  True
= i<=N  &  i<N => i+1 <= N

= i<=N  &  i<=N-1 => i+1 <= N
= i<=N  &  i<=N-1 => i =N -1
= i<=N  &  True
= i<=N  

WP(i:=0, WP(while(i<N) do i:=i+1, i=N))
WP(i:=0, i<=N)
= 0<=N

verification condition (vc)
P => WP([i:=0; while(i<N) do i:=i+1], i=N,Q)
P => 0<=N
N >= 0   =>  0 <= N
True  (i.e.,   program is correct wrt to P and Q)

P1 => 0<=N
N >= 1   =>  0<=N   
True  (i.e.,   program is correct wrt to P and Q)

P2 => 0<=N
True => 0<=N
0<=N



--
let I = true
WP(while [I] b do S, Q) =  I & (I & b => WP(S,I) & (I & !b)  => Q)
WP(while(i<N) do i:=i+1, i=N)
= True &    True & i<N => WP(i:=i+1, True) &    (True & i>=N)  => i=N
= True &    True & i<N => True  &    (True & i>=N)  => i=N
= (True & i<N) => True    &     (i>=N  => i=N)
= (i<N => True)  &   (i>=N  => i=N)
=     i>=N       &   (i>=N  => i=N)


WP(i:=0, i>=N   & (i>=N  => i=N))
0>=N  &  (0>=N  =>  0=N)


VC
P => 0>=N  &  (0>=N  =>  0=N)
N>=0   =>  0>=N  &  (0>=N  =>  0=N)
Not simplified to True



{True} i:=i+1  {True}

Q[x/E]
True[i/i+1]
True

WP(i:=i+1,  x=10)
x=10[i/i+1]
x=10

{x=10} {i:=i+1} {x=10}



// {N >= 0}   # P
i = 0;
while (i < N){
    i = i + 1;
}

// {N >= 0}   # P
i = 0;
while (1){
    [I]  // 
    if (!(i < N)) break;
    i = i + 1;
}


2. i<=N ... loop inv
3. i>=0  ... loop inv

#+end_src


** Repr Invariants
- things that are true about a data structure
- binary tree 
  - at most two children
  - all nodes except root has a parent
 
- BinTree
  - add(x)
  -

- Set
  - Distinct
      
- BinarySearchTree
  -     

ReprOK()
RepOK()

* Lecture 4 (<2022-09-16 Fri>)

** No class next Friday
   - will send out details later

** Topic: Automatic Verification
- Logic

  a => b   :  !a OR b
  
  - there is class next Friday :   False
  - today is September 16:  True

  1. x > 6 and x < 5  : False  (no value of x would satisfy this)
  2. x > 6  =>  x > 1   :  True
  3. x > 6  and  y = 3   :  False , counterxample(cex) : (x=5 , y=2)
  4. x > 6  =>  y = 3   :  False,       cex  : (x=7,  y=4)
    x <= 6  or  y = 3

  satisfiable:
    f :  satisfiable   if there is some assignment to the values in f that makes f evaluate to True
    - x <= 6 or y = 3  is satisfiable (e.g.,  x=4, y=4)
    - x > 6  and  y = 3 is SAT (e.g.,  x =7, y=3)  
    - x > 6  =>  x > 1   is SAT (e.g.,  x=7)
    - x > 6 and x < 5   is UNSAT

  valid (tautology):
    f : valid, if f evaluates to True for *every* assignment (f is *always* satisfiable)
    - x > 6  =>  x > 1   is valid
    - x = x  is valid

  falsification:
   f : is falsification if f elvalues to False for *every* assignment (f is *always* unsat)
   -  x > 6 and x < 5
   - x != x
   - x = x + 1   (if x = some infinite number, then x = x + 1 would True, so assume x is finite)


  Implication   a => b   =  !a or b
  
  - f => f      =  Valid    (!f or f)
  - f => True   =  Valid    (!f or True)
  - True => f   = Not Valid  !True or f  = False or f   =  f
  - f => False   =  Not Valid       !f or False   = !f
  - False => f  =  Valid      !False or f  =  True or f  = True
  
Hoare Verification
   - Tony Hoare: Sir. Hoare, quick sort, verification, ...
   - automatic verification that a program S is correct with respect to precondition P and postcondition Q


   - Hoare tripple
     {P}  S  {Q}
     - Precondition: P
     - Postcond :  Q
     - S :   program (statements)
     - Hoare tripple is valid: if P holds, and the successful execution of S results in Q
       - S is correct with respect to P and Q
     
        


   - Testing   S,   P , Q

     Goal: given a program S,  {P, Q},  check if S is correct wrt to P, Q
     - testing: finding some bug:  want to find if there is some (bad) input that satisfy P,  but doesn't satisy Q
       - pros: quick , test it on some finite number of inputs (K,M,B ..)
       - cons: if the test shows no bug, DOES NOT mean the program really has no bug
         
     - verification: want to show there exist no bad input that ... 
       - pros: if verify shows no bug,  DOES mean program has bug
       - cons: runs slowly (have to consider all possible inputs)


     - medical (surgeries), airplan, weapons, ...
     - Hardware design (CPU)
     - Airbus:  verification to check floating errors do not occur A380 ...
     - NASA:  Rovers  (symbolic execution)
     - Facebook Newsfeed :  verification (currency), Instagram
     - Amazon AWS :  cloud computing 
       
       
Examples of Hoare tripples

- {True} x := 5  {x=5}  : Valid HT # strongest post
- {True} x := 5  {x > 4} :  Valid HT
- {True}  x:= 5  {x=5 or x=6}  : Valid HT
# postcondition:  prefer strongest postcondition
# precondition: prefer weakest precondition




- {True}  x:= 5  {x > 5}  : Invalid HT

- {x = 1 & y = 2} z:= x/y  {z < 1}   : Valid
- {x < y} z:= x/y  {z < 1}   :   Invalid
- {False} x:=3 {x=8}  : Valid
- {True} while(1){x:=8} {x=3}  : Valid (Partial correct)
  - Partial () vs Total (you have to check that the program terminates)

- Halting problem
  - given a program, is it possible to determine if it will halt or not?
  - Alan Turing
    - Break Engima (10 years of WW-II)
    - Father of Computer Science
      - Show that Halting problem is undecidable
      - Turing machine - Universal Machine
      - Turing test
    - Matrix multiplication (LU-)
  - Halting: Undecidable problem
  

How to determine if Hoare Triple is valid or not?
- Compute *weakest* preconditions (WP)
- WP(S, Q) = P'

  
- Skip:WP(skip, {x=3})=  {x=3}
- Assignment:  
  - WP(x:=x+1, {x=3})= {x=2}
    - {x=2} x:= x+1 {x=3}
  - WP(x:=x+1, {x>3})= x>2
  - WP(x:=1, {x=3}) = False
    {False}  x:= 1 {x=3}  
- Condition
  - WP(if x > 0 then y := x + 2  else y:= y + 1,  {y > x})
    x>0  and   (x  < 0 -> y + 1 >x )
- While loop
  - loop invariant (I)
    - true when entering the loop
#+begin_src python
  while (b){
    # loop body
  }

  while (True){
    [I]      # loop invariant I is right here
    if (!b) break
      # loop body
  }
#+end_src
       
#+begin_src python
  {N >= 0} # precondition
  
  i := 0
  while(True):
    [L]
    if(!(i < N)):  # i >= N : break
        break
    i := N;
#+end_src       

i = i = True
N= N
i >= 0
i <= N   
      
* Lecture 3 (<2022-09-09 Fri>)
** Go over quiz 1

Binary_search(arrays, x)
- precondition:
  - arrays: sorted, cannot null, 
- postcondition:
  - if x not in arrays: raise some exception ...
  - ow: returns index of x in array
    
 * Recap:
   - Specification is NOT code/implementation (it is independent of implementation)
   - Do not look at implementation to write specification (you will write specification for that implementation); write specification FIRST !
   - Raise exceptions related to the undesirable input, e.g., if you don't want null, then raise something about NullPointerException.  If you don't want bad index to array, then use something about IndexOutOfBoundException. If you don't want some type of inputs, then raise IllegalArgumentException.

** Data Abstraction
Consider [[./files/Poly.java][Poly.java from Liskov]]
  - implements a class to represent ~polynomials~
  - 10*x + 5*x^2 + 3*x^3 + 100*x^11 + 42
  - 101
  - c_1*x_1^d_1 + c_2*x_2^d_2    (c_i*x_i^d_i : term,  c_i: coefficients, d_i: degree)


- This is a *specific* implementation of Polynomials
  - uses arrays of ints to represent terms ...
  - =deg= var to store degree

  - Some additional constraints for polynomials in this implementation
     - 1 variable (5*x*y not allowed)
     - no negative degree
     - coefficients integers

- to represent: =5 + 3*x^2= in this code
  - =Poly(deg=2, trms=[5,3])=
  - =Poly(deg=2, trms=[5,0,3])=
    
  - =Poly(deg=2, trms=[5,0,3,0,0,0,0,0...])=: not allowed in Poly implementation (last element of the array term cannot be non zero)

    
- 1st =public Poly= contract: good (no inputs, not modifying any inputs etc)
- 2nd =public Poly= contract: also good, total contract: raise exception if n < 0, otherwise return this polynomial
- =private Poly=  :  she did not forget the contract, it is assumed that it will be called by something trusted , so no need to talk about specs of these.
- =deg=:  highest degree associated with a non-zero cofficient  
- =coeff_book()= vs =coeff()=  :  which is better? coeff() is better, go back to constructors:  if n < 0 , it throws IAE,  but this coeff_book returns a value (implicitly allow that)
...
- *abstraction method/function*: =toString=   -> concrete (implementation) to abstract (polynomial)
  -  =Poly(deg=2, trms=[5,3])=   =>  5+3*x
  -  =Poly(deg=2, trms=[5,0,3])= =>  5+3x^2
  
*** Immutable
  - Thread safe ;  easier for sharing; efficiency; safety;  less prone to error, easier to design
  - really good for concurrency (can do things in parallel)

**** General way to turn mutable to immutable      
  - If modifies contents of the data, create a new one instead and also return the newly created one
  - In other words, it would not modify the contents of the data, instead of modifying the data internally,  it returns a new data (that would have same contents as data in the the mutable version)

*** In-class 3A

#+begin_src 
q = [1,2,3]
q.enQueue(4) #  q.elements = [1,2,3,4]

result = q.deQueue()
- q.elements = [2,3,4]
- result = 1

----------------

q = [1,2,3]
q' = q.enQueue_Immutable(4)  
- q.elements = [1,2,3]
- q'.elmenets = [1,2,3,4]
q = q'

q' = q.deQueue_Immutable()
result = q.getFirst()
q = q'
- q.elements = [2,3,4]
- result = 1  

#+end_src

    
* Lecture 2 (<2022-09-02 Fri>)

** Adminstrative: Groups
  - next time:  1 submission per group

** Reconsider In-class 1B (class =User=)
#+begin_src java
  User u1 = new u1("hello");
  User u2 = new User(null);
  u2.equals(u1); //contract:F, impl: F
  u1.equals(v2); //contract:F (Javadoc does not say it should raise exception), impl: exception

  //Q: how to fix this?
  //A: Check for null and return False
#+end_src  

** Another example on how to obtain specs from documentation
  - consider =remove= from =iterator=: https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html
    - Removes from the underlying collection the last element returned by this iterator (optional operation). This method can be called only once per call to next(). The behavior of an iterator is unspecified if the underlying collection is modified while the iteration is in progress in any way other than by calling this method.
    - Getting contracts/specs from the English description.
        - 1st sentence: postcondition, specifying behavior 
        - 2nd:  post  or detail implementation
        - 3rd:  post, side effects,  but could be a *precondition*:  statement that the collection should not be modified



** Method/Program specifications
  - Preconditions (=P=): assumptions, properties about the inputs
    - established by clients (e.g., inputs are strings, unsorted list, ...)
      
  - Postconditions (=Q=): properties/behaviors of the method/program (usually related inputs)
    - done/established by the developers/implementations (e.g., outputs are sorted list, ...)

  - When something goes wrong, who to blame?
    - If preconditions are incorrect: blame the clients
    - If preconditions are correct, and the postconditions are not correct: blame developers


** Weaker Preconditions and Stronger Postconditions
  
  - Reconsider the =intdiv= example from previous class
    
#+begin_src java
  int intdiv(int x, int y){
    /*
    Return the integer division result x/y. 

    preconds:
    - x and y are integers # (already given in type)
    // - y cannot be zero   # better if we can remove this

    postconds:
    - z is a number  # weak
    - z is an integer  # weak
    - z = x // y  # *strong*
    ,*/

    if (y == 0){ // raise ...
        
    }

    return z
  }
#+end_src

If we have ~S1 = P => Q~ and ~S2 = P' => Q'~, then 
- S1 is better than S2 :   if P is weaker than P'
- S1 is better than S2 :   if Q is stronger than Q'


** Total vs Partial contract
  - *partial* specification:  has a precondition
  - *total* specification:  has NO precondition

  - to turn a partial spec into a total spec:
    - for every precondition, remove and turn it into a new behavior in postcondition (of the form if not precondition, then do something, e.g., raising an excpetion)
      - E.g., if we have a precondition   =list= cannot be =null=
      - Then we remove that precondition
      - And create the postcondition:  if list is null then raise NullPointerExeception
   - in the implementation, create conditions and raise exception


** In-class 2
  1. null : gives NPE error null pointer
  2. []   : gives IOB error (result.remove())

  Happy Paths     
  3. [1]  : []         
  4. [1,2,3] :  [2, 3]


-  Partial Specs
  Preconds:
     - list not null
     - list not empty (list has at least 1 elem)
  Postconds:
     - return the tail of the original list

-  Total Specs
  Preconds: 
  Postconds:
     - raise NPE if list is null
     - raise  IllegalArgumentExcdeption if list is empty
     - return the tail of the original list
     -   
  
#+begin_src java
  public static List<Integer> tail (List<Integer> list) {

      // REQUIRES/PRECONDS: ???
      // EFFECTS/POSTCONDS:  ???

      if (list is null){
          raise NullPointerException;
      }
      if (list.size() == 0){
          raise IllegalArgumentException;
      }

      .....
  }
#+end_src  

- 
  
** In-class 2B (=tail= implementation)

    

* Lecture 1 (8/26)
** Administrative
- Syllabus
    
** Specification Example

Sorting (e.g., quicksort)
- Input: a list of integers numbers, e.g., [2,1,5,10]

- Output:  
  - *output is a permutation of input* and *output is in sored sorder (e.g., ascending)*
  
- Alg:
  - additional requirements, e.g., (involving pivot, worst case complexity n^2, amortized nlg n)
   
** Definitions 
Software Specifications (e.g., specification of a program/methoad/function)
 - *Preconditions*: properties of the Inputs
 - *Postconditions*: properties of the Outputs
   - Typically will have some relationships with the inputs
   
- Additional properties/specifications that are common for all software (desirable, but very hard to achieve)
  - secured
  - robust
  - bugs-free
  - efficiently
  
- Specification of a program: precondition + postcondition
- Correctness: A program (implementation) is *correct* if it satifies the given specifications (i.e., pre/post conditions).

** Another example

#+begin_src java
  int intdiv(int x, int y){
    /*
    precond: x and y are integers, y cannot be zero
    postcond: z = x // y
    ,*/


    return z
  }    
#+end_src



** In class Exercise (User, equals)
*** Truth table for Implication (=>)

| X | Y | X => Y |
|---+---+--------|
| T | T | T      |
| T | F | F      |
| F | T | T      |
| F | F | T      |

- Be careful about implication, the formula `X => Y` is only False when `X` is True but `Y` is False, in every other cases, the formula is True.


*** Expected properties for an implementation of `equals` (according to [[https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)]])
1. reflexive: `a == a`
1. symmetry:   `a == b <=>  b == a`
1. transitive: `a == b && b == c  =>  a == c`
 

- Examples

#+begin_src java
User u1 = new User("hello");
User u2 = new User("world")
User u3 = new User("swe419");

User u1a = new User("hello");
User u1b = new User("hello");
User u2a = new User("world");

SpecialUser s1 = new SpecialUser("hello", 1)
#+end_src


For the equal implementation in In-class 1B for =User=.

- Reflexive: OK
  - e.g., =u1.equals(u1): contract: T   impl: T=

- symmetry: OK
  - e.g., =u1.equals(u2): False  && u2.equals(u1): False    contract: F   impl: F=
  - =u1.equals(u1a): T  && u1a.equals(u1): T  contract: T  impl: T=

- Transitive: OK
  - e.g., =u1.equals(u2) &&  u2.equals(u3) =>  u1.equals(u3) contract: T impl: T=, 
  - =u1.equals(u2a) &&  u2a.equals(u2b)  contract: T   impl: T=
          
          
Things become more complicated when involving inheritence

- Symmetry: Not OK
  - =u1.equals(s1)    impl:  T=
  - =s1.equals(u1)    impl:  F=

- A potential fix (suggested by a student)
  #+begin_src java
SpecialUser
      @Override public boolean equals (Object obj) {
      if (!(obj instanceof SpecialUser)) return super.equal(obj); //obj.equals(this)
       return super.equals(obj) && ((SpecialUser) obj).id == this.id;
      }

  #+end_src

