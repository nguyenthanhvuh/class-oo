<2022-04-18 Mon>
* Common Java Methods

- equals, toString, hash, clone, etc

- toString(): show abstract states/ things that are useful for the users

- =equals()=
  - reflexive:  x.equals(x)
  - symmetric:   x.equals(y)  <->  y.equals(x)
  - transitive:  x.equals(y) && y.equals(z) -> x.equals(z)

  Mathematical equivalence:

  Liskov Substitution Principle: if a Rectangle is subtype of a Shape, then Rectangle is also a Shape.


  - consistent: ....
  - 

#+begin_src java
  public final class CaseInsensitiveString {

      private final String s;

      public CaseInsensitiveString(String s) {
          this.s = Objects.requireNonNull(s);

      }

      @Override public boolean equals(Object o) {
          if (o instanceof CaseInsensitiveString)
              return s.equalsIgnoreCase(
                  ((CaseInsensitiveString) o).s);
          if (o instanceof String)  // One-way interoperability!
              return s.equalsIgnoreCase((String) o);
          return false;          
      }

      @Override public boolean equals(Object o) {
          return (o instanceof CaseInsensitiveString  && s.equalsIgnoreCase(
                  ((CaseInsensitiveString) o).s))  
      }      
#+end_src
  
#+begin_src java
  CaseInsensitiveString s0 =    CaseInsensitiveString("Hello")
  String s1 = "hello";
  s0.equals(s1); // True
  s1.equals(s0); // False

  // using new equal()
  s0.equals(s1); // False
  s1.equals(s0); // False
#+end_src

*** Transitivity
  #+begin_src java
           public class Point {

               private final int x;
               private final int y;

               public Point(int x, int y) {
                   this.x = x;
                   this.y = y;
               }

               @Override public boolean equals(Object o) {
                   if (!(o instanceof Point))
                       return false;
                   Point p = (Point)o;
                   return p.x == x && p.y == y;
               }



               ...  // Remainder omitted

           }
       public class ColorPoint extends Point {
           private final Color color;



           public ColorPoint(int x, int y, Color color) {
                   super(x, y);
                   this.color = color;
           }
           ...  // Remainder omitted

       // breaks symmetry (does not break transitivity)
       @Override public boolean equals(Object o) {
           if (!(o instanceof ColorPoint))
              return false;
           return super.equals(o) && ((ColorPoint) o).color == color;
       }

       // does not break symmetry, breaks transitivity
       @Override public boolean equals(Object o) {
           if (!(o instanceof Point))
              return false;

            if (!(o instanceof ColorPoint)) //if o instanceof Point
               return o.equals(this);       //then call equals of Point

           //o is colorpoint
           return super.equals(o) && ((ColorPoint) o).color == color;

       }


     ColorPoint a (1,2,Blue);
     ColorPoint b (1,2,Red);
     Point c (1,2);

     c.equals(a);  //True
     a.equals(c); // False

     //new equal      
     c.equals(a);  //True
     a.equals(c); // True

     a.equals(c); //True
     c.equals(b); //True
     a.equals(b); //False


     @Override public boolean equals(Object o) {
         if (o == null)
             return false;

         if (o.getClass() != getClass())
             return o.equals(this)

         Point p = (Point) o;
         return p.x == x && p.y == y;
     }
     a.equals(c); //True
     c.equals(b); //True
     a.equals(b); //True


    //another prob, breaks LSP
    //points = {Point(1,2), Point(3,4)}
    //c1 = ColorPoint(1,2,Blue)
    //
           
  #+end_src


<2022-04-11 Mon>

* Generics

- Don't use Raw types (item 26)
  
List<E> : generic type
List :  raw type
List<String>:  parameterized type

#+begin_src java
  // Now a raw collection type – don’t do this
     private final Collection stamps = …; // Contains only Stamps
  // Erroneous insertion of coin into stamp collection
     stamps.add(new Coin(…));   // Oops!  We’re set up for ClassCastException later

   for (Iterator I = stamps.iterator(); i.hasNext(); ) {
      Stamp s = (Stamp) i.next();       // Throws ClassCastException
       …//  Do something with the stamp
    }

  // Parameterized collection type - typesafe 
     private final Collection<Stamp> stamps = …;
     stamps.add(new Coin(…));  // result is instead a compile time error, which is good

  for(Stamp s: stamps){
    //do something with the stamp s
    }
#+end_src

#+begin_src java
      List<String> strings = new ArrayList<String>();
      unsafeAdd(strings, new Integer(42));
      String s = strings.get(0);  //can cause error at runtime

       // note use of raw types
       private static void unsafeAdd(List list, Object o) {
          list.add(o);
       }

      private static void unsafeAdd( List<Object> list, Object o) {
          list.add(o);
      }
#+end_src

** Suppress Warnings (Item 27)
#+begin_src java
    Set<Lark> exaltation = new HashSet();              // warning
    Set<Lark> exaltation = new HashSet<Lark>();              // no warning


    public <T> T[] toArray (T[] a) {
      if (a.length < size)
         @SuppressWarnings(“unchecked”)
             //copyOf copyes Objects so it would warn that Objects[] is not the same as T[]
         T[]results = (T[]) Arrays.copyOf(elements, size, a.getClass());
         return results

      System.arraycopy(elements, 0, a, 0, size);
      if (a.length > size)  a[size] = null;
      return a; }

  /*
    ArrayList.java:305: warning [unchecked] unchecked cast
  found   : Object[], required T[]    
      return (T[]) Arrays.copyOf(elements, size, a.getClass());
   ,*/

#+end_src

** Prefer Lists over Arrays
Arrays are *covariant* and Lists are *invariant*
- Array[Subtype] is a subtype of Array[Type]:  covariant
- List[Subtype] has NO relationship with List[Type]:  invariant


#+begin_src java
// Fails at runtime
Object[] objectArray = new Long[1];
objectArray[0] = “I don’t fit in!”;           // Throws ArrayStoreException

// Won’t compile
List<Object> o1 = new ArrayList<Long>();
o1.add(“I don’t fit in!”);                           //  Incompatible types
#+end_src

** Prefer Generic Types (Item 29)

*Generify* code

private Object[] elements; // private E[] elements (1st attempt) /=> private List<E> elements ..

** Prefer Generic Methods (Item 30)

#+begin_src java

  // Uses raw types – unacceptable! (Item 23)
  public static Set union (Set s1, Set s2)  {  
     Set result = new HashSet(s1);              // Generates a warning              
     result.addAll(s2);                                 // Generates a warning
     return result;
  }
  
  // Generic method 
     public static <E> Set <E> union (Set <E> s1, Set  <E> s2)  {  
     Set <E> result = new HashSet <E> (s1);              
     result.addAll(s2);                                 
     return result;
  }
#+end_src


** Bounded WildCards
#+begin_src java
    public class Stack <E> {
       public Stack()
       public void push( E e ) 
       public E pop()
       public boolean isEmpty()
    }

      //  pushAll method without a wildcard type – deficient!
      // only add E  (but not its subtype)
          public void pushAll( Iterable<E> src) {
             for (E e : src) { push(e); }
          }


     //  wildcard type for parameter that serves as an E producer
     // allows everything that is subtypes of E
          public void pushAll( Iterable<? extends E> src) {
             for (E e : src) { push(e); }
          }


       // wildcard type for parameter that serves as an E consumer
         public void popAll ( Collection<? super E> dst) {
             while (!isEmpty()) { dst.add(pop()); }
        }

  //PECS: procer extends and consumer super
#+end_src

#+begin_src java
public class Chooser {
    private final Object[] choiceArray;

    public Chooser (Collection choices) {
        choiceArray = choices.toArray();
    }

    public Object choose() {
        Random rnd = ThreadLocalRandom.current();
        return choiceArray [rnd.nextInt(choiceArray.length)];
#+end_src

First attempt, 

#+begin_src java
  public class Chooser<T> {
      private final T[] choiceArray;

      public Chooser (Collection<T> choices) {
          choiceArray = choices.toArray();// compiler errors: cannot convert to T,
          
        @supresswarning..
          choiceArray = (T[]) choices.toArray();  //cast to (T[]),  got a warning, supress it because we know it is safe because choiceArray is of type T
      }

      public T choose() { 
          Random rnd = ThreadLocalRandom.current();
          return choiceArray [rnd.nextInt(choiceArray.length)];
#+end_src


List attempt
#+begin_src java
  public class Chooser<T> {
     private final List<T> choiceList; //List instead of Array

      //repr inv: choiceList != null, cannot be empty

      //preconds:  choices != null, choices cannot be empty, choices not containing null
      //postcondition: creates a Chooser from choices

      //alternative:
      //preconds: none
      //postcond:
      //if choices is empty, then raise IAE
      //if choices is null, throw exception
      //if choices contain null, throw some exception
      //creates a Chooser from choices
     public Chooser(Collection<T> choices) {
         if (choice.size() == 0) throw IllegalArException(); // ADD
         //if choice == null throw ...
         //...
         choiceList = new ArrayList<>(choices);
     }

     //precond: none
     //post: returns a random choice in choicelist
     public T choose() {
         Random rnd = ThreadLocalRandom.current();
         return choiceList.get(rnd.nextInt(choiceList.size()));
     }

      //precond: none
      //postcond:
      //if choice is null throw exception ...
      //otherwise add choice to choicelist
     public void addChoice(T choice){
         if (choice == null) throw ...;
         choiceList.add(choice);
     }

#+end_src


<2022-04-04 Mon>

- Comparable vs Comparator

  #+begin_src java
    class Person implements Comparable{
    int age;
    String name;
    int years_of_experiences;
    
    public int compareTo(Person p){
      age.compare(p.age);
    }


    class NamePerson implements Comparator{
    public int compare (Person p1, Person p2){
    //compare name
    }


    Coolections.sort(collection_of_person, new NamePerson())
  #+end_src

  - Lambda Expression
    #+begin_src python
      my_list = [1, 2, 3, 4, 5, 6]

      def mydouble(x):
         return x*2

      my_double_list = map(mydouble, my_list)
      [2,4,6,10,12]

      my_double_list = map(lambda x: x*2, my_list)


      def mymulby(n):
          return lambda x: x*n

       double = mymulby(2) # double = lambda x:x*2
       double(10)=20
       double(11)=22

       triple = mymulby(3)
       triple(10)=30
       triple(-1)=-3

    #+end_src
    


Consider the following Market class.
#+begin_src java
class Market {
    private Set<Item> wanted;           // items for which prices are of interest
    private Bag<Item, Money> offers;    // offers to sell items at specific prices
    // Note:  Bag isn't a Java data type.  Here, the bag entries are pairs.

    public void offer (Item item, Money price)
    // Requires: item is an element of wanted
    // Effects:  add (item, price) to offers

        public Money buy(Item item)
    // Requires: item is an element of the domain of offers
    // Effects: choose and remove some (arbitrary) pair (item, price) from
    //          offers and return the chosen price
        }
#+end_src
Suppose that offers are only accepted if they are lower than previous offers.

#+begin_src java
class Low_Bid_Market extends Market {
    public void offer (Item item, Money price)
    // Requires: item is an element of wanted
    // Effects:  if (item, price) is not cheaper than any existing pair
    //           (item, existing_price) in offers do nothing
    //           else add (item, price) to offers

Is Low_Bid_Market a valid subtype of Market? Appeal to the methods rule to back up your answer.
#+end_src



Suppose that the buy() method always chooses the lowest price on an item.

#+begin_src java
class Low_Offer_Market extends Market {
    public Money buy(Item item)
    // Requires: item is an element the domain of offers
    // Effects: choose and remove pair (item, price) with the 
    //          lowest price from offers and return the chosen price
Is Low_Offer_Market a valid subtype of Market? Appeal to the methods rule to back up your answer.

#+end_src


In-class 9

Approach 1

#+begin_src java
  public static void findPersonOlderThan(List<Person> listOfPerson, int age) {
          for (Person p : listOfPerson) {
                  if (p.getAge() >= age) p.printPerson();
          }
  }
#+end_src

Approach 2
#+begin_src java
  public static void findPersonOlderThan(List<Person> listOfPerson, int lower, upper) {
          for (Person p : listOfPerson) {
                  if (p.getAge() >= lower && p.getAge() <= lower) p.printPerson();
          }
  }
#+end_src

Approach 3
#+begin_src java
  public static void printPersons(List<Person> roster, CheckPerson tester) {
          for (Person p : roster) {
              if (tester.test(p)) {
                  p.printPerson();
              }
          }
      }

  interface CheckPerson {
      boolean test(Person p);
  }


  class CheckPersonEligibleForSelectiveService implements CheckPerson {
      public boolean test(Person p) {
          return p.gender == Person.Sex.MALE &&
              p.getAge() >= 18 &&
              p.getAge() <= 25;
      }
  }

#+end_src

Approach 4
#+begin_src java
  public static void printPersons(List<Person> roster,
                                new CheckPerson{
                                  public boolean test(Person p){
                                      return p.gender == Person.Sex.MALE &&
                                          p.getAge() >= 18 &&
                                          p.getAge() <= 25;
                                    }
                                  }
                                )
#+end_src

Approach 5
#+begin_src java
  public static void printPersons(List<Person> roster,
                                (Person p) -> p.getGender() == Person.Sex.MALE &&
                                  p.getAge() >= 18 &&
                                  p.getAge() <= 25
                                )
#+end_src


<2022-03-21 Mon> Typing / Liskov Substitution Principle


- Likov Substitution Principle (LSP)
  - if B is a substype of A (A is a supertype of B)
  - foo(a) => foo(b)
  - property(MAMAL)  => property(CAT)

B is a subtype of A
- B is more precise than A
- strengthens properties of A
- if A has N methods, B also has those N methods + additional methods (specific for B)
- B's methods are superset of A's

  
- If B overrides a method of A, then that method (f') must be at least as strong (stronger or equal to) the original method (f).
  - the specification of f' is stronger than or equal the specification of f
  - specifications = pre/postconditions
  - pre    vs   pre':  pre' should weaker than or equal to pre
    - pre => pre' :  (pre: takes even numbers,   pre':  takes any numbers)
  - post   vs  post':    post'  should be at least as strong as post 
    - post' => post   (post : returns integer , post': returns positive integer,     post_int => any_int )

void f(Mamal m);
void f'(Dog m);
Dog => Mamal
Pre' => Pre

o.f(m) => o.f(d)


#+begin_src java
class A:
public void reduce (Reducer x)
// Effects: if x is null throw NPE
// else if x is not appropriate for this throw IAE
// else reduce this by x

class B:
public void reduce (Reducer x)
// Requires: x is not null
// Effects: if x is not appropriate for this throw IAE
// else reduce this by x

class C:
public void reduce (Reducer x)
// Effects: if x is null return (normally) with no change to this
// else if x is not appropriate for this throw IAE
// else reduce this by x
#+end_src



- B extends A: violates
  - preconds: B's precond (x not null) is stronger than A's precond is True -- violates LSP
  - postconds:
    - A's post stronger than B -- violates LSP

- C extends A:
  - preconds: both have no pre, i.e., their preconds are the same -- sat LSP
  - postconds:
    - since throwing NPE is stronger than returning normall, C is weaker than A
    - since returning normally is more preferred than raising exception, A is weaker than C
    - since diff behaviors (when x is null), cannot compare -- violates LSP

- A extends B:
  - preconds: A has no pre and therefore is weaker than B -- satisfies LSP     
  - postconds:
    - Since A is stronger because it handles null (throwing NPE), but B does not -- satisfies LSP
    - if taken into account the precond of B, then we only deal inputs when x is not null, in which case the behaviors of both are the same (i.e., equivalence and satisfies LSP).


- C extends B:
  - preconds: C is weaker than B - satisfies LSP
  - postconds:
    - since C can handle null input, C is stronger than B
    - since for non-null cases as required by the pre of B, both C and B hae same posts/behaviors 
  

- variance vs contravariance: LSP method rule

Greyhound is subtype of Dog, subtype of Animal

Dog -> Dog   (e.g.,  Dog f(Dog))

- GH -> GH  (e.g., Greyhound g(Greyhound))
  not OK
  
  o.f()  ->  o.g(Dog/GermanShepherd)
- Greyhound -> Animal (e.g., Animal g(Greyhound))
  not OK
  o.f()  ->  o.g(Dog/GermanShepherd)

- Animal -> Greyhound (i.e., Greyhound g(Animal))

input type:  precondition (contravariance)
output type: postcondition (variance)

type-safe
- TypeScript:  unsafe 
- 
  



<2022-03-07 Mon>
In-Class 6A: Iterator

#+begin_src java
  List<String> list = new List<>();
  //list = ["b", "c", "d"]
  Iterator<String> itr = list.iterator(); //iter = [b,c,d]
  itr.next(); //returns b, iter = [c,d]
  itr.next(); //return c, iter = [d]
  itr.next(); //return d, iter = []
  itr.hasNext() ; //return False
  itr.next(); //throw NoSuchElem exception

  //hasNext: observer
  prev();  hasPrev()  //achieving something like do/undo
  List<String> list = new List<>();
  //list = ["b", "c", "d"], iter.X = [b,c,d], iter.Y = []
  itr.next(); //returns b, iter.X = [c,d], iter.Y = [b]
  itr.next(); //return c, iter.X = [d], iter.Y= [c,b]
  itr.prev(); //return c, iter.X=[c,d], iter.Y = [b]
  itr.prev();  //return b, iter.X = [b,c,d], iter.Y = []
  itr.prev(); // throw NSE exception

  //remove():  will modify contents of list
  //list = ["b", "c", "d"]
  Iterator<String> itr = list.iterator(); //iter = [b,c,d], list=[b,c,d], nextCalled=False
  itr.next(); //returns b, iter = [c,d], list=[b,c,d], nextCalled=True
  itr.next(); //returns c, iter = [d], list=[b,c,d], nextCalled=True
  itr.remove(); //iter=[d], list=[b,d], nextCalled=False
  itr.remove(); //raise Illegal State exception 

#+end_src

#+begin_src java
// Broken “immutable” time period class
public class Period {               // Question 3
    private final Date start;
    private final Date end;
    /**
     * @param start the beginning of the period
     * @param end the end of the period; must not precede start
     * @throws IAE if start is after end
     * @throws NPE if start or end null
     */

    public Period (Date start, Date end) {
        if (start.compareTo(end) > 0) throw new IAE();
        this.start = start; this.end = end;  // Question 1
    }
    public Date start() { return start;}    // Question 2
    public Date end()   { return end;}      // Question 2
}
#+end_src


#+begin_src java
      public class MyClass extends Period{
        private Date myDate = new Date(0);
        @override public Date start(){
             if (itsTime()){
                 return myDate;   // returning some(bad)thing I define 
             }
             return super.start()
         }
      }

    public class LoanProvider{
        Period p;
        public LoanProvider(Period p, other stuff){
            this.p = p; // no defense copy because Period is immutable

          this.p.start()
        }
    }

  Period m = new myClass(); // instead of the start define in class Period,  this uses start method from my class which uses myDate
  LoanProvider lp = new LoanProvider(m, ..) //will have start from my class



#+end_src

<2022-02-28 Mon>

HW
#+begin_src 
//{N>=0}   # P

// 0<=N  WP
i = 0;
while(i < N){
  i = i + 1;
}
//{i == N}   #Q
#+end_src

- loop invariant: i<=N
WP(S, Q) =
WP([i = 0, while(i<N){i = i + 1}], i == N)
WP([i=0], WP(while(i<N){i = i + 1}, i == N))


WP(while(i<N){i = i + 1}, i == N) =
I & (I & i < N => wp(i=i+1, I)) & (I & i >= N => i == N)

// I
i <= N

// (I & i < N => wp(i=i+1, I))
(i<=N & i < N) => wp(i=i+1, i<=N) =
(i<=N & i < N) => i+1 <= N
 i < N         =>  i <= N-1
 i < N         =>  i < N
   TRUE

// (I & i >= N => i == N)
(i<=N & i >= N) => i == N
 i == N         => i == N
 TRUE

i <= N & TRUE & TRUE  =  i <= N

WP(while(i<N){i = i + 1}, i == N) =  i <= N

WP(i:=0, i<=N) = 0 <= N

VC:
N>=0   =>   0 <= N
TRUE (valid),  program is correct wrt to given P and Q; i <= N

if precondition is given as N >= 5
N >= 5   =>  0 <= N
N >= 5   =>   N >= 0  (valid)

if precondition is given as N >= -5
N >= -5   =>  0 <= N
invalid, cex = N = -4

N=-1

i=0
N=-1



verification vs testing
verification (Hoare logic, abstract interpretation):  is to prove if a program is correct

testing :  is to prove that a program has a bug

Disjkstra:  testing is to prove the presence of a bug, not its absence

Linus Torvalds

Liskov 5.5-5.10
REasoning about correctness in Object oriented programming is even harder

Abstract Function (AF)
- toString(): {1,5,10}

[1,5,10].toString() => {1,5,10}
[5,1,10].toString() => {1,5,10}
[1,5,1,10].toString() => {1,5,10}

Representative Invariant (RepInv)
-
- Binary Tree:
   - exact 2 children
   - null or exactly 2 children
   - 

- Binary Search Tree
   - values of the nodes in the right part of a tree are >= the values of the nodes in the left part of the tree


BT_removenode(BT t, Node n){
  //repr1 :  each node has 2 children
  //repr1 holds on BT

  // code to traverse t, find n, and remove n
  ...

  //ensure that the result preserves the repr inv (repr1)
}

induction (repr/loop) invariant

toString:  abstract function
bool repOK() :   check if the data satisfies the repr invs

IntSet
public boolean repOK(){
  if (els == null) return False;
  //no duplicate check
  ...
}

modular analysis
M1, M2, M3, M4  ....

M1: satisfies its specification(pre/postconditions, repr)
M2: satisfies its specification(pre/postconditions, repr)

In class exercise 5B

#+begin_src java
                     public class Members {
                         // Members is a mutable record of organization membership
                         // AF: Collect the list as a set

                         // rep-inv1: members != null
                         // rep-inv2: members != null && no duplicates in members

                         // for simplicity, assume null can be a member...

                         List<Person> members;   // the representation

                         //  Post: person becomes a member
                         public void join (Person person) {

                             if(!members.contains(person)){
    members.add(person);
  }
                         }

                         //  Post: person is no longer a member
                         public void leave(Person person) {
          members.remove(person);
                         }

#+end_src 
  
repr1  members != null

join: OK,  satisfy contract  
leave: OK,  satisfy contract

repr2 members != null && members cannot have dups

join: NO,  satisfy contract
leave: YES, satisfy contract



* <2022-02-14 Mon>  <2022-02-21 Mon>

Hoare Tripple
{P} S {Q}
{P} : precondition  (e.g.,  0 < x < 5)
{Q} : postcondition  (e.g.,  output = x * 2)
S   : your program (a list of statements)  (e.g., [int y = x * 2; return y;])

Goal: verify that executing S under the assumption that P holds will result in Q (satisfies Q).

If this goal is met, then S is correct wrt to P and Q.

*Partial correctness*:  also assuming that S will terminate  **
Total correctness: does not make the assumption that S will terminate (halting problem)

:= assignment
= , ==  :  equal sign

{True} x := 5 {x==5 or x== 6 or x > 6}  ... valid
{True} x := 5 {x>1}  ... valid
{True} x := 5 {x==5}  ... valid  (preferred, strongest postcondition)

{True} x := 5 {x>5}  ... invalid ,  S is INCORRECT wrt P and Q.

{x = 1 & y = 2} z:= x/y  {z < 1}  .. valid
{x = 2 & y = 4} z:= x/y  {z < 1}  .. valid
{0 < x < y & y  != 0 } z:= x/y  {z < 1}  .. valid    (preferred, weakest precondition)
{0 < x < y } z:= x/y  {z < 1}  .. valid  (preferred, weakest precondition)

{x < y} z:= x/y  {z < 1} *Invalid tripple* , counterexample input x=-1, y = 0
{x = 0 } z:= x/y  {z < 1} *Invalid tripple* , counterexample input x=0, y = 0
{y != 0} z:= x/y  {z < 1} *Invalid tripple* , counterexample x=2, y=1
{x <y & y != 0} z:= x/y  {z < 1} *Invalid tripple* , counterexample y=-1, x = -5


To prove {P} S {Q} is valid, we check if ~P => WP(S, Q)~    
- WP: a function returning the weakest precondition allowing the execution of S to achieve Q
-  WP({x:=x+1}, x=5) = x=4
-  WP({x:=x+1}, x<5)
     =   x < 4  *weakest precondition*
     =   x < 0          -
     =   x < -100

- *Assignment*
- WP(x:= E, Q)  =  Q[x/E]
  WP(x:=3, {x+y = 10})  =   {3+y=10  ->   y = 7]
   WP({x:=x+1}, {x<5}) =   {x+1<5 ->  x < 4} 

- *List of statements*
- WP([S1; S2; S3, ...], Q) = WP(S1, WP([S2; S3; ...], Q))
WP([x:=x+1, y=y*x], {y==2*z}) =
   WP(x:=x+1,WP(y=y*x, {y==2*z})) = 
   WP(x:=x+1, {y*x=2*z}) = 
   {y*(x+1)==2*z}
     
- *Condition*
- WP(if b then S1 else S2, {Q})  =
    b => WP(S1,Q)  &&  !b => WP(S2, Q)

WP(if x > 0 then y :=x  else y:= 0,  {y > 0}) =
x > 0  => WP(y:=x, y>0)  &&  x<=0 => WP(y:=0, y>0)
x > 0  => x>0            &&  x<=0 => 0 > 0
  True                   &&  x<=0  => False
  True                   &&  !(x<=0)
                    !(x<=0) 

{x > 0} if x > 0 then y :=x  else y:= 0  {y > 0}


| x | y | x && y | x OR y | !x | !x OR y |              |
|   |   |        |        |    |         |              |
|---+---+--------+--------+----+---------+--------------|
| T | T | T      | T      | F  | T       | (F or T = T) |
| T | F | F      | T      | F  | F       | (F OR F = F) |
| F | T | F      | T      | T  | T       | (T or T = T) |
| F | F | F      | F      | T  | T       | (T or F = T) |


         
- *Loop*
  - User *has to* provide Loop invariants to compute WP of loop
  - Loop invariant I: captures the meaning of the loop (manually provided by you)
    - property that holds when the loop entered
    - is preserved after the loop body is executed (inductive loop invariant)

WP(while [I] b do S, {Q}) =
   I && (I && b => WP(S,I) && (I && !b)  => Q)

#+begin_src python
  {N >= 0}   // precondition
  i := 0
  while (i < N)
     i := N
  {i == N} // postcondition   
#+end_src

  
- True / 0 >= 0 // LOOP INV
- N >= i  LOOP INV
- N >= 0  LOOP INV
- i >= 0  LOOP INV
- N >= i && N >= 0 && i >= 0

  
- N >= 1  X  cex: N = 0
- N > i    X cex: N =0


I: N >= i
WP({i := 0; while[i<=N] i < N do i:= N}, {i == N})
WP({i := 0}; WP(while[i<=N] i < N do i:= N}, {i == N}))


WP(while[i<=N] i < N do i:=N, {i == N}) =
// WP(while[i<=N] i < N do i:=N, {i == N}) 
  I && (I && b => WP(S,I) && (I && !b)  => Q)

1.  i <= N

&&

2.   (i<= N && i< N) => WP(i:=N, {i<=N})
     (i<= N && i< N) => N <= N
         i<N          =>  TRUE
             TRUE
&&

3.   (i<= N && !(i < N))  => i == N
     (i <=N  && i>=N)     => i == N
        i = N    =>  i = N
        TRUE

i <= N && TRUE && TRUE = i<=N

WP({i := 0}; WP(while[i<=N] i < N do i:= N}, {i == N}))
WP({i := 0}; i<=N)
=  0 <= N

N >= 0 =>  0<=N   .. YES

{N >= -5}  i:=0 ; while (i<N) i:=N  {i=N}
WP(i:=0 ; while (i<N) i:=N,  {i=N})
 0<=N

N>=-5   =>  0<=N

True because (we can use N=-5)   =>   False (b/c 0<=-5 is false)

WP(i:=0; WP(while ..., i=N))
WP(i:=0; i<=N)
0<=N
N>=0  => 0<=N  YES

N>=-5 =>  0<=N  NO


- INVALID HOARE TRIPPLE DOES NOT MEAN THE PROGRAM IS WRONG (i.e., assume pre, execute prog, does not satisfy post)
- VALID HOARE DOES IMPLY THAT THE PROGRAM IS CORRECT



Chosen I = N >= 0

WP(while[N>=0] i < N do i:=N, {i == N}) =
// WP(while[N>=0] i < N do i:=N, {i == N}) 
  I && (I && b => WP(S,I) && (I && !b)  => Q)

1.  N>=0

&&

2.   (N>=0 && i< N) => WP(i:=N, {N>=0})
     (N>=0 && i< N) => i>=0

&&

3.   (N>=0  && !(i < N))  => i == N
     (N>=0  && i>=N)     => i == N
     i >= 0    =>  i == N

1 && 2 && 3
R = N >= 0 && (N >=0 && i < N => i >= 0) && (i >= 0 => i == N)

wp(i:=0, R) =
N >= 0 && (N >=0 && 0 < N => 0 >= 0) && (0 >= 0 => 0 == N)
N >= 0 &&  TRUE  &&  (0 == N)
N >= 0 && (0 == N)
0 == N

N >= 0   =>  0 == N   NO  (cex N = 5)

*

- Loop inv location

  while b {
  //body
  }

  while (1) {
   **[I]**
   if(!b) break
   //body
  }

- simplification
  
  
- insufficiently strong

  I1  i > 0
  I2  N > 0 
  I3  
  I4

  N, i , x


  0 = 0
  
  
- (x < y && y < 10)  =>   x < 101
- x < 100            => x < 101
- x < 100000         =>  x < 101
  

* <2022-02-07 Mon>

  
#+begin_src java
  public static int months (int principal, double rate, int payment){
      // Requires: principal, rate, and payment all positive and payment is sufficiently large to drive the principal to zero.
      // Effects:  return the number of months required to pay off the principal

  }
#+end_src


check vs unchecked exceptions
- Checked exception: exception that should be recoverable (and you should write code (try/catch...) to handle it)
- Unchecked exception: exceptrions that we cannot recover from / fatal errors   


Polynomial
- 10 
- ax + bx + 5
- 10x + 5x^2 - 4

- c_1*x_1^d_1 + c_2*x_2^d_2


- 5x*y  # does not allow in Poly implementation
- cannot have negative degree (allows deg >= 0)
- coefficients are integers

5+3*x^2
Poly(deg=2, trms=[5,3])    5+3*x
Poly(deg=2, trms=[5,0,3])  5+3x^2

Poly(deg=2, trms=[5,0,3,0,0,0,0,0...])  not allowed in Poly implementation

Abstraction
Abstract representation: 5+3*x
Concrete/Internal representation:
Poly(deg=2, trms=[5,0,3],
Poly(deg=2, trms=[5,0,3,0,0,0,0,0...]))

toString()

#+begin_src java
  public class Poly {
      private int[] trms;
      private int deg;

      // Effects: Initializes this to be the zero polynomial
      public Poly() {
         trms = new int[1]; trms[0] = 0;
         deg = 0;
      }

      // Effects: If n < 0 throws IllegalArgumentException
      // else initializes this to be the polynomial c*x^n
      public Poly(int c, int n) throws IllegalArgumentException {
         if (n < 0) {
            throw new IllegalArgumentException("Poly(int, int) constructor");
         }
         if (c == 0) {
            trms = new int[1]; trms[0] = 0;
            deg = 0;
            return;
         }
         trms = new int[n+1];
         for (int i=0; i < n; i++) {
            trms[i] = 0;
         }
         trms[n] = c;
         deg = n;
      }

      private Poly (int n) {
         trms = new int[n+1];
         deg = n;
      }

      // Effects: returns the degree of this
      public int degree() {
         return deg;
      }

      // Effects: returns the coefficent of the term of this whose exponent is d
      public int coeff_book(int d){
          if (d < 0 || d > deg) return 0 else return terms[d];
      }
    
      // @throws IAE if d < 0
      // Effects: returns the coefficent of the term of this whose exponent is d
      public int coeff(int d) {
         if (d < 0) throw new IAE();
         return (d > deg) ? 0 : trms[d];
      }

      // Effects: If q is null throw NullPointerException
      // else return the Poly this - q
      public Poly sub(Poly q) throws NullPointerException {
         return add(q.minus());
      }

      // Effects: return the Poly -this
      public Poly minus() {
         Poly r = new Poly(deg);
         for (int i=0; i <= deg; i++) {
            r.trms[i] = -trms[i];
         }
         return r;
      }

      // Effects: If q is null throw NullPointerException
      // else return the Poly this + q
      public Poly add(Poly q) {
         Poly la, sm;
         if (deg > q.deg) {
            la = this; sm = q;
         }
         else {
            la = q; sm = this;
         }
         int newdeg = la.deg;
         if (deg == q.deg) {
            for (int k = deg; k > 0; k--) {
               if (trms[k] + q.trms[k] != 0) {
                  break;
               }
               else {
                  newdeg--;
               }
            }
         }
         Poly r = new Poly(newdeg);
         int i;
         for (i = 0; i <= sm.deg && i <= newdeg; i++) {
             r.trms[i] = sm.trms[i] + la.trms[i];
         }
         for (int j = i; j <= newdeg; j++) {
            r.trms[j] = la.trms[j];
         }
         return r;
      }

      // Effects: If q is null throw NullPointerException
      // else return the Poly this * q
      public Poly mul(Poly q) throws NullPointerException {

         if ((q.deg == 0 && q.trms[0] == 0) || (deg == 0 && trms[0] == 0)) {
            return new Poly();
         }

         Poly r = new Poly(deg + q.deg);
         r.trms[deg + q.deg] = 0;
         for (int i = 0; i <= deg; i++) {
            for (int j = 0; j <= q.deg; j++) {
               r.trms[i+j] += trms[i]*q.trms[j];
            }
         }
         return r;
      }

      public String toString() {
         String r = "Poly:";

         if (deg == 0 || trms[0] != 0) {
             r += " " + trms[0];
         }

         for (int i = 1; i <= deg; i++) {
            if (trms[i] < 0) {
               r += " - " + -trms[i] + "x^" + i;
            }
            else if (trms[i] > 0) {
               r += " + " +  trms[i] + "x^" + i;
            }
         }
         return r;
      }
  }
#+end_src


q = [1,2,3]
q' = q.enQueue(4)
q' = [1,2,3,4]   Queue.elements=[1,2,3,4] , Queue.size=4
q = [1,2,3]

q = [1,2,3]
e = q.peek(); //e = 1
q' = q.deQueue();
q' = [2,3] 


---
Hoare Logic
- Automatic way to *verify* that an implementation satisfies a given specification (pre/post conditions)
- Imperative programs (the version I am showing you does not deal with advanced OO concepts, no inheritence, no pointers/references)
- 


Hoare Tripple
{P} S {Q}
{P} : precondition  (e.g.,  0 < x < 5)
{Q} : postcondition  (e.g.,  output = x * 2)
S   : your program (a list of statements)  (e.g., [int y = x * 2; return y;])

Goal: verify that executing S under the assumption that P holds will result in Q (satisfies Q).

If this goal is met, then S is correct wrt to P and Q.

*Partial correctness*:  also assuming that S will terminate  **
Total correctness: does not make the assumption that S will terminate (halting problem)

:= assignment


{True} x := 5 {x==5 or x== 6 or x > 6}  ... valid
{True} x := 5 {x>1}  ... valid
{True} x := 5 {x==5}  ... valid  (preferred, strongest)

{True} x := 5 {x>5}  ... invalid ,  S is INCORRECT wrt P and Q.


* <2022-01-31 Mon>

- Specification/Contract of a program

  #+begin_src java
    int add2numbers(int x, int y){
        //requires/preconditions
        //- x and y are integers

        //effects/postconditions
        //- z is integer
        //- z = x + y
        return z;
    }
  #+end_src

  #+begin_src

    List sortAscending(List<Int> l){
       //preconds:  l is a list of integers 
       //l cannot be null
       //l cannot contain null

       //postconditions:
       - l' has an ascending order 
       - l' is a permutation of l
       return l';
    }
  #+end_src


#+begin_src java
  User u = new User(“SWE619”);
  u.equals(u); // contract: T, impl: T
  u.equals(null); //contract: F, impl: F
  u.equals("SWE619"); //contract: F, impl: F

  User v = new User(null);
  v.equals(u); //contract:F, impl: F
  u.equals(v); //contract:F, impl: exception
  
#+end_src


testing vs verfication
- testing:  test if the program works over a *finite* number of inputs
- verification: formally/mathematically show/guarantee that a program works over *all possible* inputs
  - Nasa rovers
  - A318: formally proved that no floating pt errs
  - robotic surgical arms



Precondition (P):
  - client/customer: establish  P
Postcondition (Q)
  - developer/implementation:  establish Q under assumption that P is established


- If a program is not correct
  - if precondition is wrong: blame client
  - if (precondition is met) postcondition is wrong: blame developer


- sqrt example  :  y = sqrt(x)
  preconditions:
  - x > 0 (preferred)
  - x >= 0 (preferred)
  - x is an integer (preferred)
  - 100 <= x  <= 200  (not preferred)
  - x = 101  (not preferred)

  - best precondition: no precondition
  
  postconditions:
  - y is a number
  - y <= x
  - y*y == x (-/+ epsilon)   ~~ y = x/y  (preferred)



- partial vs total specification
  - partial specification:  has a precondition
  - total specification:  has NO precondition

- how to turn a partial into a total specification?
  //partial spec
  sqrt(x):
     precondition: x >= 0
     postcondition:  y*y == x (-/+ epsilon)

  //total spec
  sqrt(x):
     precondition: 
     postcondition:
         //if x < 0:  raise exception
         //ow.  y*y == x (-/+ epsilon)

  //div_xy(x,y):   output = x/y
  partial spec:
   precond:  y != 0
   post :   y*output == x

  total spec:
    precond: true
    postcondition:   if y is 0, raise exception(DivByZero);
    y*output = 



list = null,  NPE
list = [], IOBE
list = [1], []  *
list = [1,2,3] , [2,3] *

pre: non-empty list and non-null
post: remove the head, return the rest (tail)

//total
pre: 
post:
if  (list is []) throw IOBE
if (list is null) throw NPE
remove the head, return the rest (tail)

specification too specific to implentation (remove(0)), to fix: throws IAE instead of IOBE when list is []

* <2022-01-24 Mon>

What does it mean to write correct software?
- It conforms to some expectation (software contracts or specificaions)
- Should pass its testsuite  ..
- Should not have exception or performance issues


- Specifications/contracts (requirements)
- Should not have exception or error

- Performance, maintainable, expandable :  desired qualities , but not
required for *correctness*


f (x, y):   // return output = x  / y
   //precond:  x,y are reals

  if y == 0:  raise exception
  ...



preconditions
- x,y are reals
- y != 0
- x >= 0
- x >=  100
- we want preconditions are are as WEAK as possible
   1. x could be any real numbers
   2. x must be non-negative
   3. x must be >= 100

3 is stronger than 2 is stronger 1
the best precondition is the weakest one, i.e., TRUE  (the function
has no assumption on the input)


- output : number
- output ~   x /y    (output * y   ~= x)

- precondition/requirements:  a condition over the inputs ,
assumptions that we make when the function starts
   - x,y being real numbers
   - y != 0

- postcondition/behaviors:  behavior of the function (the program),
relationshp btw inputs and outputs

   1. output is a number (reals,... )     weaker
   2. output * y ~= x                     stronger

   the best postcondition is the strongest one,  i.e.,   output * y ~= x

- side-effects:
   - can change input X, ....


task: sorting a list of numbers in ascending order  (e.g., 1,5,10,...)

g(l):
  //precondition: a list of numbers
  //same data types (comparable)
  //iterable ...
  //finite

  // l is arraylist of integers
  // precondition over l:   none,  true

   postcondition:
   - |l| == |l'|
   - l' same datatype  as l
   - [1,2,1,2]   [1,1,1,2]
   - l' is a permutation of l
   - l' ascending order


 //sort l in ascending order
 return l'




type checking

- void f (int x, int y){
   int o = 3;
   return o;
}

- type-checker is light-weight analysis and therefore can be built in in comilers,  just check if x and y are integers 
- assertion checking is heavy-weight because we can check expressive properties such as y = x ** 2; never built in, have to do some serious program analysis for this.
assertion(y = x**2);

