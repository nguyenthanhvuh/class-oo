Option to 
- Multiple Share screen
- Allow people to join to break out rooms

<2021-08-26 Thu>
** Quiz:
   binary search
   - write pre/post/modifies
   - total vs **

partial Reflection:
   - precondition (purely specification):  undefine behavior
   - exception (more implementation): turn undefine behavior into defined ones
   - checked exception (i.e. these that you should explicitly catch or rethrow):
     - Block: To summarize, throw checked exceptions for recoverable conditions and unchecked exceptions for programming errors. When in doubt, throw unchecked exceptions.
     - Liskov:
       - You should use an unchecked exception only if you expect that users will usually write code that ensures the exception will not happen, because
        • There is a convenient and inexpensive way to avoid the exception.
        • The context of use is local.
       - Otherwise, use checked

Otherwise, you should use a checked exception.
     Most prefer Bloch's ...
   - security:
     - some group mention about parseHttpRequestLine ..
     - fuzzing : generating weird, unexpected inputs ... hoping for weird/undefined/unexpected behaviors that can be exploited

** Contract
   (powerpoint)
   - {P} S{Q}:  Hoare tripple
     - P , S, Q
     - assume terminaton
     - customer (client) needs to establish P
     - Implementer (service) assume P
     - Implementer needs to establish Q (assume P)
     - Customer assumes Q
     - Bug: if both client/server do their job: good
     - if precondition is not satisfied, customer is wrong (client has bug)
     - if postcond is not satisfied, implementer is wrong (service has a bug)

   - sqrt example:
     sqrt(x):
        pre:  x >= 0
        what if x is negative?
        post:  r*r = x +/ epsilon

   - Precondition:
     - as weak as possible  (True is the weakest)
     - but lots of work, so Server prefers STRONGER (e.g., sqrt example:  if pre is weak/nothing, then SERVER has to handle more corner cases,  if if pre is stronger (e.g., x >= 0) , then SERVER doesn't have to handle as much
       
   - Postcondition:
     - as strong as possible  (False is the strongest)
     - but lots of work !  so Server prefers WEAKER post conditions (less things to do),  e.g.,  if post for sqrt is just return a number, then very easy


     
** Abstraction
   - focuses on what (not how)
     - signature: formal parameters, return types, etc
     - isPrime:  detemrine if arg is prime is important ,   how this is determine is irrelevant
** Specifications/Contracts
   
   - Informal (English, remove example): easier to write but vague
** Signatures/Header
   - requires/modifies/effects   in comments
   - requires/precond: partial vs total  (partial: only for certain input so have require/preconditions,  total: for all correct type inputs, so precondition is TRUE, i.e. no precondition/require clause)
   - modifies: input modification -> side-effect
   - effects/postcond:  under assumption that requires are satisfied  (x' or x_post)
   - Precondition: weakest is best,  nothing (i.e., True) is even better
   - weaker vs stronger

** Implementation
   - Adhere to specifications
   - weaker vs stronger  , e.g., if specification says return a number, then always return 3 is ok.  but if specification says return an odd number, then cannot return any number.
   - 
     
** Exception (Bloch item 69)

** Checkvs vs Unchecked (Bloch item 70)
   - check exception:  recoverable
     - force the caller to handle the exception
     - IOException:  file not found,  well probably can have a backup , default one       
   - unchecked exception:
     - recovery not possible
     - NPE: if you pass me a null pointer, and I try to dereference it, well then I should get NPE.  Not much I can do to turn a null pointer into a non-null pointer.  
       



** Item76: Strive for Failure Atomicity
   - failed method invocation should leave the object in the state that it was prior to the invocation
   - ways to achieve this
     - design immutable objects (tuples, string vs arrays, set)
       - performance, easy to reason about that (will spend more time later)
     - check the inputs
     - order the computation : parts that fail come before modification
     - write recovery code:  allow objecet to roll back its state
     - perform the operations on temporary copy of the object



** WARNING: will make people share your answers ...
   Look at Javadoc for ArrayList
   

** in class 1A

#+begin_src java
public static List<Integer> tail (List<Integer> list) {

    // REQUIRES: ???
    // EFFECTS:  ???
  if(list.size() == 0) throw new IllegalAccessException() ..
    List<Integer> result = new ArrayList<Integer>(list);
    result.remove(0);
    return result;
}
#+end_src


https://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html


- what does it do?

- write partial specs for happy paths (where it works) ,
  A: last 2 cases
- rewrite to be total.  A: add addition things to postconditions so that we can remove preconditions
  @throws NPE if list is null
  @throws IOOBE if list is empty (because of remove in javadoc)

  
- IOBE :  does not match the exception (if list is empty, throw IOB)

- instead of IOBE,  throw IllegalAccessException

- no need to do nullpointer exception because .size() will throw   

  
** In class 1B (20 mins)



-----


- turn on recording

- introducing myself (in NE, taught compilers etc)

- SCHEDULE
  - give plenty of time to read the assignment,  might have few pages, but lots of stuff in there


** <2021-08-23 Mon>
   - Correctness:
     -- specification  or contract ...
     -- code is correct if it satisfies the contract
     -- if you give it no contract, well then anything would be correct
     -- so you want strong and precise contract

     
     
   - Pre/Post conditions

   - sort list  : 
     - preconds:  input is a list of *comparable* items
     - postcond:
       - output is sorted
       - output is a permutation of data input






   - =void remove()=
     Removes from the underlying collection the last element returned by this iterator (optional operation). This method can be called only once per call to next(). The behavior of an iterator is unspecified if the underlying collection is modified while the iteration is in progress in any way other than by calling this method.

   Throws:
   - UnsupportedOperationException - if the remove operation is not supported by this iterator
   - IllegalStateException - if the next method has not yet been called, or the remove method has already been called after the last call to the next method


   List<String>l = ... // [cat, dog, mouse]
   Iterator<String> itr = l.iterator();

   itr.next();    // cat
   itr.next(); // dog


   itr.next();  // cat
   l.add("elephant");
   itr.next();  // anything can happen, depends on Java implementation,  probably return an exception (Concurrent modification)

* INCLASs object   
  - Group break out , do in-class ,  45 mins
  - turn recording OFF

  - after break,  turn on recording



- Talk about compilers if have time   
