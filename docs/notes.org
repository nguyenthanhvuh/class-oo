<2021-11-08 Mon>

equals, toString, clone, hash

equals
- reflexive  :  x.equals(x)  
- symmetric  :  x.equals(y)  <->  y.equals(x)
- transitive :  x.equals(y) && y.equals(z)  -> x.equals(z)
- Liskov's Substitution Principle  


- consistent  :   
- o.equals.null()     should be False




#+begin_src java

  public final class CaseInsensitiveString {

      private final String s;

      public CaseInsensitiveString(String s) {
          this.s = Objects.requireNonNull(s);

      }



      // Broken - violates symmetry!
      @Override public boolean equals(Object o) {
          if (o instanceof CaseInsensitiveString)

              return s.equalsIgnoreCase(
                  ((CaseInsensitiveString) o).s);

          if (o instanceof String)  // One-way interoperability!
              return s.equalsIgnoreCase((String) o);
          return false;

      }

      // does not break symmetry
      @Override public boolean equals(Object o) {
          return (o instanceof CaseInsensitiveString  && s.equalsIgnoreCase(
                  ((CaseInsensitiveString) o).s))  
      }

      ...  // Remainder omitted

  }

  CaseInsensitiveString s1 = CaseInsensitiveString("Hello")
  String s2 = "hello";

  s1.equals(s2) ;  // True
  s2.equals(s1); // False


#+end_src


* Transitivity
  #+begin_src java

        public class Point {

            private final int x;
            private final int y;

            public Point(int x, int y) {
                this.x = x;
                this.y = y;
            }

            @Override public boolean equals(Object o) {
                if (!(o instanceof Point))
                    return false;
                Point p = (Point)o;
                return p.x == x && p.y == y;
            }



            ...  // Remainder omitted

        }
        public class ColorPoint extends Point {
            private final Color color;



            public ColorPoint(int x, int y, Color color) {
                super(x, y);
                this.color = color;
                }
                ...  // Remainder omitted
            }

    // breaks symmetry
    @Override public boolean equals(Object o) {
        if (!(o instanceof ColorPoint))
           return false;
        return super.equals(o) && ((ColorPoint) o).color == color;

    // does not break symmetry (but breaks transivity instead)
    @Override public boolean equals(Object o) {
        if (!(o instanceof Point))
           return false;

         if (!(o instanceof ColorPoint)) //if o instanceof Point
            return o.equals(this);       //then call equals of Point

        //o is colorpoint
        return super.equals(o) && ((ColorPoint) o).color == color;

    }
  #+end_src


  ColorPoint a (1,2,Blue)
  ColorPoint b (1,2,Red)
  Point c (1,2)

  c.equals(a) ; // True
  a.equals(c) ; //  True
  
  c.equals(b) ;// True
  b.equals(a) ;// True

  a.equals(c) -> True
  c.equals(b) -> True 
  a.equals(b) -> False  //break transitivity

  x.equals(y) && y.equals(z)  but !x.equals(z)



 
  #+begin_src java

       //3rd attempt, many people will try this, but this breaks Liskov Principle of substitution
      @Override public boolean equals(Object o) {

          if (o == null || o.getClass() != getClass())
              return false;

          Point p = (Point) o;
          return p.x == x && p.y == y;
      }

      //Vu's attempt,  anything wrong with this ?
      @Override public boolean equals(Object o) {
          if (o == null)
              return false;

          if (o.getClass() != getClass())
              return o.equals(this)


          Point p = (Point) o;
          return p.x == x && p.y == y;
          // return super.equals(o) && ((ColorPoint) o).color == color;
      }

    ColorPoint a (1,2,Blue)
    ColorPoint b (1,2,Red)
    Point c (1,2)

    a.equals(c) // True
    c.equals(b) // True
    a.equals(b) // False   , breaks transitivity

    a.equals(b)  //TRUE  <- not expected



    //points = [Point(1,2), Point(3,4)]
    //c1 = ColorPoint(1,2,Blue)
    //c1 should be in points (because c1 is still a point), but using this equals method, c1 is not in points because of diff types
  #+end_src



What is the equals() contract? What is the standard recipe?
  - reflexive, transitivity, symmetry, consistency, non-null equiv
  - use == for reference  (for performance)  if (o == this){ return true } 
    Check if the type is Point, if not false  
    Cast to Point
    Compare key attributes
   
Why does Bloch use the instanceof operator in the standard recipe?
 - to preserve type hierachy for principle of subs (i.e., use instanceof insetad of getclass)

Write client code that shows a contract problem with the first attempt at ColorPoint (i.e., what contract does it break?)
 - breaks symmetry
   Point a = new Point(1,2)
   ColorPoint b = new ColorPoint(1,2, Color.Red)
   a.equals(b); // return true
   b.equals(a); // return false  , break symmetry   

Write client code that shows a contract problem with the second attempt at ColorPoint (i.e., what contract does it break?)
- breaks transitivity
     Point a = new Point(1,2)
     ColorPoint b = new ColorPoint(1,2, Color.Red)
     ColorPoint c = new ColorPoint(1,2, Color.Blue)
     a.equals(b); // return true
     a.equals(c); // return true
     b.equals(c); // return false; break transitivity


Some authors recommend solving this problem by using a different standard recipe for equals().
What's the key difference?
getClass()  ...  break Liskov principle of subs

Which approach do you want in the following code:

        #+begin_src java
          public class CounterPoint extends Point
                                            private static final AtomicInteger counter =
                                            new AtomicInteger();

          public CounterPoint(int x, int y) {
              super (x, y);
              counter.incrementAndGet();
          }
          public int numberCreated() { return counter.get(); }

          // @Override public boolean equals (Object obj) {
          //   //don't need this ,  

          // }
          }


          // Client code:

          Point p = PointFactory.getPoint();   // either a Point or a CounterPoint
          Set<Point> importantPoints =   // a set of important points
              boolean b = PointUtilities.isImportant(p);  // value?

        #+end_src




(1,2,counter=5)  =  (1,2,counter=6)


Consider a variation of Liskov's IntSet example (Figure 5.10, page 97)
#+begin_src java
  public class IntSet implements Cloneable {  
      private List<Integer> els;
      public IntSet () { els = new ArrayList<Integer>(); }
      ...
      @Override
      public boolean equals(Object obj) {
          if this == ojb return true ;

          if (!(obj instanceof IntSet)) return false;

          IntSet s = (IntSet) obj;
          return super.equals(obj)  && els.equals(obj.els)
       }

      @Override
      public int hashCode() { 
          // ??
      }

      // adding a private constructor
      private IntSet (List<Integer> list) { els = list; }

      @Override 
      public IntSet clone() { 
          return new IntSet ( new ArrayList<Integer>(els));
      }

  }
#+end_src

How should the equals() method be completed?
Analyze the following ways to implement hashCode()? If there is a problem, give a test case that shows the problem.
- not overridden at all
  //will return different hashcode for every objects  
- return 42;
  //degrade performance b/c everything collides and instead of efficient hashing (e.g., constant look up in hashtable), you have a an inefficient operation (e.g., O(n) search instead of constant)
- return els.hashCode();
  //hash([1,2,3])  !=  hash([3,2,1])  != hash([3,1,3,2])
  //set([1,2,3]) == set(3,2,1)== set([3,1,3,2])
- int sum = 0; for (Integer i : els) sum += i.hashCode(); return sum;
  //sum(1,3)  =4  sum(0,4)

  result = hash(v1)
  result += 31 * v1  + has(v2)
  result += 31 * v1  + has(v3)







  




  

Equal :  ... HARD

only 2 out of 3,  shows example,  show how it breaks Liskov

getClass ... violating Liskov


Pg. 48 recipe

In class 9A (40 mins)

Equal contracts
reflex, symmetry, transitivity, liskov substitution variable

In class 9B (30 mins)


<2021-11-01 Mon>

HW assignment 7 (abs value in comparator)

-3, 3  abs(-3) == abs(3)   -3,3  => 3

-10 3    10  3     1



Generics 

- Summary
  - Generics are safer (type-safe and give errors at *compilation time*) than raw types (gives erros at *runtime*)
  - Raw types still allowed due to backward compability

    

Item 26: Don't use Raw Type

- List: raw
- List<E>: generics
- List<String>  parametrized type  


#+begin_src java

  // Now a raw collection type – don’t do this
     private final Collection stamps = …; // Contains only Stamps
  // Erroneous insertion of coin into stamp collection
     stamps.add(new Coin(…));   // Oops!  We’re set up for ClassCastException later

   for (Iterator I = stamps.iterator(); i.hasNext(); ) {
      Stamp s = (Stamp) i.next();       // Throws ClassCastException
       …//  Do something with the stamp
    }

  // Parameterized collection type - typesafe 
     private final Collection<Stamp> stamps = …;
     stamps.add(new Coin(…));  // result is instead a compile time error, which is good

  for(Stamp s: stamps){
    //do something with the stamp s
    }
#+end_src

#+begin_src java
      List<String> strings = new ArrayList<String>();
      unsafeAdd(strings, new Integer(42));
      String s = strings.get(0);  //can cause error at runtime

       // note use of raw types
       private static void unsafeAdd(List list, Object o) {
          list.add(o);
       }

      private static void unsafeAdd( List<Object> list, Object o) {
          list.add(o);
      }
#+end_src


Item 27: Suppress Warnings

#+begin_src java
    Set<Lark> exaltation = new HashSet();              // warning
    Set<Lark> exaltation = new HashSet<Lark>();              // no warning


    public <T> T[] toArray (T[] a) {
      if (a.length < size)
         @SuppressWarnings(“unchecked”)
         T[]results = (T[]) Arrays.copyOf(elements, size, a.getClass());
         return results
           
      System.arraycopy(elements, 0, a, 0, size);
      if (a.length > size)  a[size] = null;
      return a; }

  /*
    ArrayList.java:305: warning [unchecked] unchecked cast
  found   : Object[], required T[]    
      return (T[]) Arrays.copyOf(elements, size, a.getClass());
   ,*/

#+end_src


Item 28: Prefer Lists over Arrays
- Lists play well with Generics

- Arrays are covariant; and generics are invariant
  - array of type Sub is a subtype of array of type Super  (covariant)
  - List<Sub> NO relationship   List<Super>   (invariant)   

reifying  :  Arrays (information are carried to runtime) 
erasure  List (information not carried to runtime)

#+begin_src java
// Fails at runtime
Object[] objectArray = new Long[1];
objectArray[0] = “I don’t fit in!”;           // Throws ArrayStoreException

// Won’t compile
List<Object> o1 = new ArrayList<Long>();
o1.add(“I don’t fit in!”);                           //  Incompatible types
#+end_src


Item 29: Favor generic types
#+begin_src java
  public class Stack {                 // Original Version – no generics
     private Object [] elements;
     private int size = 0;
     private static final int CAP = 16;

     public Stack() { elements = new Object [CAP];}

     public void push( Object e ) {
        ensureCapacity(); 
        elements [size++] = e;
     }
     public Object pop() {
        if (size == 0) { throw new ISE(…); }
        Object result = elements [--size];
        elements[size] = null;
        return result;
     }

    # generify it
  public class Stack<E> {                 // Original Version – no generics
     private E [] elements;
     private int size = 0;
     private static final int CAP = 16;

     public Stack() {
       @supresswarning ...
       elements = new (E []) Object [CAP];

     }

     public void push( E e ) {
        ensureCapacity(); 
        elements [size++] = e;
     }
     public E pop() {
        if (size == 0) { throw new ISE(…); }
        E result = (...) elements [--size];
        elements[size] = null;
        return result;
     }
#+end_src

Item 30: Favor generic methods
#+begin_src java

  // Uses raw types – unacceptable! (Item 23)
  public static Set union (Set s1, Set s2)  {  
     Set result = new HashSet(s1);              // Generates a warning              
     result.addAll(s2);                                 // Generates a warning
     return result;
  }
  // Generic method 
     public static <E> Set <E> union (Set <E> s1, Set  <E> s2)  {  
     Set <E> result = new HashSet <E> (s1);              
     result.addAll(s2);                                 
     return result;
  }
#+end_src

Recursive Type Bound
#+begin_src 
public  static <T extends Comparable<T>>  T  max (List <T> list)
#+end_src

Item 31: Bounded Wildcards


#+begin_src java

    public class Stack <E> {       
       public Stack()
       public void push( E e ) 
       public E pop()
       public boolean isEmpty()
    }

      //  pushAll method without a wildcard type – deficient!
          public void pushAll( Iterable<E> src) {
             for (E e : src) { push(e); }
          }


     //  wildcard type for parameter that serves as an E producer
          public void pushAll( Iterable<? extends E> src) {
             for (E e : src) { push(e); }
          }


       // wildcard type for parameter that serves as an E consumer
         public void popAll ( Collection<? super E> dst) {
             while (!isEmpty()) { dst.add(pop()); }
        }

  # PECS: procer extends and consumer super
                     
#+end_src


#+begin_src java
  public class Chooser<T> {
      private final T[] choiceArray;

      public Chooser (Collection<T> choices) {
        @supresswarning..
          choiceArray = (T[]) choices.toArray();
      }

      public T choose() { 
          Random rnd = ThreadLocalRandom.current();
          return choiceArray [rnd.nextInt(choiceArray.length)];
#+end_src
   

#+begin_src java
  public class Chooser<T> {
     private final List<T> choiceList;


     // Rep invs: choiceList != null && size(choices) > 0

     // Requires/Precond: None
     // Post: if choices is null , throw IAE
     // Post: if choices is empty, throw exception
     // Post: !choices.contains(null), throw exception
     // Post: create a choooser with choices

     //Alternative way
     // Precondition: choices cannot be null, cannot be empty, cannot contain null
     // Post: create a choooser with choices
     public Chooser(Collection<T> choices) {
         if (choice.size() == 0) throw IllegalArException(); // ADD
         //if choice == null throw ...
         choiceList = new ArrayList<>(choices);
     }

     //Requires: None
     //Post/Effects: returns random choice in List<T> choiceList
     public T choose() {
         Random rnd = ThreadLocalRandom.current();
         return choiceList.get(rnd.nextInt(choiceList.size()));
     }


     public void addChoice(E choice) {
        /**
         ,* REQUIRES: None
         ,* EFFECTS: Throws IllegalArgumentException if choice == null, 
         ,* else add choice to the choiceList
         ,*/

         if (choice == null){
             throw new IllegalArgumentException();
         }

         choiceList.add(choice);
    }
#+end_src

//REQUIRE: x has type int
foo(int x)















- Homework assignment 7:
  Absvalue comparator (see schedule.org)

- Reflection: not too many used generics  
  
Item 26: Don't use Raw types (slide 4, 5)

Item 27: Handle Warnings  (slide 10)

Item 28: prefer Lists to Arrays (slide 11, 12)

- Arrays are covaraint; generics are invariants
  - array of Sub (i.e., Sub[]) is a subtype of array of Super (Super []) (design) -> covariant
  - But List <Sub> is not a subtype of List <Super), and vice versa -> invariant


Item 29: Favor generic types (#Slide 18, #19 Converting collection to generics)
#+begin_src java
  public class Stack ...
#+end_src

Item 30: Generic method / *Recursive Type Bound* (slide 22)
#+begin_src java
  max function
#+end_src

Item 31: Slide 28



<2021-10-25 Mon>

Assignment 6

Comparable vs Comparator

Comparable:


class Person implements Comparable{
   int age ..
   String name ...
   int years_in_college
   
   public int compareTo(Person p){
       age.compareTo(p.age); 
   }

}

class NamePerson impelments Comparator{
  public int compare(Person p1, Person p2){
  //compare name
  }
}

class YICPerson implements Comparator{
  public int compare(Person p1, Person p2){
  //compare yearsin college
  }

}

Collections.sort(persons, new NamePerson())


In-class Exercise 7


1. Approach 1
#+begin_src java
public static void findPersonOlderThan(List<Person> listOfPerson, int age) {
	for (Person p : listOfPerson) {
		if (p.getAge() >= age) p.printPerson();
	}
}
#+end_src

2. Approach 2
   

#+begin_src java
  public void AgeRange(ArrayList<Person> personArrayList, int lower, int upper){
              Iterator<Person> it = personArrayList.iterator();
              while(it.hasNext()){
                  Person person = it.next();
                  if(lower > person.getAge() && person.getAge() > upper) person.printPerson();
              }

#+end_src

3. Approach 3
   
#+begin_src java
  public static void printPersons(
          List<Person> roster, CheckPerson tester) {
          for (Person p : roster) {
              if (tester.test(p)) {
                  p.printPerson();
              }
          }
      }

  interface CheckPerson {
      boolean test(Person p);
  }


  class CheckPersonEligibleForSelectiveService implements CheckPerson {
      public boolean test(Person p) {
          return p.gender == Person.Sex.MALE &&
              p.getAge() >= 18 &&
              p.getAge() <= 25;
      }
  }



#+end_src

4. Approach 4
   #+begin_src java
     printPersons(
         roster,
         new CheckPerson() {
             public boolean test(Person p) {
                 return p.getGender() == Person.Sex.MALE
                     && p.getAge() >= 18
                     && p.getAge() <= 25;
             }
         }
     );


   #+end_src

5. Approach 5:Lambda Expression
   #+begin_src java

     printPersons(
         roster,
         (Person p) -> p.getGender() == Person.Sex.MALE
             && p.getAge() >= 18
             && p.getAge() <= 25
     );
   #+end_src


Java SE Lambda Expression tutorial






















Comparable vs Comparator


#+begin_src java

    //natural/default sorting
    class Employee implements Comparable {
       String name;
       public int compareTo(Employee o) {        
          return name.compareTo(o.name);
       }
    }

    //Collections.sort(employees);


  class IdComparator implements Comparator<Employee> {
     public int compare(Employee o1, Employee o2) {
        if (o1.getId() < o2.getId()) {
           return -1;        
        }else if (o1.getId() > o2.getId()) {          
           return 1;
        } else {
           return 0;        
        }
     }
  }

  class AgeComparator implements Comparator<Employee> {
     public int compare(Employee o1, Employee o2) {
        if (o1.getAge() < o2.getAge()) {
           return -1;        
        }else if (o1.getAge() > o2.getAge()) {          
           return 1;
        } else {
           return 0;        
        }    
     }
  }
  //Collections.sort(employees, new IdComparator());
  //Collections.sort(employees, new AgeComparator());

#+end_src


- Inclass Lambda



- Inclass 6


- Show DIG if have time 


- Quiz

-------------------------




Type-Checking or Type-Safety


Greyhound extends Dog extends Animal

Dog f(dog d){
 ...
 return g(d);
}

What is the signature of g?

T2 g(T1 x)

T1 :  Dog or Animal
T2:  Dog  or Greyhound




Greyground g (Greyhound x)  ?   NO (not TYPE-SAFE)
Greyhound g (Animal x)  ?   YES



Dog d =  Greyhound f(...)   
Animal a  = Greyhound f(...)








Inclass 5B

#+begin_src java
  class A:
      public void reduce (Reducer x)    
          // Effects: if x is null throw NPE 
          // else if x is not appropriate for this throw IAE
          // else reduce this by x

  class B:
      public void reduce (Reducer x) 
          // Requires: x is not null
        
          // Effects: if x is not appropriate for this throw IAE
          // else reduce this by x

  class C:
      public void reduce (Reducer x)   
          // Effects: if x is null return (normally) with no change to this
          // else if x is not appropriate for this throw IAE
          // else reduce this by x
#+end_src
        



B extends A.   Fail
Precondition Part:  B has stronger pre:  Fail
Postcondition Part: B has weaker post:  Fail  

-----------------------------------          
C extends A. 
Precondition Part: both have no preconds:  OK   
Postcondition Part:
- incompatible behaviors (a => b ,  b => a) :  Fails
- throwing NPE is stronger than return normally:  Fails
- return normally is better / stronger than giving an exception:  OK   
-----------------------------------          
A extends B.  
Precondition Part: OK, A has no precondition 
Postcondition Part: OK, A is stronger
OK, A == B

P        Q    (supertype)
 P'   Q'      (subtype)

P -> P'  -> Q' -> Q
P is stronger than P'
Q' is stronger than Q

-----------------------------------          
C extends B.  OK
Precondition Part: OK,  C has no precondition so weakest 
Postcondition Part:
- same postconditions (because of B's precond forbidding null) OK
- C's post is stronger (because it handles more cases)  OK
-----------------------------------                    

A extends C.
Precondition Part: none has precond OK
Postcondition Part: A is stronger OK
A is weaker :  Fail
-----------------------------------          






Liskov Substitution Principle (LSP)

If B is a subtype of A, B can always be subsituted for A

- B extends A  (B is a subtype of A  ,  A is a supertype of B)

- foo(A) =>  foo(B)


B should be more preicse than A,  strengthen properties of A
- if A has some N methods,  B will have those methods,  B can have extra ones,  B overrides those N methods
- An overriding method must have a stronger (or equal to) specification the the original method of A.
- Precondition (requires)
- Postcondition (effects)
- Specification: Precondition => Postcondition (partial correctness specification, total)    
- A's original method ~foo~   ~p => q~
- B's ~foo~:   ~p' => q'~ 

- more requires,  more preconditions

 ~p'~ has more constraints/requires than ~p~, then  ~p'~ is stronger. 


p' is stronger than p  ,     p' => q'  is stronger or weaker than p => q ? 


p -> q

p' -> q


p' -> p   DOES NOT MEAN p' -> q =>  p -> q


p -> q =>  p' -> q


1. WEAKEN the precondition p' of foo in B (i.e., make the precondition p' of B foo weaker than the precondion p of A's foo) (and keep the postconditions of both the same)

p -> p'  MEANS (p' -> q) -> (p -> q)

weakening the precondition of B's foo, allows B's foo to deal with MORE inputs than A's foo, thus B's is "better" or stronger than A's.

OR
2. STRENGTHEN the postcondition of foo in B (i.e., make the postcondition of B's foo stronger than A's foo) (keep the preconditions of both the same)

q' -> q  MEANS (p -> q') -> (p -> q)

   
A's foo return some animal , and B's foo return a cat  ,   thus B's foo is stronger than that of A



if A has a function
#+begin_src java
  A_foo(int x){
    //requires x as an integer
    //effects: returns a positive int
    }

  B_foo(int x){
      //requires x as a postive integer :  BAD (stronger precondition)
      //effects:  return an integer:  BAD (weaker postcondition)
    }
#+end_src




A:
foo() returns animal


B:
foo() returns a mamal


class Shape

class Triangle extend Shape




just types, then the Compiler will automatically checks and enforces LSP for us

T1' extends T1
T2' extends T2

--- contravariance and covariance
supertype       T1 foo (T2 x)
subtype         T1 foo (T2 x)
                   foo (T2' x)   #would violate Liskov principle 




T1x.foo()

T1'x.foo()


bar(T1x)
bar(T1'x)














































<2021-10-12 Tue>

Liskov Substitution principle

-  If B is a subtype of A,a B can always be substituted for an A

- B is permitted to strengthen properties and add properties
  – Fine to add new methods (that preserve invariants)
  – An overriding method must have a stronger (or equal) spec
B is not permitted to weaken a spec
  – No method removal
  – No overriding method with a weaker spec

Constraints on methods
– For each supertype method, subtype must have such a method
  • Could be inherited or overridden
Each overriding method must strengthen (or match) the spec: –
   Ask nothing extra of client (“weaker precondition”)
      - Requires clause is at most as strict as in supertype’s method
      -  Guarantee atleast as much(“stronger post condition”)
         • Effects clause is at least as strict as in the supertype method
         • No new entries in modifies clause
         • Promise more (or the same) in returns clause
         • Throws clause must indicate fewer (or same) possible exception types

*TYPE*
      Contra vs co-variance
supertype    T1 foo(T2)
subtype      T1' foo(T2')
      T2' is supertype of T2 (as T2' is weaker, contravariance)
      T1' is subtype of T1 (as T1 is stronger, covariance)

class A{
   A foo(A x);
}

class B extends A{
   A foo(B x); // Bad, strengthening precond
   B foo(A x); // OK,  strenthening postcond
   A foo(Object x); // OK , weakening precond
}
      
Object o = new Date() ;// OK,   new Date() returns a Date() which is stronger than Object
Date d = new Object(); // Not OK, compile time error 

dog a = ..
dog b = f(a)


dog f(dog d):
   ...
   return g(d)


can f returns greyhound ?  YES,    
can f returns animal ?  NO

can f takes greyhound ?  yes
can f takes germanshephard? yes

g: animal -> greyhound



*SPECIFICATION*
- Any property (e.g., invariants or specification) guaranteed by supertype must be guaranteed by subtype
  – The subtype is permitted to strengthen & add properties
  – Anything provable about an A is provable about a B
- No specification weakening
  - No method removal
  - An overriding method has
    - a weaker precondition:
      - cannot ask anything extra more from the client
      - if super_pre  is x < 5,
        - then sub_pre can be x < 4 ? no, bc x<4 => x<5
      -  then sub_pre can be x < 10? yes, bc x<5 => x<10
    - a stronger postcondition:
      - give result at least as strong as the overriden one


-supertype has a method f that takes in an int, and returns a positive int (e.g., absolute)
-subtype overrides f and
  - take positive int:  so strenghthen precond, this is bad because what used to work with negative is now broken
  - returns an int: so weakening postcond,  also bad because the return should be positive int, but now could return a neg



  



https://www.youtube.com/watch?v=PZlD39cd4Wk


Counter vs Counter2:

2 methods in Counter
Also 2 in Counter2 (get is inherit)
precondition: OK,  same (both True)
postcondition: NOT OK double doesn't make it bigger (incr), so this is not at least stronger than post of Counter.  (if we have some precondition saying this >= 0, then we are OK)




Method rules
- Subtype has all methods from supertype and more
- Client only has access to the methods (overriden or extra) of the subtypes, they cannot access methods of the supertype directly     

- Subtype Precondition:
  - can be weaken than supertype precond
    - i.e, ~presuper -> presub~
  - e.g., supertype precond : x > 5
  - subtype precond,  x > 4   (x > 5 => x> 4)
  - 

- Subtype Post:
  - can stregthen supertype post
    - i.e., ~presuper & postsub => postsuper~ 
    


In-class 5B

B extends A:  fails
Precond:  BAD
Post: really doesn't matter, already fail pre

C extends A: fails
Precond: Ok, no precond for both
Post: BAD,  supertype A does more (e.g., return NP when x is null)

A extends B: OK
precond:  OK,  A has no precond
post: Ok, A is stronger, throws exception (actually they are the same if we consider the precond of B)

C extends B: OK
precond: OK, C's precond is arguebly weaker
post: Ok, same post


A extends C: OK
precond: OK, none has precond
postcond:  A post is stronger if we consider returning exception is stronger.  But not OK if we reason that in C we expect a return but in A we don't get anything.
We can also say the postcondition is not compatible,  neither one is stronger or weaker,  so in that case it also not satisfies the requirement that sub post has to be stronger than super post

---

In-class 5A

<2021-10-04 Mon>


Iterator 

List<String> list  = new List<>();

list = [bat, cat, dog] ;

Iterator<STring> itr = list.iterator();   // iter = [b,c,d]

itr.next();    //return b ,   iter = [c,d]  so iter's contents can be stored in a STACK ADT 
itr.next();   // return c ,   iter = [d]
iter.hasNext(); return True,  iter =[d]
iter.next(); //return d ,   iter = []
iter.hasNext(); return False,  iter =[]
iter.next(); // raise Exception NSEE



next()
hasNext()
prev()
hasPrev() 

Iterator<STring> itr = list.iterator();     // itr.X = [b,c,d] itr.Y = []
itr.next(); // return b ,   itr.X = [c,d]   itr.Y = [b]
itr.next(); // return c ,   itr.X = [d]     itr.Y = [c,b]
itr.prev(); // return c,    itr.X = [c,d]   itr.Y = [b]
itr.prev(); // return b,    itr.X = [b,c,d] itr.Y = []
itr.prev() ; // raise NSEE ...


Iterator<STring> itr = list.iterator();     // itr.X = [b,c,d],  itr.nextCalled = False
itr.next() ;  // return b ,   itr.X = [c,d],   list = [b,c,d],  itr.nextCalled = True
itr.next() ;  // return c,   itr.X [d],  list = [b,c,d], itr.nextCalled = True

itr.remove(); //   itr.X = [d],  list = [a, d],  itr.nextCalled = False
itr.remove(); // raise ISE


public class Period {              
    private final Date start;
    private final Date end;

    /**
     * @param start the beginning of the period
     * @param end the end of the period; must not precede start
     * @throws IAE if start is after end
     * @throws NPE if start or end null
     */

    public Period (Date start, Date end) {
        if (start.compareTo(end) > 0) throw new IAE();
        this.start = start; this.end = end;  // Question 1
    }
    public Date start() { return start;}    // Question 2
    public Date end()   { return end;}      // Question 2

}


public class MyMaliciousClass extends Period{
    private Date myDate = new Date(0)

@override public Date start(){
    if (itsTime()){
        return myDate;  // this is mutable !
    }
    else{
        return super.start()
    }
}


public class LoanProvider{
    Period p;

    public LoanProvider (Period p, other stuff){
        this.p = p ; // no defense copy, Because Period is supposed to be immutable 
    }
}


Period m = new myMaliciousClass(); 
LoanProvider lp = new LoanProvider(m, ...) // will have start from myClass

















<2021-09-27 Mon>


F
F'

F == F'    F => F'  && F' => F


F =    x >= 5  && True && x >= 4
F' =   x >= 5  && x >= 4
F'' =  x >= 4  not correct
F''' = x >= 5

F = i >= 0 && N >= i
F' =   N >= 0

(i >= 0 && N >= i)  =>  N >= 0
N >=0  =>  (i >= 0 && N >= i)    (N=5,  i = 100)




(x >= 5 && x >= 4)   =>   x >= 4     TRUE
x >= 4   => (x >= 5 && x >= 4)   ? x = 4 
4 >= 4  =>  4 >= 5 && 4 >= 4
True =>  (False &&  True)
True =>  (False)

False


(x >= 5 && x >= 4)   =>   x >= 5   TRUE
(x >= 5)  => (x >= 5 && x >= 4)   TRUE 


"3-SAT" 

Convert Java/C++/Rust  => a (BIG) formula => 3-SAT (Verification condition)

Theorem Proving (SAT Solver,  SMT solver)


assignment
loop ()
...


NP-COMPLETE


Objects/ Classes

- analyze / verify method in ISOLATION
- M1,  M2, M3   ...
- M1,  M2,  M3   ... will not scale 

- Rep Inv

  IntSet, Poly

  Binary Tree
  - if a child != null (not leaf), then it will have 2 children
  - if a child == null (leaf), ...
  - constructor ,  ...  =>  valid BT (rep-inv will hold)
  - delete/add ,     => valid BT

  Binary Search Tree
  - content of the left child (node)  <= content of parent (node)
  -


class BinSearchTree:
    bool is_valid(...){
       ... 
    }
    
  
#+begin_src java
  public class Members {
      // rep-inv1: members != null

      // rep-inv2: members != null & no duplicates in members

      List <Person> members;   // the representation

      //  Post: person becomes a member
      public void join (Person person){
        if (!members.contain(person)){
          members.add(person);
        }
      }

      //  Post: person is no longer a member
      public void leave(Person person) {
        //rep-inv2 
          members.remove(person);

      }

    ...
  }

#+end_src

for each method : join and leave 
1. does it satisfy rep-inv1 ?  
   join: yes
   leave: yes
   
2. does it satisfy rep-inv2 ?
   join: no
   leave: yes

3. does it satisfy postcondition ?
   join: yes
   
   leave: NO if do not assume rep-inv2 (or no assumption)
          YES if do assume rep-inv2

3b.  if a method DOESNOT satisfy given rep, then do we need to check if satisfy the postcondition?
     no, if rep inv is broken, the code is wrong,  no need to check anything else
    
4. if the method doesn't method a rep inv,  modify the code so it does





abstract function:  toString()

Poly:


toString:  internal/concrete -> abstract  5x^4 + 3x^2




















Verifying methods class
- when analyzing a method, do not attempt to analyze other methods and their interactions
- will not scale
- should analyze each method in isolation
- use rep inv !

- Does the method establish and maintain rep-inv  ?
  - similar to inductive invariant (hold before and preserve through loop)
  - constructor: return obj satisfies the repr
  - mutator:  assume repr, maintain it 

Example :  Members.java

#+begin_src java
  public class Members {
      // Members is a mutable record of organization membership
      // AF: Collect the list as a set 
      // rep-inv1: members != null
      // rep-inv2: members != null & no duplicates in members

      List <Person> members;   // the representation

      //  Post: person becomes a member
      public void join (Person person) { members.add(person);}

      //  Post: person is no longer a member
      public void leave(Person person) { members.remove(person);}

  }
#+end_src
  - does method maintain rep-inv ?   does it satisfy the contract?
    - if the first one fails,  no point to do the rest

  - ~members != null~
    - join:  yes,  no assignment to members, we just add things to it,  so if it was not null when we enter the method then not null when we exit the method.
      - yes, satisfy the contract, because person becomes a member
    - leave: yes, maintain inv;
      - no, does not satisfy the contract (we haven't looked at or assume the duplicate repr inv)
      - to "repair" this,  we can do something like
        while (members.contains(person)){
           members.remove(person);
        }
      
  - ~members !=null and no duplicates~  (stronger)
    - join:  NO,  doesn't check if input person already a member. Counterexample ?
      - since doesn't preserve the repr, so don't care about contract 
      - repair: check if a person already a member, 

        
    - leave: yes, maintain repr inv
      - yes, satisfy the contract (using the repr,  person only in the list no more than once)


- Poly example
  #+begin_src java

    public class Poly {
    // Polys are immutable polynomial c0+c1x + c2x^2 + ..
    
        private int[] trms;
        private int deg;

        // Effects: returns the degree of this
        public int degree() {
           return deg;
        }
  #+end_src
  
<2021-09-20 Mon>
* * Lecture 4-1



Verification

- Testing
  - Dynamic Analysis: analyze the program runs
  - Run the program on some inputs ...
  - Strength: Fast, does not need to analyze complex code , ...
  - Weakeness:  could miss corner cases, ...
    
- Verification
  - Static Analysis: analyze the source code (AST, Bytecode ...)
  - Do not run the program 
  - Strenghths: attemp to reason about the program on *all* possible inputs
  - Weakenesses: slow, infeasible, analyze the program source code
  - For certain domains or applications, failure is not an option
    - Airbus :  ASTREE
    - NASA:  ...
    - Facebook
    - Amazon AWS: Amazon Formal Methods
    ... 
    
- Facebook INFER
  - Verification tool 
  

"Program testing are used to show the presence of bugs, but never to show their absence"  -- Dijkstra 1972 

- Hoare Logic
  {P} S {Q}    : Hoare tripple
  - Read:  assume P holds,  if S successfully executes, then Q holds
  - (Sir) Tony Hoare
    - Quick sort
    - NULL Pointer (billion dollar mistake)
    - Dining Philosopher / Monitor

{True} x := 5; {x=5}   // strongest postcondition
{True} x := 5; {True}
{True} x := 5; {x >= 0}
{True} x := 5; {x >= 5} // x=5 OR x=6 or X... 


{x == y}  x:= x + 3 {y = x - 3} // strongest condition
{x == y}  x:= x + 3 {x >= y}
{x == y}  x:= x + 3 {x > y}

{x > -1}  x:= 2*x + 3  {x <= 3} // X 
{x > -1}  x:= 2*x + 3  {x >= 1}    x = 1 OR x= 2 or X=3 ......  

{x > -1}  x:= 2*x + 3  {x >= 3} // STRONGEST post condition

x = 0  ...  x = 3    x >= 3
x = 1  ...  x = 5
x = 2 ...   x = 7
.....

{x==a}  if x < 0: x = - x {x == |a|}
{True}  if x < 3: x = 10 else: x = 20  { x == 10 || x == 20 }

{False} x := 3 {x != 3}
{False} x := 3 {False}
{False} x := 3 {x= any int}

{x < 0}  while(x!=0) x:= x - 1 {X < 0}
{x < 0}  while(x!=0) x:= x - 1 {ANYTHING}

Partial Correctness: 
- Talk about compilers if have time   
  - assume P holds,  *if* S successfully executes, then Q holds


{True} x := 5 {x=5 or x= 6 or x > 6}  *valid*
{True} x := 5 {x > 6}  *invalid* 
{x == 5}  x += 2  {x < 7}  # x == 7 does not imply *x < 7*


{x < y} z:= x/y  {z < 1}   *Invalid* y=0 
{x = 0} z:= x/y  {z < 1}   *Invalid* x=0, y=0 
{y != 0} z:= x/y  {z < 1}  *Invalid* x = 2 , y =1  
{x < y & y != 0} z:= x/y {z <1} *invalid*   x=-2,  y=-1

{0 < x < y & y != 0} z:= x/y {z <1} *valid*   weakest precondition 
{x = 1 & y = 2} z:= x/y  {z < 1}  *Valid*  
{x = 2 & y = 4} z:= x/y {z <1} *valid*



** Verification using Hoare logic
- To prove ={P}  S  {Q}=  is valid,   we check if  ~P =>  WP(S, Q)~
  - `WP`: a function returning the weakest precondition allowing the execution of S to achieve Q

- S is an ASSIGNMENT statement 
  - WP(x := E, Q) = Q[x/E]
    WP(x := 3, {x + y = 10}) =  3 + y = 10  =   y = 7
    
  - {y==7} x := 3 {x + y = 10}

    WP(x := 3, {x + y > 0) =  3 + y > 0  = y > -3
  - {y > -3}  x := 3 {x + y> 0}

- S is a LIST of Statements
  - WP(S1; S2; S3 ...;  Q)  = WP(S1, WP(S2;S3;.., Q))
  - wp(x:=x+1; y = y*x, {y=2*z})

    {y*(x+1)=2*z} x:=x+1; {y*x=2*z} ; y := y*x, {y=2*z}

    wp(y:=y*x, {y=2*z}) =  y*x=2*z
    wp(x:=x+1, {y*x=2*z}) = {y*(x+1)=2*z}

    WP(x:=x+1, y=y*x, {y=2*z}) = WP(x:=x+1,WP(y=y*x, {y=2*z}))
                               = WP(x:=x+1, {y*x=2*z})
                               = {y*(x+1)=2*z}

- S is CONDITION
  wp(...)
  
- S is a LOOP                               
  - {x <= 99 or x = 100} while (x < 100) x = x+ 1; {x=100}
  - {x <= 100} while (x < 100) x = x+ 1; {x=100}
  - WP(while, Q) = loop invariant of the while loop

     - *Loop invariant*: captures the meaning of the loop (manually provided by you)
        -  property that holds when the loop entered 
        -  is preserved after the loop body is executed  (inductive loop invariant)


#+begin_src java
  {N >= 0}

  {0 <= N}
  i := 0 ;

  {i <= N}//wp for the while loop below wrt to Q= i == N using i <= N
  {False} //wp for the while loop below wrt to Q= i == N using N >= 0

  //LOOP INV:  i <= N
  //LOOP INV: i <= 0  # NOT LOOP INV
  //LOOP /inv : i>=0 
  //LOOP INV :  N >= 0
  //LOOP INV:  TRUE

  while(i < N){
      i := N;
  }

  {i == N}

#+end_src

- WP(while[I] B do S,  {Q}) =
   1. I and
   2. (I &b) => wp(S,I)
   3. (I &!b) => Q

- using ~i <= N~ as loop invariant to prove program
  - wp(while[i<=N] i < N do i:=N, {i == N}) =
    1. ~i <= N~
    2. ~(i <= N & i < N)   => wp(i:=N, {i<=N})~
       ~i < N  =>   N <= N ~
       ~i < N =>  True~
       ~True~
       
    3. ~i <= N & !(i<N) => i == N~
        ~i == N => i == N~
        True
        
    =  ~i <= N~

~wp(while[i<=N] i < N do i:=N, {i == N}) = i <= N~


wp(i:=0; {i<=N}) = 0 <= N

P => wp(...)
N>=0  => 0 <= N

- using ~N >= 0~
- wp(while[N >= 0] i < N do i:=N, {i == N}) =
  1. ~N >= 0~
  2. ~(N >=0 & i < N) => wp(i := N, N >= 0)~
      -   ~(N >=0 & i < N) => i >= 0~
        
  3. ~N >=0 & !(i<N) => i ==N~
     ~(N >= 0 & i >= N) => i == N~
     ~i>= 0  => i == N~
     ~False~
 =  False  
 

N >= 0 => False   N= 5    = True => False     !True or False  = False or False  = False
False 

Demorgan Law

a => b   ==  !a or b


!a or True  == True
!a or b
!(i == N)  or (i==N)  = True

a and b and c

b == true  =>  a and c















  
  

* Lecture 4
**  Reflection
   - Invariants
   - Invariants vs Precondition
   - toString:  abstraction function that takes internal representation (e.g., arrays, vectors) and abstract it for the client (e.g., polynomials)
   -  Correctness
     - Testing vs Verification
     - Dijsktra
     - Satisfy contracts (specifications)
** Verification
   - Verification vs Testing: very different
   - Testing: correct over sample inputs
     - number of inputs is infinite ,  so can only sample a small finite set
   - Verification: the implementation is correct with respect to the specification.
     - Correctness: Mathematical definition, a proof
     - Theorem proving ..

** Abstract Function and RepInv
      - Abstraction Function:  maps rep internal data to the astract object
        - e.g., Liskov's PolyClass (uses arrays)  => mathematical polynomial objects
        - =toString= is often used as an abstraction function
      - Rep invariant:
        - Example:  binary tree (2 children),  binary search tree (binary tree and lc <= rc),
        - IntSet:
          #+begin_src java
            // c.els ≠ null &&
             // (all elements of c.els are integers)
            // for all integers i. c.els[i] is an Integer && 
            // for all integers i , j. (0 <= i < j < c.els.size ⇒
            // no duplicates in c.els
            //     c.els[i].intValue ≠ c.els[j].intValue )
          #+end_src
        - =repOK= use to check rep invariant (used in various constructors and methods to check if the rep invs are establish or preserved)

          
** OO Verification
    - Main keys to verification
      - verify each method one by one,  once verified wrt to the contract,  we can now just use the contract
   
   - establish or maintain rep invariant
          - constructor: establish rep invariants
          - mutator:  maintain/preserves the rep invariants
          - inductive :  constructor(base) inductive case (muttator)
      - Contract:
        - given rep inv as assumption, given preconditions as assumptions, does postcondition hold?

    - Verification diagram
      Abstract Stage (Poly, Set)

        
<2021-09-13 Mon>

Lecture 3
RECORD
HW2:
- Pick some volunteer  (example code: https://www.youtube.com/watch?v=dacJdCgm-dM  5:31)

TEAM 2

- should not have checks or code for precondition (it’s assumed )
- contracts format
    - javadoc (preferred)
    - Liskov (effects, modifies etc)
- Report all errors at once or one by one 
    - no standard
    - one by one (compilers style)
- Reflections
    - Immutable: Many mention threat safe as an advtange of immutable;  also easy to compare
    - Mutable: may be faster, doesn't have to recreate the whole thing when changing something

*immutability over mutability?*
1. Prevents corruption of objects and the data they hold as the object cannot be updated.
2. Data is predictable. Once created cannot be modified.
3. Comparing two immutable objects is easier. We can just compare the reference of the object.
4. Immutable objects are thread safe and is useful to share data in multithreaded applications.
5. Testing: Testing will be easy for immutable objects.

*o mutability over immutability?*
1. Mutable objects can be used when we do not know the actual size of the input data. Size can be
variable which is an advantage of mutable objects over immutable objects.
2. Objects can be modified post its creation. This memory efficient as we just update the reference
instead of creating a new object.
3. Mutable classes provide methods to update the data.


# - Data abstraction
#     - Creators: create objects (constructors are special kinds of creators)
#     - Producers: (???)
#         - create objects of their type based on existing objects
#         - typically used in immutable data types
#     - Mutators:
#         - modify objects of their type
#         - typically used in mutable data types
#     - Observers
#         - 
# - Disadvantage: Performance
#     - typically approach:  provide both Immutable and muttation. 
#     - E.g., Java library:
#         - String (Immutatble)
#         - StringBuilder (companion mutable class)

- Poly.java :  show the code
    - What is a polynomial ? Ask student
        - Should describe high level (client perspective), not implemented
        - Wikipedia: expressions consisting of terms, which are variables and coefficients
        - Also involve operations such as mult, addition, subtraction, non-neg int exponentiation
    - How to implement polynomial?  
        - Coef:  integer coef
        - Exponent:  non-neg ints
        - 1 variable (just x) 
    - Poly code
        - Effects (Poly constructor):  would it be ok if we say “initialize array to 0 and such”,  no it’s wrong,  it’s implementation level,  not specification 
        - Think about this as “if I change my code,  would the specification still hold?”  If yes, then specification is good, otherwise,  incorrect 
    - ADD:
        - why so ugly?
        - Because she has a constraint such that doesn’t trailing zeros …
        - last thing in array is a non-negative coefficient
- In class exercise: 2A QUEUE 
    - Queue is currently mutable
    - convert it to immutable
    - ALSO put/change the contracts on both the ORIGINAL (mutable version) and immutatable version
    - 30 mins
    - 
   #+begin_src java

     public class Queue <E> {

         private List<E> elements;
         private int size;

         public Queue() {   
             this.elements = new ArrayList<E>();
             this.size = 0;
         }

         public void enQueue (E e) {
             elements.add(e);
             size++;
         }

         public Queue<E> enQueue_producer (E e) {
             Queue<E> queue = new Queue<>();
             queue.elements.addAll(this.element);
             queue.elements.add(e);
             queue.size = this.size + 1;
             return queue;
         }

         //Effect: remove and return the front element of queue (this)
         //Modifies: contents of queue
         //@throw ISE if queue is empty  (DO NOT USE SIZE)
         public E deQueue () {
             if (size == 0) throw new IllegalStateException("Queue.deQueue");
             E result = elements.get(0);
             elements.remove(0);
             size--;
             return result;
         }

         //Effect: return a queue that is like this but without the front element
         //Modifies: none 
         //@throw ISE if queue is empty  (DO NOT USE SIZE)
         public Queue<E> deQueue_producer () {
             if (size == 0) throw new IllegalStateException("Queue.deQueue");

             Queue<E> queue = new Queue<>();
             queue.elements.addAll(this.element);
             //E result = queue.elements.get(0);
             queue.elements.remove(0);
             queue.size--;
             return queue;//return result


         }

         public boolean isEmpty() {
             return size == 0;
         }

     }

     public static void main(String [] args){
         Queue <String> q = new Queue<>();
         q.enQueue("cat");
         q.enQueue("dog");
         q.deQueue();// return cat 
     }
   #+end_src


*** Invariants:
**** definition    
**** Invariant locations :
     - at the end,  post condition 
     - loop invariant
       - hold at the loop entrance
       - preserves through the loop body
         
     #+begin_src 
      {N >= 0}

      i = 0
      while (i < N):
         i++

# loop invs
# i < N   # not a loop invariant because at first loop entrance, when N = 0  ,  i is NOT < N
# i >= 0 # YES , loop inv
# N >= 0   #  YES, loop inv
# i <= N   # YES, loop inv 

#  N >= -10
#  N >= -11000

     #+end_src



AF:  mapping from (concrete state) representation state to abstract state  (often many to 1,  why, because abstractions forget details)

    e.g.,  (2, [5,0,3])  ->  5 + 3x^2
           (2, [5,0,3,0])  -> 5 + 3x^2   ... but Liskov's implementation not allows this

     rep-inv: implementation details !!!! talk about the specific representation (programmer/Liskov's choice)
     
     #+begin_src txt
     trms != null
     terms.length >= 1
     deg = trms.length - 1
     deg >= 0  =>  c.terms[deg] != 0

     #+end_src

     
Option to 
- Multiple Share screen
- Allow people to join to break out rooms

<2021-08-26 Thu>
** Quiz:
   binary search
   - write pre/post/modifies
   - total vs **

partial Reflection:
   - precondition (purely specification):  undefine behavior
   - exception (more implementation): turn undefine behavior into defined ones
   - checked exception (i.e. these that you should explicitly catch or rethrow):
     - Block: To summarize, throw checked exceptions for recoverable conditions and unchecked exceptions for programming errors. When in doubt, throw unchecked exceptions.
     - Liskov:
       - You should use an unchecked exception only if you expect that users will usually write code that ensures the exception will not happen, because
        • There is a convenient and inexpensive way to avoid the exception.
        • The context of use is local.
       - Otherwise, use checked

Otherwise, you should use a checked exception.
     Most prefer Bloch's ...
   - security:
     - some group mention about parseHttpRequestLine ..
     - fuzzing : generating weird, unexpected inputs ... hoping for weird/undefined/unexpected behaviors that can be exploited

** Contract
   (powerpoint)
   - {P} S{Q}:  Hoare tripple
     - P , S, Q
     - assume terminaton
     - customer (client) needs to establish P
     - Implementer (service) assume P
     - Implementer needs to establish Q (assume P)
     - Customer assumes Q
     - Bug: if both client/server do their job: good
     - if precondition is not satisfied, customer is wrong (client has bug)
     - if postcond is not satisfied, implementer is wrong (service has a bug)

   - sqrt example:
     sqrt(x):
        pre:  x >= 0
        what if x is negative?
        post:  r*r = x +/ epsilon

   - Precondition:
     - as weak as possible  (True is the weakest)
     - but lots of work, so Server prefers STRONGER (e.g., sqrt example:  if pre is weak/nothing, then SERVER has to handle more corner cases,  if if pre is stronger (e.g., x >= 0) , then SERVER doesn't have to handle as much
       
   - Postcondition:
     - as strong as possible  (False is the strongest)
     - but lots of work !  so Server prefers WEAKER post conditions (less things to do),  e.g.,  if post for sqrt is just return a number, then very easy


     
** Abstraction
   - focuses on what (not how)
     - signature: formal parameters, return types, etc
     - isPrime:  detemrine if arg is prime is important ,   how this is determine is irrelevant
** Specifications/Contracts
   
   - Informal (English, remove example): easier to write but vague
** Signatures/Header
   - requires/modifies/effects   in comments
   - requires/precond: partial vs total  (partial: only for certain input so have require/preconditions,  total: for all correct type inputs, so precondition is TRUE, i.e. no precondition/require clause)
   - modifies: input modification -> side-effect
   - effects/postcond:  under assumption that requires are satisfied  (x' or x_post)
   - Precondition: weakest is best,  nothing (i.e., True) is even better
   - weaker vs stronger

** Implementation
   - Adhere to specifications
   - weaker vs stronger  , e.g., if specification says return a number, then always return 3 is ok.  but if specification says return an odd number, then cannot return any number.
   - 
     
** Exception (Bloch item 69)

** Checkvs vs Unchecked (Bloch item 70)
   - check exception:  recoverable
     - force the caller to handle the exception
     - IOException:  file not found,  well probably can have a backup , default one       
   - unchecked exception:
     - recovery not possible
     - NPE: if you pass me a null pointer, and I try to dereference it, well then I should get NPE.  Not much I can do to turn a null pointer into a non-null pointer.  
       



** Item76: Strive for Failure Atomicity
   - failed method invocation should leave the object in the state that it was prior to the invocation
   - ways to achieve this
     - design immutable objects (tuples, string vs arrays, set)
       - performance, easy to reason about that (will spend more time later)
     - check the inputs
     - order the computation : parts that fail come before modification
     - write recovery code:  allow objecet to roll back its state
     - perform the operations on temporary copy of the object



** WARNING: will make people share your answers ...
   Look at Javadoc for ArrayList
   

** in class 1A

#+begin_src java
public static List<Integer> tail (List<Integer> list) {

    // REQUIRES: ???
    // EFFECTS:  ???
  if(list.size() == 0) throw new IllegalAccessException() ..
    List<Integer> result = new ArrayList<Integer>(list);
    result.remove(0);
    return result;
}
#+end_src


https://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html


- what does it do?

- write partial specs for happy paths (where it works) ,
  A: last 2 cases
- rewrite to be total.  A: add addition things to postconditions so that we can remove preconditions
  @throws NPE if list is null
  @throws IOOBE if list is empty (because of remove in javadoc)

  
- IOBE :  does not match the exception (if list is empty, throw IOB)

- instead of IOBE,  throw IllegalAccessException

- no need to do nullpointer exception because .size() will throw   

  
** In class 1B (20 mins)



-----


- turn on recording

- introducing myself (in NE, taught compilers etc)

- SCHEDULE
  - give plenty of time to read the assignment,  might have few pages, but lots of stuff in there


** <2021-08-23 Mon>
   - Correctness:
     -- specification  or contract ...
     -- code is correct if it satisfies the contract
     -- if you give it no contract, well then anything would be correct
     -- so you want strong and precise contract

     
     
   - Pre/Post conditions

   - sort list  : 
     - preconds:  input is a list of *comparable* items
     - postcond:
       - output is sorted
       - output is a permutation of data input






   - =void remove()=
     Removes from the underlying collection the last element returned by this iterator (optional operation). This method can be called only once per call to next(). The behavior of an iterator is unspecified if the underlying collection is modified while the iteration is in progress in any way other than by calling this method.

   Throws:
   - UnsupportedOperationException - if the remove operation is not supported by this iterator
   - IllegalStateException - if the next method has not yet been called, or the remove method has already been called after the last call to the next method


   List<String>l = ... // [cat, dog, mouse]
   Iterator<String> itr = l.iterator();

   itr.next();    // cat
   itr.next(); // dog


   itr.next();  // cat
   l.add("elephant");
   itr.next();  // anything can happen, depends on Java implementation,  probably return an exception (Concurrent modification)

* INCLASs object   
  - Group break out , do in-class ,  45 mins
  - turn recording OFF

  - after break,  turn on recording



