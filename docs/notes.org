* Notes
:PROPERTIES:
:CUSTOM_ID: notes
:END:
** Week 1
:PROPERTIES:
:CUSTOM_ID: week-1
:END:
- Syllabus
  - No cheating
- Correctness:
  - specification or contract ...
  - code is correct if it satisfies the contract
  - if you give it no contract, well then anything would be correct
  - so we want strong and precise contract

*** Method/Program specifications
:PROPERTIES:
:CUSTOM_ID: methodprogram-specifications
:END:
- Preconditions: assumptions, properties about the inputs
  - established by clients (e.g., inputs are strings, unsorted list,
    ...)
- Postconditions: properties/behaviors of the method/program (usually
  related inputs)
  - done/established by the developers/implementations (e.g., outputs
    are sorted list, ...)
- When something goes wrong, *who to blame*?
  - If preconditions are incorrect: blame the clients
  - If preconditions are correct, and the postconditions are not
    correct: blame developers
- Pre/Post conditions
  - specs/contracts consist of pre and postconditions
    - preconds (or requires)
    - postconds (or effects)
  - Example: __sorting a list_
    - preconds: input is a list of /comparable/ items
    - postcond:
      - output is sorted
      - output is a __permutation_ of data input
  - Precondition
    - as weak or general as possible
  - Postcondition
    - as strong or precise as possible
- In class exercise
  - Equality (=__equals__= in Java or =_eq_= in Python)

** Week 2 More on Specifications
:PROPERTIES:
:CUSTOM_ID: week-2
:END:

*** Weaker Preconditions and Stronger Postconditions
:PROPERTIES:
:CUSTOM_ID: weaker-preconditions-and-stronger-postconditions
:END:
- Reconsider the =intdiv= example from previous class

#+begin_src java
int intdiv(int x, int y){
  /*
  Return the integer division result x/y.
  

  precondition 
  - 
  -
  
  postconditions
  - if x or y are not integers, raise Exception
  - z is a number
  - z is an integer
  - if y is 0, then raise an Exception 
  - z*y ==  x
  */

  if not typeof(x, Int): raise 
  if not typeof(y, Int): raise     
  if (y == 0){ // raise ...
     ...     
  }
  return z
}
#+end_src

#+begin_example
preconds:
- x and y are integers # (already given in type)
// - y cannot be zero   # better if we can remove this

postconds:
- z is a number  # weak
- z is an integer  # weak
- z = x // y  # *strong*
,*/
#+end_example

If we have =S1 = P => Q= and =S2 = P' => Q'=, then - S1 is better than
S2 : if P is weaker than P' - S1 is better than S2 : if Q is stronger
than Q'

*** Partial vs Total Contracts/Specifications
:PROPERTIES:
:CUSTOM_ID: partial-vs-total-contractsspecifications
:END:
- /partial/ specification: has a precondition

- /total/ specification: has NO precondition

- to turn a partial spec into a total spec:

  - for every precondition, remove and turn it into a new behavior in
    postcondition (of the form if not precondition, then do something,
    e.g., raising an excpetion)
    - E.g., if we have a precondition =list= cannot be =null=
    - Then we remove that precondition
    - And create the postcondition: if list is null then raise
      NullPointerExeception

- in the implementation, create conditions and raise exception

*** Check vs Unchecked Exception
:PROPERTIES:
:CUSTOM_ID: check-vs-unchecked-exception
:END:
- precondition (purely specification): if violated can gives undefine
  behavior
- exception (more implementation): turn undefine behavior into defined
  ones
- *checked exception**
  - things that you should explicitly catch or rethrow
  - Block: throw checked exceptions for __recoverable conditions_ and
    /unchecked exceptions/ for programming errors. When in doubt, throw
    unchecked exceptions.

*** Check vs vs Unchecked (Bloch item 70)
:PROPERTIES:
:CUSTOM_ID: check-vs-vs-unchecked-bloch-item-70
:END:
- check exception: recoverable
  - force the caller to handle the exception
  - IOException: file not found, well probably can have a backup ,
    default one
- unchecked exception:
  - recovery not possible
  - NPE: if you pass me a null pointer, and I try to dereference it,
    well then I should get NPE. Not much I can do to turn a null pointer
    into a non-null pointer.

*** Abstraction
:PROPERTIES:
:CUSTOM_ID: abstraction
:END:
- focuses on what (not how)
  - signature: formal parameters, return types, etc
  - isPrime: detemrine if arg is prime is important , how this is
    determine is irrelevant

*** Specifications/Contracts
:PROPERTIES:
:CUSTOM_ID: specificationscontracts
:END:
#+begin_example
int foo(string s, char d): ... 
 // pre: 
 // post
 // modify: s
 ....
 //implementation
  ..
 return 
#+end_example

*** Signatures/Header
:PROPERTIES:
:CUSTOM_ID: signaturesheader
:END:
- requires/modifies/effects in comments
- requires/precond: partial vs total (partial: only for certain input so
  have require/preconditions, total: for all correct type inputs, so
  precondition is TRUE, i.e.Â no precondition/require clause)
- modifies: input modification -> side-effect
- effects/postcond: under assumption that requires are satisfied (x' or
  x_post)
- Precondition: weakest is best, nothing (i.e., True) is even better
- weaker vs stronger

** Implementation
:PROPERTIES:
:CUSTOM_ID: implementation
:END:
- Adhere to specifications
- weaker vs stronger , e.g., if specification says return a number, then
  always return 3 is ok. but if specification says return an odd number,
  then cannot return any number.
- 

IC2a 3. total specs

* pre: Nothing
:PROPERTIES:
:CUSTOM_ID: pre-nothing
:END:
* post:
:PROPERTIES:
:CUSTOM_ID: post
:END:
1. if input list is null/None, throw NullPointException
2. if input list is empty, throw Exception (or return [])
   - don't say anything about IndexError as that requires an Index-based
     datastructure in the implementation
3. return the original list in the same order without first element
4. remove the first element and return the rest: WRONG, X, too
   implemntation specific

* side-effects
:PROPERTIES:
:CUSTOM_ID: side-effects
:END:
- Nothing

4. [@4] 

hasNext() Method: -Preconditions: Nothing explicitly mentioned in the
Iterator interface documentation. It is generally assumed that the
iterator is positioned at a valid element or at the end of the
collection.

- Postconditions:
  - Returns true if there is at least one more element in the
    collection; otherwise, returns false.

next() Method: - Preconditions: There is at least one more element in
the collection. indicating the end of the collection. - Postconditions:
Returns the next element in the collection. The iterator is moved to the
next position.

- Violation Example:
  - Calling next multiple times without calling hasNext to check if
    there are more elements.
  - Calling next when hasNext returns false,

remove() Method: - Preconditions: next() has been called at least once
after the last call to remove. - Violation Example: Calling remove
without first calling next. Postconditions: Removes the last element
returned by next from the underlying collection. - Violation Example:
Calling remove multiple times consecutively without calling next in
between.

** Week 3: Automatic Verification and Hoare Logic
:PROPERTIES:
:CUSTOM_ID: week-3
:END:


*** Quiz 1: Binary Search
- precondition:
  - arrays: sorted, cannot null,
- postcondition:
  - if x not in arrays: raise some exception ...
  - ow: returns index of x in array


- **Prev lectures**: about specifications and contracts
  - Written in English, human language
  - Manual check that implementation and specification are consistent (e.g., run the program, return exception ~X~, see if ~X~ is in the postcondition)
    - **Pros**: easy to do
    - **Cons**: manual, time-consuming, error-prone  (imagine having to do this with real-world programs)
- **Today**: automatic verification
    - You: provide specifications (pre/postconditions)
    - Computer: **automatically** check if implementation is correct wrt to specifications
    - **Pros**: automatic, fast, no human error
    - **Cons**: hard to do, requires some knowledge of logic
    - Formal Methods
    - Industry:  used in many places (e.g., Facebook, Amazon, NASA, Airbus, ...)

- **Hoare logic**: The classicial logic for program verification


*** Logic Primer
:PROPERTIES:
:CUSTOM_ID: logic-primer
:END:

- **Satisfiability**

  - formula ~f~ is **satisfiable** if there is some assignment to the values in ~f~ that makes ~f~ evaluate to ~True~.
  - ~f~ is **unsatisfiabile** is there is no such assignment.
  - Examples
    - x <= 6 or y = 3  is satisfiable  (e.g., x=4, y=3)
    - x > 6  and  y = 3 is SAT (e.g.,  x =7, y=3)
    - x > 6  =>  x > 1   is SAT (e.g.,  x=7)
      - x = -1
      -  False => False: True
      -  True => False: Not possible
    - x > 6 and x < 5  is UNSAT

    - 3-SAT: (x || y | z)  && (!x || y || w )  &&  .....
    - NP-Complete: Nondeterministic polynomial
     - Graph Coloring
     -


 - **valid (tautology)**
    - f is a tautology if f evaluates to True for *every* assignment (f is *always* satisfiable)
    - Examples
      - x > 6  =>  x > 1   is valid
      - x = x  is valid

  - **falsification**
    - f is a *falsification* if f elvalues to False for *every* assignment (f is *always* unsat)
    - Examples
      - x > 6  and  x < 5   is falsification
      - x != x  is falsification
      - x == x + 1 (assuming x is a finite number,  why ?  because if x = some infinite number, then x = x + 1 would True)


- Implication can be tricky (e.g., x > 6  =>  x > 1)
   - a => b   =  !a or b

   - f => f      =  Valid    (!f or f)
   - f => True   =  Valid    (!f or True)
   - True => f   = Not Valid  !True or f  = False or f   =  f
   - f => False   =  Not Valid       !f or False   = !f
   - False => f  =  Valid      !False or f  =  True or f  = True

**** Using Z3 to check satisfiability


*** Hoare Logic
   - Tony Hoare: Sir. Hoare, quick sort, verification, ...
     - medical (surgeries), airplan, weapons, ...
     - Hardware design (CPU)
     - Airbus:  verification to check floating errors do not occur A380 ...
     - NASA:  Rovers  (symbolic execution)
     - Facebook Newsfeed :  verification (currency), Instagram
     - Amazon AWS :  cloud computing

   - automatic verification that a program ~S~ is correct with respect to precondition ~P~ and postcondition ~Q~


**** Hoare tripple: {P}  S  {Q}
     - Precondition: P
     - Postcond :  Q
     - S :  program (a list of statements)
     - Hoare tripple is valid: if P holds, and the successful execution of S results in Q
       - S is correct with respect to P and Q

   - Testing  S,  P , Q

     Goal: given a program S,  {P, Q},  check if S is correct wrt to P, Q
     - testing: finding some bug:  want to find if there is some (bad) input that satisfy P,  but doesn't satisy Q
       - pros: quick , test it on some finite number of inputs (K,M,B ..)
       - cons: if the test shows no bug, DOES NOT mean the program really has no bug

"Testing shows the presence of bugs, not its absence" -- Dijkstra

"Verification shows the absence of bugs, not its existence" ...

     - verification: want to show there exist no bad input that satisfies P but violates Q
       - pros: if verification tool shows no bug, then DOES mean program has no bug
       - cons: runs slowly (have to consider all possible inputs)

def foo(x:int):
  {True}
  y = x
  y += 1;
  {x <= y}
  {x == y - 1}

*** [[https://github.com/dynaroars/dynaroars.github.io/wiki/notes-hoare-logic][See complete notes on Hoare logic here]]


*** In-Class
:PROPERTIES:
:CUSTOM_ID: in-class
:END:

*** Quiz
