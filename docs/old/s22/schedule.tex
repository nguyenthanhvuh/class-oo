% Created 2021-10-18 Mon 10:19
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{ThanhVu (Vu) Nguyen}
\date{\today}
\title{SWE 619 Course Schedule and Assignments}
\hypersetup{
 pdfauthor={ThanhVu (Vu) Nguyen},
 pdftitle={SWE 619 Course Schedule and Assignments},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.2 (Org mode 9.4.4)}, 
 pdflang={English}}
\begin{document}

\maketitle
\setcounter{tocdepth}{1}
\tableofcontents


\section{Schedule}
\label{sec:org4916eff}

\begin{itemize}
\item \textbf{Notes}: Except for the first class, students are expected to complete the reading \textbf{prior to class} on listed meeting. Quizzes may occasionally take advantage of this expectation.

Homework assignments are \textbf{due} on the date listed. Quizzes are posted, with solutions, on Piazza following the class in which the quiz is given.
\end{itemize}

\begin{center}
\begin{tabular}{rllcc}
Meeting & Topic & Reading & Assignment/Quiz Guide & In-Class Exercise\\
\hline
1 & Class Overview & Liskov 1--2 &  & IC \hyperref[sec:org748dd31]{0}\\
2 & Procedural Abstraction; Exceptions & Liskov 3--4, Bloch 10 & \hyperref[sec:orgb85722c]{A1 Due}; \hyperref[sec:org609e664]{Guide 1} & IC 1 \hyperref[sec:org629117e]{A} \hyperref[sec:org88b0623]{B}\\
3 & Data Abstraction; Mutability & Liskov 5.1--5.4, & \hyperref[sec:orgfbf8dc5]{A2 Due}; \hyperref[sec:orgb776807]{Guide 2} & IC 2 \hyperref[sec:org6c8dcae]{A} \hyperref[sec:orgc5a4384]{B}\\
4-1 & Program Verification & \href{https://nguyenthanhvuh.github.io/posts/program-analysis-notes.html}{Hoare logic notes} & \hyperref[sec:org645b614]{A4-1 Due}; \hyperref[sec:orgc575334]{Guide 4-1} & \hyperref[sec:org6f6e901]{IC 4-1}\\
4 & Reasoning About Data Abstraction & Liskov 5.5-5.10 & \hyperref[sec:org853ad5b]{A3 Due}; \hyperref[sec:orga829d7c]{Guide 3} & IC 3 \hyperref[sec:org450d1ac]{A} \hyperref[sec:orga9deffd]{B}\\
5 & Interation Abstraction; Method Guidelines & Liskov 6, Bloch 8 & \hyperref[sec:orgc646439]{A4 Due}; \hyperref[sec:orgb1584d3]{Guide 4} & IC 4 \hyperref[sec:org873a6b0]{A} \hyperref[sec:org8a1b731]{B}\\
6 & Type Abstraction & Liskov 7 & \hyperref[sec:orga934bb3]{A5 Due}; \hyperref[sec:org86cae61]{Guide 5} & IC 5 \hyperref[sec:org4d8c866]{A} \hyperref[sec:orgfe7ef1b]{B} \hyperref[sec:orgeeef43a]{C}\\
7 & Mid-semester Recap & \emph{No New Material} & \hyperref[sec:orgc528c10]{Guide 6} & IC \hyperref[sec:org8451126]{6}\\
8 & Polymorphic Abstract; Lambdas & Liskov 8, Bloch 7(Item 42) & \hyperref[sec:orgd546b4d]{A6 Due}; \hyperref[sec:org3a88e25]{Guide 7} & IC \hyperref[sec:org32be849]{7}\\
9 & Generics & Bloch 5 & \hyperref[sec:org5d1a5c5]{A7 Due}; \hyperref[sec:org3b1a2ca]{Guide 8} & IC 8 \hyperref[sec:org9f29a82]{A} \hyperref[sec:org50147d0]{B}\\
10 & Common Java Contracts & Bloch 3 & \hyperref[sec:org3b589ce]{A8 Due}; \hyperref[sec:org28a3f01]{Guide 9} & IC 9 \hyperref[sec:org94da596]{A} \hyperref[sec:org9981d50]{B}\\
11 & Classes and Inheritance & Bloch 4 & \hyperref[sec:orgf89b975]{A9 Due}; \hyperref[sec:orgcc316de]{Guide 10} & IC 10 \hyperref[sec:orgbbdf573]{A} \hyperref[sec:org2036435]{B}  \hyperref[sec:org87161aa]{C}\\
12 & Contract Model in Testing & Advanced JUnit (slides 22-24) & \hyperref[sec:org223d54f]{A10 Due}; \hyperref[sec:orgb293768]{Guide 11} & IC \hyperref[sec:org3711f95]{11}\\
13 & Enums and Annotations & Bloch 6 & \hyperref[sec:orgf91f5c7]{A11 Due}; \hyperref[sec:org822f6d8]{Guide 12} & IC 12 \hyperref[sec:org16fff9b]{A} \hyperref[sec:org0aeee0d]{B}\\
14 & Course Wrap Up & Final Exam Notes; Code for final &  & IC \hyperref[sec:org68e00cb]{13}\\
15 & Final Exam @ 4:30 & \emph{Online} &  & \\
 &  &  &  & \\
\end{tabular}
\end{center}

\section{In class Assignments}
\label{sec:org6b7be15}

\subsection{In class 1}
\label{sec:org748dd31}
Work with your group and do the following:
\begin{enumerate}
\item Spend a few minutes getting acquainted. Explain a bit about yourself: full-time student?, working in software development?, why are you taking this class?, favorite/least favorite thing about writing software?, etc.
\item Decide on a mechanism for joint communication. Google docs? IDE with screen share? Something else?
\end{enumerate}

Now address a technical topic. This exercise touches on some of the thorny issues in data abstraction and inheritance. There is a lot going on in this example. Hence don't worry if it seems confusing today. We'll revisit this example several times over the course of the semester.

Consider the following (textbook) code:

\begin{verbatim}
public class User {
    private String name;
    public User (String name) { this.name = name; }
    @Override public boolean equals (Object obj) {
        if (!(obj instanceof User)) return false;
        return ((User) obj).name.equals(this.name);
    }
    // other methods omitted
}
public class SpecialUser extends User {
    private int id;
    public SpecialUser (String name, int id) { super(name); this.id = id; }
    @Override public boolean equals (Object obj) {
        if (!(obj instanceof SpecialUser)) return false;
        return super.equals(obj) && ((SpecialUser) obj).id == this.id;
    }
    // other methods omitted
}
\end{verbatim}

\begin{enumerate}
\item Walk though the execution of the \texttt{equals()} method in class \texttt{User} for a few well-chosen objects as the parameter. What happens at each point in the execution?
\item What does it mean for an \texttt{equals()} implementation to be \textbf{correct}? How do you know? Be as concrete as you can.
\item Is the given implementation of \texttt{equals()} in class \texttt{User} correct? Again, be concrete. If there is a problem, find a specific object (test case!) that demonstrates the problem.
\item How does inheritance complicate the correctness discussion for \texttt{equals()} in class \texttt{SpecialUser}?
\item What is your assessment of the \texttt{equals()} method in the \texttt{SpecialUser} class?
\end{enumerate}

\subsection{In class 1A}
\label{sec:org629117e}
Consider the following specification and implementation:

\begin{verbatim}

public static List<Integer> tail (List<Integer> list) {

    // REQUIRES: ???
    // EFFECTS:  ???

    List<Integer> result = new ArrayList<Integer>(list);
    result.remove(0);
    return result;
}
\end{verbatim}

\begin{enumerate}
\item What does the \textbf{implementation} of \texttt{tail} do in each of the following cases? How do you know: Running the code or reading an API description?
\begin{itemize}
\item \texttt{list = null}
\item \texttt{list = []}
\item \texttt{list = [1]}
\item \texttt{list = [1, 2, 3]}
\end{itemize}
\item Write a partial specification that matches the "happy path" part of the implementation's behavior.
\item Rewrite the specification to be total. Use Bloch's standard exceptions.
\item The resulting specification has a problem. What is it?
\item Rewrite the specification to address this problem. Rewrite the code to match the new specification.
\end{enumerate}

\subsection{In class 1B}
\label{sec:org88b0623}
\textbf{Goal}: Understanding Contracts 

Consider the 3 methods \texttt{hasNext} , \texttt{next}, and \texttt{remove} in the Java \href{https://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html}{Iterator} interface:

\begin{itemize}
\item For each method, identify all preconditions and postconditions.
\item For each precondition, identify a specific input that violates the precondition.
\item For each postcondition, identify an input specific to that postcondition.
\end{itemize}

\subsection{In class 2A}
\label{sec:org6c8dcae}
Consider a simple generic \texttt{Queue} implementation.
\begin{verbatim}

public class Queue <E> {

    private List<E> elements;
    private int size;

    public Queue() {   
        this.elements = new ArrayList<E>();
        this.size = 0;
    }

    public void enQueue (E e) {
        elements.add(e);
        size++;
    }

    public E deQueue () {
        if (size == 0) throw new IllegalStateException("Queue.deQueue");
        E result = elements.get(0);
        elements.remove(0);
        size--;
        return result;
    }

    public boolean isEmpty() {
        return size == 0;
    }
}

\end{verbatim}

\begin{enumerate}
\item Rewrite \texttt{Queue} to be \textbf{immutable}. Keep the representation variables \texttt{elements} and \texttt{size}.
\item Do the right thing with \texttt{enQueue()}.
\item Do the right thing with \texttt{deQueue()}.
\end{enumerate}


\subsection{In class 2B}
\label{sec:orgc5a4384}
Consider Liskov's Poly example, where an abstract Poly is defined as \(c_0 + c_1x + c_2x^2 + \dots\), and is implemented with two variables:
\begin{verbatim}
private int deg;
private int[] trms;
\end{verbatim}

\begin{verbatim}
Fill in example values that are mapped by the abstraction function.
Abstract Poly State:
What is a "state"?



AF
/|\
 |        
 |
 |
 |----------------------------------------------------------
 |
 |
 |
 |        






Representation State: (deg, trms)
\end{verbatim}

\begin{enumerate}
\item Identify representation states that should not be mapped.
\item Try to capture these states with a rule (that is, a rep-invariant).
\item Devise a representation that is suitable for a mutable version of Poly.
\item Develop a rep-invariant for that representation.
\end{enumerate}

\subsection{In class 3A}
\label{sec:org450d1ac}
Consider Liskov's immutable \texttt{Poly} example, where an abstract \texttt{Poly} is defined as \(c_0 + c_1x + c_2x^2 + \dots\), and is implemented with one variable:

\begin{verbatim}
private Map<Integer, Integer> map;
\end{verbatim}


Fill in example values that are mapped by the abstraction function.

\begin{verbatim}

Abstract State: Poly

AF
/|\
|
|
|
|----------------------------------------------------------
|
|
|
|



Representation State: map

\end{verbatim}

\begin{enumerate}
\item Identify representation states that should not be mapped.
\item Try to capture these states with a rule (that is, a rep-invariant).
\item Consider implementing the \texttt{degree()} method. What code would do the job? What more specific type of map would make the implementation simpler?
\end{enumerate}

\subsection{In class 3B}
\label{sec:orga9deffd}
Consider the code:

\begin{verbatim}

public class Members {
    // Members is a mutable record of organization membership
    // AF: Collect the list as a set
    // rep-inv1: members != null
    // rep-inv2: members != null && no duplicates in members
    // for simplicity, assume null can be a member...

    List<Person> members;   // the representation

    //  Post: person becomes a member
    public void join (Person person) { members.add   (person);}

    //  Post: person is no longer a member
    public void leave(Person person) { members.remove(person);}

\end{verbatim}


\begin{enumerate}
\item Analyze these 4 questions for rep-inv 1.
\begin{enumerate}
\item Does \texttt{join()} maintain rep-inv?
\item Does \texttt{join()} satisfy contract?
\item Does \texttt{leave()} maintain rep-inv?
\item Does \texttt{leave()} satisfy contract?
\end{enumerate}
\item Repeat for rep-inv 2.
\item Recode \texttt{join()} to make the verification go through. Which rep-invariant do you use?
\item Recode \texttt{leave()} to make the verification go through. Which rep-invariant do you use?
\end{enumerate}

\subsection{In class 4-1}
\label{sec:org6f6e901}
\begin{verbatim}
// {N >= 0}   # P  
i = 0;
while (i < N){
  i = i + 1;
}

//{i == N}  # Q
\end{verbatim}

\begin{itemize}
\item Identify the loop invariants for the loop in this program
\item Use a sufficiently strong invariant to prove the program is correct
\item Attemp to prove the program using an insufficiently strong invariant, describe what happens and why.
\end{itemize}


\subsection{In class 4A}
\label{sec:org873a6b0}
Consider the Java \texttt{Iterator<E>} interface:

\begin{verbatim}
public boolean hasNext();
public E next() throws NoSuchElementException
                       public void remove() throws IllegalStateException
\end{verbatim}

\begin{enumerate}
\item What is the abstract state of an iterator without the \texttt{remove()} method?
\item Work through an example iterating over a list of strings: \texttt{["bat", "cat", "dog"]}
\item What is the abstract state of an iterator with a \texttt{previous()} method?
\item What is the abstract state of an iterator with the \texttt{remove()} method?
\item Design an immutable version of the iterator.
\begin{enumerate}
\item How is \texttt{hasNext()} handled?
\item How is \texttt{next()} handled?
\item How is \texttt{remove()} handled?
\end{enumerate}
\item Exercise the immutable iterator with some sample client code.
\end{enumerate}

\subsection{In class 4B}
\label{sec:org8a1b731}
Consider the example in Bloch's Item 50 (3rd Edition):

\begin{verbatim}

// Broken “immutable” time period class
public final class Period {               // Question 3
    private final Date start;
    private final Date end;

    /**
     * @param start the beginning of the period
     * @param end the end of the period; must not precede start
     * @throws IAE if start is after end
     * @throws NPE if start or end null
     */

    public Period (Date start, Date end) {
        if (start.compareTo(end) > 0) throw new IAE();
        this.start = start; this.end = end;  // Question 1
    }
    public Date start() { return start;}    // Question 2
    public Date end()   { return end;}      // Question 2
}
\end{verbatim}


\begin{enumerate}
\item Write code that shows the problem the line marked // Question 1.
\item Write code that shows the problem the lines marked // Question 2.
\item Suppose that the class declaration were:
\begin{verbatim}
public class Period { // Question 3
\end{verbatim}
\begin{itemize}
\item Write code that shows the problem.
\end{itemize}
\item Bloch fixes the constructor as follows:
\begin{verbatim}
public Period (Date start, Date end) {
    this.start = new Date(start.getTime());  // Defensive copy
    this.end   = new Date(end.getTime());    // Defensive copy

    if (this.start.compareTo(end) > 0) throw new IAE();
\end{verbatim}
\begin{enumerate}
\item Bloch states that \texttt{clone()} would be inappropriate for copying the dates. Write code that shows the problem.
\item Bloch defers the exception check until the end, which seems to violate normal practice. What's the problem with checking early?
\end{enumerate}
\end{enumerate}

\subsection{In class 5A}
\label{sec:org4d8c866}
\textbf{Goal}: Understanding dynamic dispatching

Consider Liskov's \texttt{MaxIntSet} example with explict \texttt{repOk()} calls: (Really, we'd need assertions on these calls\ldots{})

\begin{verbatim}

public class IntSet {
    public void insert(int x) {...; repOk();}
    public void remove(int x) {...; repOk();}
    public boolean repOk() {...}
}
public class MaxIntSet extends IntSet {
    public void insert(int x) {...; super.insert(x); repOk();}
    public void remove(int x) {super.remove(x); ...; repOk();}
    public boolean repOk() {super.repOk(); ...;}
}

MaxIntSet s = {3, 5}; s.remove(5);  // repOk()????
\end{verbatim}

\begin{enumerate}
\item What do the \texttt{"..."} bits do?
\item How does the call work out?
\item What is the abstract state of a \texttt{MaxIntSet}? There are two options. What are they, and what are the consequences of each choice?
\end{enumerate}

\subsection{In class 5B}
\label{sec:orgfe7ef1b}
Consider the following:

\begin{verbatim}

class A:
    public void reduce (Reducer x)    
        // Effects: if x is null throw NPE 
        // else if x is not appropriate for this throw IAE
        // else reduce this by x

class B:
    public void reduce (Reducer x) 
        // Requires: x is not null
        // Effects: if x is not appropriate for this throw IAE
        // else reduce this by x

class C:
    public void reduce (Reducer x)   
        // Effects: if x is null return (normally) with no change to this
        // else if x is not appropriate for this throw IAE
        // else reduce this by x
\end{verbatim}

Analyze the "methods rule" for \texttt{reduce()} in each of these cases: Note: Some analysis may not be necessary. If so, indicate that.

\begin{verbatim}

B extends A.
Precondition Part:
Postcondition Part:
-----------------------------------          
C extends A.
Precondition Part:
Postcondition Part:
-----------------------------------          
A extends B.
Precondition Part:
Postcondition Part:
-----------------------------------          
C extends B.
Precondition Part:
Postcondition Part:
-----------------------------------                    
A extends C.
Precondition Part:
Postcondition Part: 
-----------------------------------          
\end{verbatim}

\subsection{In class 5C}
\label{sec:orgeeef43a}
Consider the following:
\begin{verbatim}
public class Counter{   // Liskov 7.8
    public Counter()     //EFF: Makes this contain 0
        public int get()     //EFF: Returns the value of this
        public void incr()   //MOD: this //EFF: makes this larger
        }
public class Counter2 extends Counter { // Liskov 7.9
    public Counter2()         //EFF: Makes this contain 0
        public void incr()       // MOD: this //EFF: double this
        }
public class Counter3 extends Counter {  // Liskov 7.10
    public Counter3(int n)   //EFF: Makes this contain n
        public void incr(int n)  // MOD: this //EFF: if n>0 add n to this
        }
\end{verbatim}

\begin{enumerate}
\item Is there a constraint about negative/zero values for this? How do we know?
\item What methods are in the \texttt{Counter2} API?
\item Is \texttt{Counter2} a valid subtype of Counter?
\item What methods are in the \texttt{Counter3} API?
\end{enumerate}

\subsection{In class 6}
\label{sec:org8451126}
This is a recap exercise.

\begin{verbatim}
public class BoundedQueue {
    private Object rep[];
    private int front = 0;
    private int back = -1;
    private int size = 0;
    private int count = 0;

    public BoundedQueue(int size) {
        if (size > 0) {
            this.size = size;
            rep = new Object[size];
            back = size - 1;
        }  }

    public boolean isEmpty() { return (count == 0); }
    public boolean isFull() { return (count == size); }
    public int getCount() { return count; }

    public void put(Object e) {
        if (e != null && !isFull()) {
            back++;
            if (back >= size)
                back = 0;
            rep[back] = e;
            count++;
        } }

    public Object get() {
        Object result = null;
        if (!isEmpty()) {
            result = rep[front];
            rep[front] = null;
            front++;
            if (front >= size)
                front = 0;
            count--;
        }
        return result;
    }
    @Override public String toString() {
        String result = "front = " + front;
        result += "; back = " + back;
        result += "; size = " + size;
        result += "; count = " + count;
        result += "; rep = [";
        for (int i = 0; i < rep.length; i++) {
            if (i < rep.length-1)
                result = result + rep[i] + ", ";
            else
                result = result + rep[i];
        }
        return result + "]";
    }
}

\end{verbatim}


\begin{enumerate}
\item What is wrong with \texttt{toString()}? What needs to be done to fix it? Make it so.
\item Write some sample client code to exercise the data structure. Include some non-happy-path cases.
\item Write contracts for each method (as written), including the constructor.
\item Build a rep-invariant. Focus on the code in \texttt{get()}. There are also lots of constraints on the array indices; these are quite tricky to get right. The constructor also introduces some complexity.
\item Suppose we removed the line
\begin{verbatim}
rep[front] = null;       
\end{verbatim}
from \texttt{get()}.
\begin{enumerate}
\item Informally, why is this wrong?
\item Formally, where does the correctness proof break down?
\item Could a client ever see the problem?
\end{enumerate}
\item Now that we've done some AF/RI analysis, what changes make the implementation better? btw - this is code straight out of a textbook.
\item Could this data structure be made immutable? If so, what would change in the contracts and method headers? What would likely change in the implementation?
\end{enumerate}

\subsection{In class 7}
\label{sec:org32be849}
Lambda In class;
Comparator;
Contract;

\subsection{In class 8A}
\label{sec:org9f29a82}
Given the following variable declarations, independently consider the given 6 sequences of Java instructions.
\begin{verbatim}

String           string = "bat";
Integer          x = 7;
Object[]         objects;
List             rawList;
List < Object >  objectList;
List < String >  stringList;

\end{verbatim}

Identify any code that results in a compiler error or warning.
Identify any code that raises a runtime exception.
Once a compiler error is noted, you do not need to analyze the sequence further.

\begin{enumerate}
\item \begin{verbatim}
objects = new String[1]; 
objects[0] = string;     
objects[0] = x;        
\end{verbatim}

\item \begin{verbatim}
objects = new Object[1];
objects[0] = string;   
objects[0] = x;     
\end{verbatim}

\item \begin{verbatim}
stringList = new ArrayList < String >();
stringList.add(string) ;
\end{verbatim}

\item \begin{verbatim}
objectList = new ArrayList < String >();
objectList.add(string) ;
\end{verbatim}

\item \begin{verbatim}
objectList = new ArrayList < Object >(); 
objectList.add(string) ;      
objectList.add(x) ;        
\end{verbatim}

\item \begin{verbatim}
rawList = new ArrayList();
rawList.add(string) ;    
rawList.add(x) ;       
\end{verbatim}
\end{enumerate}

\subsection{In class 8B}
\label{sec:org50147d0}
\begin{verbatim}
// Chooser - a class badly in need of generics!
// Bloch 3rd edition, Chapter 5, Item 28:  Prefer lists to arrays

public class Chooser {
    private final Object[] choiceArray;

    public Chooser (Collection choices) {
        choiceArray = choices.toArray();
    }

    public Object choose() { 
        Random rnd = ThreadLocalRandom.current();
        return choiceArray [rnd.nextInt(choiceArray.length)];
    }
}
\end{verbatim}



\begin{itemize}
\item First, simply generify by adding a type to the Chooser class. What is the compiler error with this approach?
\item How can you turn the compiler error into a compiler warning?
\item Can this warning be suppressed? Should it?
\item How can you adopt Bloch's advice about arrays and lists to get a typesafe Chooser class without doing anything else that is complicated?
\item What would Liskov have to say about this class? How should it evolve to address her concerns? What is the appropriate place to deal with the problem? Does an invariant help? Is that a rep-invariant, or some other kind of invariant?
\end{itemize}

\subsection{In class 8C}
\label{sec:orgb8a3276}
\begin{verbatim}
public class BoundedQueue {

    protected Object rep[];
    protected int front = 0;
    protected int back = -1;
    protected int size = 0;
    protected int count = 0;

    public BoundedQueue(int size) {
        if (size > 0) {
            this.size = size;
            rep = new Object[size];
            back = size - 1;
        }  }

    public boolean isEmpty() { return (count == 0); }

    public boolean isFull() { return (count == size); }

    public int getCount() { return count; }

    public void put(Object e) {
        if (e != null && !isFull()) {
            back++;
            if (back >= size)
                back = 0;
            rep[back] = e;
            count++;
        }  }

    public Object get() {
        Object result = null;
        if (!isEmpty()) {
            result = rep[front];
            rep[front] = null;
            front++;
            if (front >= size)
                front = 0;
            count--;
        }
        return result;
    }
}

\end{verbatim}


Generify!
\begin{itemize}
\item Can you add a putAll() method? A getAll() method?
\item Recall that we used this same example in in-class 6 as a vehicle for applying Liskov's ideas to make code easier to understand.
\end{itemize}

\subsection{In class 9A}
\label{sec:org94da596}
Consider Bloch's \texttt{Point/ColorPoint} example. For today, ignore the \texttt{hashCode()} issue.

\begin{verbatim}

public class Point {  // routine code
    private int x; private int y;    
    ...
        @Override public boolean equals(Object obj) {  // Standard recipe
        if (!(obj instanceof Point)) return false;

        Point p = (Point) obj;
        return p.x == x && p.y == y;
    }
}

public class ColorPoint extends Point {  // First attempt: Standard recipe
    private COLOR color;
    ...
        @Override public boolean equals(Object obj) {
        if (!(obj instanceof ColorPoint)) return false;

        ColorPoint cp = (ColorPoint) obj;
        return super.equals(obj) && cp.color == color;
    }
}

public class ColorPoint extends Point {  // Second attempt: DON'T DO THIS!
    private COLOR color;
    ...
        @Override public boolean equals(Object obj) {
        if (!(o instance of Point)) return false;

        // If obj is a normal Point, be colorblind
        if (!(obj instanceof ColorPoint)) return obj.equals(this);

        ColorPoint cp = (ColorPoint) obj;
        return super.equals(obj) && cp.color == color;
    }
}
\end{verbatim}

\begin{enumerate}
\item What is the \texttt{equals()} contract? What is the standard recipe?
\item Why does Bloch use the \texttt{instanceof} operator in the standard recipe?
\item Write client code that shows a contract problem with the first attempt at \texttt{ColorPoint}.
\item Write client code that shows a contract problem with the second attempt at \texttt{ColorPoint}.
\item Some authors recommend solving this problem by using a different standard recipe for \texttt{equals()}.
\begin{itemize}
\item What's the key difference?
\item Which approach do you want in the following code:
\begin{verbatim}
public class CounterPoint extends Point
                                  private static final AtomicInteger counter =
                                  new AtomicInteger();

public CounterPoint(int x, int y) {
    super (x, y);
    counter.incrementAndGet();
}
public int numberCreated() { return counter.get(); }

@Override public boolean equals (Object obj) { ??? }
}


// Client code:

Point p = PointFactory.getPoint();   // either a Point or a CounterPoint
Set<Point> importantPoints =   // a set of important points
    boolean b = PointUtilities.isImportant(p);  // value?

\end{verbatim}
\end{itemize}
\end{enumerate}

\subsection{In class 9B}
\label{sec:org9981d50}
Consider a variation of Liskov's \texttt{IntSet} example (Figure 5.10, page 97)

\begin{verbatim}

public class IntSet implements Cloneable {  
    private List<Integer> els;
    public IntSet () { els = new ArrayList<Integer>(); }
    ...
        @Override 
        public boolean equals(Object obj) { 
        if (!(obj instanceof IntSet)) return false;

        IntSet s = (IntSet) obj;
        return ???
            }

    @Override 
    public int hashCode() { 
        // see below 
    }

    // adding a private constructor
    private IntSet (List<Integer> list) { els = list; }

    @Override 
    public IntSet clone() { 
        return new IntSet ( new ArrayList<Integer>(els));
    }

}
\end{verbatim}

\begin{enumerate}
\item How should the \texttt{equals()} method be completed?
\item Analyze the following ways to implement \texttt{hashCode()}? If there is a problem, give a test case that shows the problem.
\begin{enumerate}
\item not overridden at all
\item return 42;
\item return \texttt{els.hashCode()};
\item \texttt{int sum = 0; for (Integer i : els) sum += i.hashCode(); return sum;}
\end{enumerate}
\item What's the problem with \texttt{clone()} here? Give a test case that shows the problem.
\item Fix \texttt{clone()} in two very different ways.
\end{enumerate}

\subsection{In class 10A}
\label{sec:orgbbdf573}
Consider Bloch's \texttt{InstrumentedHashSet}, \texttt{InstrumentedSet}, and \texttt{ForwardingSet} examples:

\begin{verbatim}
public class InstrumentedHashSet<E> extends HashSet<E>{
    private int addCount = 0;	
    public InstrumentedHashSet() {}

    @Override public boolean add(E e){ 
        addCount++; 
        return super.add(e); 
    }
    @Override public boolean addAll(Collection<? extends E> c){ 
        // What to do with addCount?
        return super.addAll(c); 
    }
    public int getAddCount(){ return addCount; }
}
public class InstrumentedSet<E> extends ForwardingSet<E>{
    private int addCount = 0;	

    public InstrumentedSet(Set<E> s){ super(s); }
    @Override public boolean add(E e){ addCount++; return super.add(e); }
    public int getAddCount(){ return addCount; }
}
public class ForwardingSet<E> implements Set<E> {
    private final Set<E> s;

    public ForwardingSet(Set<E> s){ this.s = s; }
    public           boolean add(E e)        { return s.add(e);     }
    public           boolean remove(Object o){ return s.remove(o);  }
    @Override public boolean equals(Object o){ return s.equals(o);  }
    @Override public int     hashCode()      { return s.hashCode(); }
    @Override public String  toString()      { return s.toString(); }
    // Other forwarded methods from Set interface omitted
}

Consider also the following client code:

Set<String> r = new HashSet<String>();
r.add("ant"); r.add("bee");

Set<String> sh = new InstrumentedHashSet<String>();
sh.addAll(r);

Set<String> s =  new InstrumentedSet<String>(r);
s.add("ant"); s.add("cat");

Set<String> t = new InstrumentedSet<String>(s);
t.add("dog");

r.remove("bee");
s.remove("ant");
\end{verbatim}


\begin{enumerate}
\item How do you think the \texttt{addCount} variable should be updated in the \texttt{addAll()} method in \texttt{InstrumentedHashSet}?
\begin{enumerate}
\item Why is this a hard question?
\item What does the answer say about inheritance?
\item Does \texttt{equals()} behave correctly in \texttt{InstrumentedHashSet?}
\end{enumerate}
\item Given your previous answer, what is the value of \texttt{sh.addCount} at the end of the computation?
\item Consider the \texttt{InstrumentedSet} solution. Besides being correct (always a plus!) why is it more general than the \texttt{InstrumentedHashSet} solution?
\item At the end of the computation, what are the values of: \texttt{r}, \texttt{s}, and \texttt{t}?
\item What would a call to \texttt{s.getAddCount()} return at the end of the computation?
\item At the end of the computation, what are the values of: \texttt{r.equals(s)}, \texttt{s.equals(t)}, and \texttt{t.equals(s)}?
\begin{itemize}
\item Are there any problems with the \texttt{equals()} contract?
\end{itemize}
\item Would this still work if you globally replaced sets with lists?
\item Would this still work if you globally replaced sets with collections?

\textbf{Note}: There is a lot going on in this example. I highly recommend that you play with the code until you understand it.
\end{enumerate}

\subsection{In class 10B}
\label{sec:org2036435}
\begin{verbatim}
public class Super {
    public Super() {
        overrideMe();
    }

    public void overrideMe () {
    }
}
public final class Sub extends Super {

    private final Date date;  // filled in by constructor

    public Sub() {
        date = new Date();
    }
    @Override public void overrideMe () {
        System.out.println(date);
    }

    public static void main (String[] args) {
        Sub sub = new Sub();
        sub.overrideMe();
    }
}
\end{verbatim}

\begin{enumerate}
\item What is the pattern, and how common is it?
\item What does the main method do, and why?
\item Which of Bloch's rules does this example break?
\item What does this example mean for \texttt{Cloneable} interface and the \texttt{clone()} method?
\item What does this example mean for \texttt{Serializable} interface and the \texttt{readObject()} method?
\item To what extent does this rule generalize to producer methods?
\end{enumerate}

\subsection{In class 10C}
\label{sec:org87161aa}
Consider a mutable complex number class:

\begin{verbatim}
public class MComplex {
    double re; protected double im;

    public MComplex (double re, double im) { this.re = re; this.im = im; }

    public double getReal()      { return re; }
    public double getImaginary() { return im; }

    public void setReal(double re)      { this.re = re; }
    public void setImaginary(double im) { this.im = im; }

    public void add (MComplex c) { re += c.re; im += c.im; }

    public void subtract (MComplex c) { re -= c.re; im -= c.im; }

    public void multiply (MComplex c) {
        double r = re * c.re - im * c.im;
        double i = re * c.im + im * c.re;
        re = r; im = i;
    }

    public void divide (MComplex c) {
        double den = c.re * c.re + c.im * c.im;
        double r = (re * c.re - im * c.im) / den;
        double i = (re * c.im + im * c.re) / den;
        re = r; im = i;
    }

    @Override public boolean equals (Object o) {
        if (o == this)               return true;
        if (!(o instanceof MComplex)) return false;
        MComplex c = (MComplex) o;

        // See Bloch page 43 to find out why to use compare() instead of ==
        return Double.compare(re, c.re) == 0 &&
            Double.compare(im, c.im) == 0;
    }

    @Override public int hashCode () {
        int result = 17 + hashDouble(re);
        result = 31 * result + hashDouble(im);
        return result;
    }

    private int hashDouble (double val) {
        long longBits = Double.doubleToLongBits(val);
        return (int) (longBits ^ (longBits >>>32));
    }

    @Override public String toString() { return "(" + re + " + " + im + "i)"; }
}

\end{verbatim}

Before we get to immutability, consider the method contracts. Where do the various contracts "come from", and is there anything in the (missing) JavaDoc that might require a bit of research?

Apply each of Bloch's 5 rules for making a class immutable:
\begin{enumerate}
\item Don't provide any methods that modify the object's state. How do you handle the mutators?
\item Ensure that no methods can be overridden.
\begin{itemize}
\item Why is this a problem? Show me!
\item Fix the problem:
\begin{itemize}
\item Change the class declaration, or
\item Change the method declarations, or
\item Change the constructor visibility.
\end{itemize}
\end{itemize}
\item Make all fields final.
\item Make all fields private.
\begin{itemize}
\item Is there a significant difference in visibility between re and im?
\end{itemize}
\item Ensure exclusive access to any mutable components.
\end{enumerate}

\subsection{In class 11}
\label{sec:org3711f95}
This is a JUnit theory exercise.

\begin{enumerate}
\item Write a JUnit theory that captures the symmetry property of the \texttt{equals()} method.
\item Create \texttt{@DataPoints} from Bloch's \texttt{Point}, \texttt{ColorPoint} classes. So that we're all on the same page, create 1 \texttt{null} reference, 1 \texttt{Point} object and 2 \texttt{ColorPoint} objects.
\item Given this set of data points:
\begin{itemize}
\item How many combinations are considered by the theory?
\item How many combinations make it past the preconditions of the theory?
\item How many combinations make it to the postcondition of the theory?
\end{itemize}
\item What happens to this theory and the accompanying data points when favoring composition over inheritance?
\item Repeat the exercise for the transitive property for \texttt{equals()}.
\item Recall the \texttt{equals()} and \texttt{hashCode()} discussion in Bloch. Write a JUnit theory that encodes the consistency property between \texttt{equals()} and \texttt{hashCode()}.
\item Build a toy example that violates the theory. Fix the toy example so that the theory is no longer violated.
\item Consider the \texttt{Comparable} interface: what properties should be checked with theories?
\end{enumerate}

\subsection{In class 12A}
\label{sec:org16fff9b}
Consider the following (bad) Java, implementing the "C style" enum pattern:

\begin{verbatim}
public class Coins {
    public static final int PENNY = 1;
    public static final int NICKLE = 5;
    public static final int DIME = 10;
    public static final int QUARTER = 25;
}

\end{verbatim}

\begin{enumerate}
\item Give example code that illustrates a type safety problem with \texttt{Coins}. Work through a range of expressions from "probably ok" to "clearly wrong".
\item What code would you need to turn a nickel into a string? Explain how this could go wrong at runtime.
\item What code would you need to iterate through the coins?
\item Would extensions to this particular enum be likely to require recompilation of client code? Explain.
\item Write a decent Java Enum for coins.
\item Turn a nickle into a string.
\item Iterate though the coins.
\end{enumerate}


Consider Bloch's example:

\begin{verbatim}
// Abuse of ordinal to derive an associated value – DON’T DO THIS
public enum Ensemble {
    SOLO,   DUET,   TRIO,  QUARTET, QUINTET, 
    SEXTET, SEPTET, OCTET, NONET,   DECTET;

    public int numberOfMusicians() { return ordinal() + 1; }
}
\end{verbatim}

Explain why it's wrong, fix it, and add another enum with an overlapping number of musicians.

\subsection{In class 12B}
\label{sec:org0aeee0d}
This is a recap exercise based on the map-based implementation of Liskov's polynomial example: \href{./files/MapPoly.java}{MapPoly}

\begin{enumerate}
\item How are the following polynomials represented?
\begin{itemize}
\item \(0\)
\item \(3-7x^4\)
\end{itemize}
\item Bloch would not accept that the MapPoly class is immutable. Why not? Show how it would be possible to provide mutable behavior with the class if Bloch's problem isn't fixed. Fix the problem, and implement any other changes Bloch suggests, even if they don't compromise immutability in this particular example.
\item Write a reasonable rep-invariant for \texttt{MapPoly}. How would this rep-invariant change if the zero \texttt{Poly} had an alternate representation.
\item Provide reasonable implementations of \texttt{equals()} and \texttt{hashCode()}. Explain why you believe your implemetations are appropriate.
\item As written, the contract for the \texttt{coeff()} method is inconsistent with other contracts in the class.
\begin{itemize}
\item What is the inconsistency with the contract?
\item Fix the inconsistency with the contract.
\item Fix the code to match the revised contract.
\end{itemize}
\item Argue that the implementation of the \texttt{coeff()} method is correct (with respect to your repaired contract, of course.)
\item Consider implementing \texttt{Cloneable} for this class. Decide whether Bloch would think this is a good idea and provide justification for your answer. Note: You don't have to actually implement anything for this question.
\item See if you can come up with a theory about Polys and implement it in JUnit. (Polys are math objects, so there should be theories!) Here's a suggestion: Think about the relationship between the degrees of two Polys being multiplied and the resulting degree.
\end{enumerate}

\subsection{In class 13}
\label{sec:org68e00cb}
How well are you prepared for the final? This exercise should help you find out. Piazza discussions encouraged!

\begin{verbatim}

public class Stack {
    private Object[] elements; private int size = 0;

    public Stack() { this.elements = new Object[0]; }

    public void push (Object e) {
        if (e == null) throw new NullPointerException("Stack.push");
        ensureCapacity(); elements[size++] = e;  
    }

    public void pushAll (Object[] collection) { for (Object obj: collection) { push(obj); } }

    public Object pop () {
        if (size == 0) throw new IllegalStateException("Stack.pop");
        Object result = elements[--size];
        // elements[size] = null;
        return result;
    }

    @Override public String toString() {
        String result = "size = " + size;
        result += "; elements = [";
        for (int i = 0; i < elements.length; i++) {
            if (i < elements.length-1)
                result = result + elements[i] + ", ";
            else
                result = result + elements[i];
        }
        return result + "]";
    }
}


\end{verbatim}

\begin{enumerate}
\item Write a contract for \texttt{push(Object e)}.
\item What is wrong with \texttt{toString()?} Fix it.
\item What rep-invariant is likely broken? Fix it. This includes writing a suitable rep-invariant.
\item How would Bloch's Item 25: \emph{Prefer Lists to Arrays} apply here? Would it make the rep-invariant simpler?
\item How would you argue that that \texttt{pop()} is correct (or not)?
\item As \texttt{Stack} is written, \texttt{pushAll()} requires special documention? Why? What would Bloch suggest as an alternative?
\item Override \texttt{equals()}. What else do you have to do? Do that too.
\item Generify. What should happen to the parameter for \texttt{pushAll()}? Why?
\item Suppose we decide to implement the \texttt{Cloneable()} interface. In what ways would Bloch think we would likely get it wrong? What would Bloch recommend instead?
\end{enumerate}


\section{HW Assignments}
\label{sec:orge6663ec}

\subsection{Assignment 1}
\label{sec:orgb85722c}
\subsubsection{Goal}
\label{sec:orgfa62630}
\begin{itemize}
\item Getting started on Piazza.
\item Getting your group together.
\end{itemize}

There are two parts to this assignment:

\begin{itemize}
\item Post a brief intro about yourself on the course Piazza page. For any credit, the posting must:
\begin{itemize}
\item be a follow-up to my introduction. In other words, all intros need to be in the same thread.
\item Include a photo appropriate in size, content, and orientation.
\end{itemize}
\item Your \textbf{group} should communicate the composition of your group to me (and the GTA) on Piazza. If you group is sticking with the random assignment, just confirm that. If you have a new group, tell us the composition, and we'll edit the post to reflect the change.
\end{itemize}

\subsubsection{Grading Criteria}
\label{sec:org3af5157}
\begin{itemize}
\item Your individual Piazza post adhers to my instructions. (That is, no sideways pictures, no oversize pictures, etc.)
\item You are in a group.
\end{itemize}


\subsection{Assignment 2}
\label{sec:orgfbf8dc5}
\subsubsection{Goals: Contracts}
\label{sec:org55e3997}

For the second assignment, you'll build a \emph{very} small piece of Java for a contract with preconditions, transform the contract so that all preconditions become postconditions, and then re-implement appropriately.

\begin{itemize}
\item Consider a method that calculates the number of months needed to pay off a loan of a given size at a fixed \emph{annual} interest rate and a fixed \emph{monthly} payment. For instance, a \$100,000 loan at an 8\% annual rate would take 166 months to discharge at a monthly payment of \$1,000, and 141 months to discharge at a monthly payment of \$1,100. (In both of these cases, the final payment is smaller than the others; I rounded 165.34 up to 166 and 140.20 up to 141.) Continuing the example, the loan would never be paid off at a monthly payment of \$100, since the principal would grow rather than shrink.
\end{itemize}

Define a Java class called \texttt{Loan}. In that class, write a method that satisfies the following specification:

\begin{verbatim}
/*
@param principal:  Amount of the initial principal
@param rate:       Annual interest rate  (8% rate expressed as rate = 0.08)
@param payment:    Amount of the monthly payment
*/
public static int months (int principal, double rate, int payment)
    // Requires: principal, rate, and payment all positive and payment is sufficiently large to drive the principal to zero.
    // Effects:  return the number of months required to pay off the principal
\end{verbatim}


Note that the precondition is quite strong, which makes implementing the method easy. You should use double precision arithmetic internally, but the final result is an integer, not a floating point value. The key step in your calculation is to change the principal on each iteration with the following formula (which amounts to monthly compounding):

\begin{verbatim}
newPrincipal = oldPrincipal * (1 + monthlyInterestRate) - payment;
\end{verbatim}


The variable names here are explanatory, not required. You may want to use different variables, which is fine.

\textbf{To make sure you understand the point about preconditions, your code is required to be minimal. Specifically, if it possible to delete parts of your implementation and still have it satisfy the requirements, you'll earn less than full credit.}

\begin{itemize}
\item Now modify \texttt{months} so that it handles \textbf{all} of its preconditions with exceptions. Use the standard exceptions recommended by Bloch. Document this with a revised contract. You can use JavaDoc or you can simply identify the postconditions.
\end{itemize}

\subsubsection{Grading Criteria}
\label{sec:org494b8f3}

\begin{itemize}
\item Adherence to instructions.
\item Minimal implementation.
\item Preconditions are correctly converted to exceptions.
\item Syntax: Java compiles and runs.
\end{itemize}

\subsection{Assignment 3}
\label{sec:org853ad5b}
\subsubsection{Goals: Data Abstraction / Mutability}
\label{sec:org7a3303f}

Rewrite \href{./files/MapPoly.java}{MapPoly}, my map-based version Liskov's Poly so that it is \emph{mutable}. Keep the same representation.

Rewrite the overview, the method signatures, the method specifications, and the methods themselves. You do not need to rewrite the abstraction function and representation invariant for this exercise.

Turn in a \textbf{story}. This means that it is possible to grade your assignment simply by reading it, as if it were part of a textbook. In particular, every place you make a decision to change something in the code (or not), you should have a description of what you did (or didn't do) and why you did (or didn't do) it.

Remember that part of your group is responsible for synthesizing a solution, and part of your group is responsible for checking the result.

\subsubsection{Grading Criteria}
\label{sec:org600dbc9}
\begin{itemize}
\item Correct transformation of Poly
\item Clarity of your story.
\item Reasonable division of synthesis vs. checking.
\end{itemize}


\subsection{Assignment 4}
\label{sec:orgc646439}
\subsubsection{Goals: Rep-Invariants, contracts, tests}
\label{sec:orgab2f9ef}

Revisit the mutable Poly example from \href{./assign03.html}{assignment 3}. That is, use the one based on a map, not an array.

\begin{enumerate}
\item Implement \texttt{repOk()}.
\item Introduce a fault (i.e. "bug") that breaks the rep-invariant. Try to do this with a small (conceptual) change to the code. Show that the rep-invariant is broken with a JUnit test.
\item Analyzed your bug with respect to the various contracts/methods in Poly. Are all/some/none of the contracts violated?
\item Do you think your fault is realistic? Why or why not?
\end{enumerate}

As in assignment 3, your deliverable is a \textbf{story}, with exactly the same rationale. Take screenshots (e.g. of failing JUnit tests) as necessary to make your case.

\subsubsection{Grading Criteria}
\label{sec:orgac5d303}

\begin{itemize}
\item Correctness of solution
\item Clarity of story
\end{itemize}
Note: If your group had trouble with the previous assignment, feel free to appeal to your classmates to post a sample solution on Piazza.

\subsection{Assignment 4-1}
\label{sec:org645b614}
\subsubsection{Goals: Understanding Program Verification through Hoare Logic}
\label{sec:orga133e2b}

Do the \hyperref[sec:org6f6e901]{in-class exercise} with your group and submit it on BB. More specifically, you will do the below two tasks:
\begin{enumerate}
\item Prove the program using the following the loop invariant:  \texttt{i <= N}.
\begin{enumerate}
\item Clearly reason why this is a loop invariant
\item Compute the weakest precondition \texttt{wp} of the program wrt the post conditiong \texttt{Q}
\item Compute the verification condition \texttt{vc (P => wp(..))}, and
\item Analyze the \texttt{vc} to dertermine whether the program is proved or not
\end{enumerate}
\item Repeat the above task a different loop invariant:  \texttt{N >= 0}
\end{enumerate}

\subsubsection{Grading Criteria}
\label{sec:org7010b3c}

\begin{itemize}
\item Correctness of solution
\end{itemize}
Note: If your group had trouble with the assignment, feel free to appeal to your classmates to post a sample solution on Piazza.


\subsection{Assignment 5}
\label{sec:orga934bb3}
\subsubsection{Goals: Immutablity via Bloch Item 50}
\label{sec:orgf8178c0}

Revisit the \hyperref[sec:org8a1b731]{Period example}.

Implement a satisfying solution to question 3. That is, you should not only break the immutability of the \texttt{Period} class by writing a suitable sublcass, but you should also develop a plausible case where a client ends up "in trouble" due to the loss of immutability.

Turn in a \textbf{story}.

\subsubsection{Grading Criteria}
\label{sec:org2cd30e9}

Grading is in part the technical aspect of breaking immutability, and in part that your client case is plausible.


\subsection{Assignment 6}
\label{sec:orgd546b4d}
\subsubsection{Goals: Type Abstraction}
\label{sec:org0c06e5e}

Consider the following \texttt{Market} class.

\begin{verbatim}

class Market {
    private Set<Item> wanted;           // items for which prices are of interest
    private Bag<Item, Money> offers;    // offers to sell items at specific prices
    // Note:  Bag isn't a Java data type.  Here, the bag entries are pairs.

    public void offer (Item item, Money price)
    // Requires: item is an element of wanted
    // Effects:  add (item, price) to offers

        public Money buy(Item item)
    // Requires: item is an element of the domain of offers
    // Effects: choose and remove some (arbitrary) pair (item, price) from
    //          offers and return the chosen price
        }

\end{verbatim}

\begin{enumerate}
\item Suppose that offers are only accepted if they are lower than previous offers.
\begin{verbatim}
class Low_Bid_Market extends Market {
    public void offer (Item item, Money price)
    // Requires: item is an element of wanted
    // Effects:  if (item, price) is not cheaper than any existing pair
    //           (item, existing_price) in offers do nothing
    //           else add (item, price) to offers

\end{verbatim}
Is \texttt{Low\_Bid\_Market} a valid subtype of \texttt{Market}? Appeal to the methods rule to back up your answer.

\item Suppose that the \texttt{buy()} method always chooses the lowest price on an item.
\begin{verbatim}
class Low_Offer_Market extends Market {
    public Money buy(Item item)
    // Requires: item is an element the domain of offers
    // Effects: choose and remove pair (item, price) with the 
    //          lowest price from offers and return the chosen price
\end{verbatim}
Is \texttt{Low\_Offer\_Market} a valid subtype of \texttt{Market}? Appeal to the methods rule to back up your answer.
\end{enumerate}


\subsubsection{Grading Criteria}
\label{sec:org373bcc0}

This is purely a "paper and pencil" exercise. No code is required. Write your answer so that it is easily understandable by someone with only a passing knowledge of Liskov's rules for subtypes.


\subsection{Assignment 7}
\label{sec:org5d1a5c5}
\subsubsection{Goals: Polymorphic Abstraction.}
\label{sec:org211a1c5}

A \texttt{Comparator} based on absolute values is problematic. Code up the comparator and then write client code that illustrates the problem. Use a \emph{lambda function} to implement the comparator. Explain what is wrong in a brief summary statement. Your explanation of the problem must be phrased in terms of a violation of the contract for \texttt{Comparator}.

To emphasize that this contract problem is real, your code should create two Java sets, one a \texttt{HashSet}, and the other a \texttt{TreeSet}. The \texttt{TreeSet} should order items with your absolute value comparator. Your example should add the same integers to both sets, yet still end up with sets that are different. Your summary statement should explain why.

\subsubsection{Grading Criteria}
\label{sec:orgd75a7c5}
As for other recent assignments, your deliverable is a clear, concise story that demonstrates completion of the assignment.


\subsection{Assignment 8}
\label{sec:org3b589ce}
\subsubsection{Goals: Generics}
\label{sec:org3b1afb4}

Consider the \href{./files/BoundedQueue.java}{BoundedQueue} example from in-class exercise \href{./inclass08C.html}{\#8C}.

Complete the generic part of the exercise: The result should be fully generic, and there should not be any compiler warnings. You should adopt Bloch's advice about lists vs. arrays; doing so will eliminate the need for many of the instance variables.

Keep the same methods, but update the behavior (and document with contracts!) to include exception handling for all cases not on the happy path.

Include the constructor in your considerations. In particular, consider whether you think a zero-sized buffer is a reasonable possibility. Document your reasoning. This is less about a right vs. wrong answer than a careful consideration of the consequences of the decision.

Add \texttt{putAll()} and \texttt{getAll()}. Define the method signatures carefully. Use exception-handling consistent with that for \texttt{get()} and \texttt{put()}. Use bounded wildcards as appropriate. Note that \texttt{putAll()} has a special case where there isn't sufficient space in the bounded queue. Adopt a solution you think Bloch and/or Liskov would approve of. In particular, Bloch prefers that when methods throw exceptions, there is no change to the state of the object.

\subsubsection{Grading Criteria}
\label{sec:org6734936}
As before, turn in a clear, concise story demonstrating completion of the assignment.


\subsection{Assignment 9}
\label{sec:orgf89b975}
\subsubsection{Goals: \texttt{Object} class contracts.}
\label{sec:orgc6a2089}

As it happens, Liskov's implementation of \texttt{clone()} for the \texttt{IntSet} class (see figure 5.10, page 97) is wrong.

\begin{enumerate}
\item Use the \href{./files/IntSet.java}{version} of \texttt{IntSet} from the in-class exercise. Implement a subtype of \texttt{IntSet} to demonstrate the problem. Your solution should include appropiate executable code in the form of JUnit tests.
\item Provide a correct implementation of \texttt{clone()} for \texttt{IntSet}. Again, give appropriate JUnit tests.
\item Correctly override \texttt{hashCode()} and \texttt{equals()}. As discussed in the class exercise, the standard recipe is not appropriate in this (unusual) case.
\end{enumerate}

\subsubsection{Grading Criteria}
\label{sec:org17c1833}
In addititon to code and tests, your deliverable is a story. Explain what is going on at each stage of the exercise. The GTA will primarily grade your story.


\subsection{Assignment 10}
\label{sec:org223d54f}
\subsubsection{Goals: Favoring composition over inheritance. Bloch, Item 18.}
\label{sec:org28cfc93}

Consider the \texttt{InstrumentedSet} example from Bloch Item 18 (as well as in-class exercise \href{./inclass10A.html}{\#10A}).
\begin{enumerate}
\item Replace \texttt{Set} with \texttt{List}. There is no problem with \texttt{equals()}. Why not?
\item Replace \texttt{Set} with \texttt{Collection}. Now \texttt{equals()} does not satisfy its contract.
\begin{itemize}
\item Explain why there is a problem.
\item Demonstrate the problem with a suitable JUnit test.
\end{itemize}
\end{enumerate}



\subsubsection{Grading Criteria}
\label{sec:org9cd521d}
The GTA will look for correct responses, appropriate JUnit tests, and plausible explanations when doing the grading.


\subsection{Assignment 11}
\label{sec:orgf91f5c7}
\subsubsection{Goals: Applying lessons learned.}
\label{sec:orgbacb317}

You have a choice of possible assignments:

\begin{enumerate}
\item Consider one of the \texttt{copyOf()} methods in the Java \href{https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html}{Arrays} utility class. Bloch uses this method in his \texttt{Stack} example. Code a corresponding method in C++, changing the argument list as necessary. Provide a specification for the C++ code by translating the JavaDoc and adding preconditions as necessary. Explain what this exercise demonstrates about C++ type safety.

\item For most of the semester, we have focused on design considerations for constructing software that does something we want it to do. For this last assignment, I would like students to appreciate just how vulnerable software is to malicious parties intent on attacking their software.

There are two attacks documented in Bloch's Item 88: \emph{Write \texttt{readObject()} methods defensively}. One is called \texttt{BogusPeriod}, and the other is called \texttt{MutablePeriod}. Implement either (your choice) of these attacks (basically involves typing in code from Bloch) and verify that the attack takes place.

\item A different source of security vulnerabilities in Java also involve serialization. Bloch (and others) recommend "cross-platform structured data representations" (e.g. JSON or Protocol Buffers) as safe alternatives. Develop a simple serialization example in Java and convert it into a safe alternative (probably, JSON is easier to use, since it is text-based). To make the example more interesting, use some objects types that are not directly supported.

\item Find some existing (Java) code that uses the "int enum pattern" and refactor it to use Java \texttt{Enums} instead. Identify any type-safety issue you uncover in the existing code. To make the exercise interesting, extend your enums beyond simple named-constants in one of the ways discussed by Bloch in Item 34.

\item Where appropriate, code up, as JUnit theories, constraints for classes that implement the Java \texttt{Comparable} interface. Note that there is significant overlap with the in-class exercise. Note also that the Comparable interface is generic; hence, you should use generics in your JUnit test class.

\item Gain experience with one of the property-based testing tools. I suggest a Java-based one (such as \href{https://jqwik.net}{jqwik}). One way to do this is work through one of the articles linked on the jqwik site.
\end{enumerate}


\subsubsection{Grading Criteria}
\label{sec:orgcd2f961}
In each case, the deliverable is a story. Write a brief report, and include enough evidence (output, screen shots, etc.) that the GTA can figure out that you actually completed the assignment.

\section{Quiz Guides}
\label{sec:org467ad92}
\textbf{Note}: it's possible that your quiz involves last week's topic. Be prepared for both!


\subsection{Guide 1}
\label{sec:org609e664}
Quiz 1 will revisit the example from In-Class Exercise 0. I'll ask you about the \textbf{first} of the two given \texttt{equals()} methods, as well as "corner" cases where this method might do something odd.

This won't be a deep-dive; that comes later. But you should be able to identify specific inputs that lead to corner case behavior. You should be able to assess code behavior on specific inputs.

Quiz 1 may also include items from the syllabus and from the readings. Please read both carefully!

\subsection{Guide 2}
\label{sec:orgb776807}
Quiz 2 will focus on Liskov, Chapters 3-4 and Bloch 10. Specifically, you should be able to explain the code and the contracts for in-Class exercise 1A. As part of this, you should be able to transform preconditions into postconditions via the exception handling mechanism, and you should be able to incorporate Bloch's advice on exceptions into this transformation.


\subsection{Guide 3}
\label{sec:orga829d7c}
Quiz 3 will focus on the first part of Liskov 5. You should be able to manipulate the IntSet and Poly examples. You should understand basic mutability - that is, the specification of mutators in mutable classes and producers in immutable classes. You should be able to convert the specification of a simple mutable class to an immutable one, and vice versa.

\subsection{Guide 4-1}
\label{sec:orgc575334}
Quiz 4-1 will focus on program verification using Hoare tripple. You should understand and able to do examples we have discussed in class. In particular, I'd suggest modifying the examples or specifications or invariants and see if the verification process still works or fails.



\subsection{Guide 4}
\label{sec:orgb1584d3}
Quiz 4 will focus on abstraction functions, rep-invariants, and verification. You should understand, evaluate, and modify the abstraction functions and rep-invariants for simple variations on examples we have discussed in class. You should also understand the verification of methods with respect to their specifications. If I give you a specification, and a Java implementation, you should be able to analyze (informally) whether the method is correct. In particular, I'd suggest studying the verification of the Members example, which we covered in the in-class exercise.


\subsection{Guide 5}
\label{sec:org86cae61}
Iteration abstraction is the focus of Quiz 5. You should understand the abstraction functions for iterators, as well as the examples Liskov covers.

Also on the agenda is Bloch 3rd edition, Chapter 8 (Methods).

\subsection{Guide 6}
\label{sec:orgc528c10}
Type abstraction is the focus of Quiz 6. In addition to the basic Java mechanisms for implementing type abstraction, you should understand section 7.9, particularly the "signature" rule, the role of preconditions and postconditions in the "methods" rule, and simple applications of the "properties" rule. You should be prepared to analyze example specifications for overridden methods.

\subsection{Guide 7}
\label{sec:org3a88e25}
Two possible foci for Quiz 7:
Java's lambda expressions as explored in the in-class exercise.
The element subtype vs. related subtype approaches to polymorphism and how they are implemented in Comparable vs. Comparator.


\subsection{Guide 8}
\label{sec:org3b1a2ca}
Quiz 8 will focus both Liskov's treatment of polymorphism and Bloch's treatment of lambda expressions.

To make this concrete, we'll focus on the \texttt{Comparator} interface. You should be prepared to evaluate various implementations of this interface against the contract for the interface, with the ability to explain why certain violations of the contract could lead to trouble (e.g. when used in a collection framework such as \texttt{TreeSet}). You should also be prepared to manipulate this interface via lambda expressions (e.g. when used in a collection framework such as \texttt{TreeSet}).

This homework should be excellent preparation.


\subsection{Guide 9}
\label{sec:org28a3f01}
Quiz 9 will focus on Bloch's Chooser example. There is a lot going on in this example. Not only does it illustrate many of the points Bloch makes about generics, but it is also a good place to apply what we learned in Liskov about analyzing data types. Note that \texttt{Chooser} is very similar to Liskov's \texttt{IntSet} class.

\subsection{Guide 10}
\label{sec:orgcc316de}
Quiz 10 will focus on the Bloch's treatment of \texttt{Object} class methods.

In particular, you should be able to identify defective implementations of \texttt{equals()}, \texttt{hashCode()}, and \texttt{clone()}, explain what's wrong, and repair appropriately. The assessments will be based on the examples we study in class.

\subsection{Guide 11}
\label{sec:orgb293768}
Quiz 11 will focus on the Bloch Chapter 4 with special emphasis on Item 17: Minimize mutability and Item 18: Favor composition over inheritance. In particular, you should be prepared to apply Bloch's rules for making a class immutable to a simple example and you should understand the various aspects of Bloch's InstrumentedSet example (code on page 90).


\subsection{Guide 12}
\label{sec:org822f6d8}
Quiz 12 will focus on the contract model in JUnit theories. The specific examples will be variations from In-Class 11.

\section{Reflection}
\label{sec:org7c316ef}

For each of the following, answer these two questions first:
\begin{enumerate}
\item List the names of students in your group.
\item Did everyone in your group contribute to the discussion of your solutions to this reading quiz? If not, who did not?
\end{enumerate}

\subsection{Reflection 1}
\label{sec:org9754d14}
\begin{enumerate}
\item Much of the material explores the connection between preconditions and exception handling. Were there any aspects of this connection that surprised or confused anyone in your group? If so, explain. If not, where did you learn this material?
\item Liskov and Bloch have different advice with respect to checked vs. unchecked exceptions. Which approach do you find more persuasive, and why?
\item Preconditions are often characterized as "bad" from a security perspective. If you think you know why this is, please explain. If you are unsure, say so and try to explain why the you find the connection between preconditions and security confusing.
\end{enumerate}


\subsection{Reflection 2}
\label{sec:orga3b729a}

\begin{enumerate}
\item If you sat down to design a new class, would the result likely be mutable or immutable? Why?
\item In her presentation, Liskov doesn't cover all the requirements for immutability. (In fairness, these requirements weren't well understood at the time she wrote her text.) Do you know what she's missing and why it's important? If so, briefly explain. (We'll cover those requirements later in the semester.)
\item Based on your experience, what do you think the major advantage is of immutability over mutability? mutability over immutability?
\end{enumerate}



\subsection{Reflection 3}
\label{sec:org76c7aca}
\begin{enumerate}
\item Have you ever explicitly considered invariants when deciding how to implement a Java class? If so, can you give an example?
\item Please explain what you think it means to to correctly override the toString() method. Base your answer on your understanding \textbf{before} enrolling in SWE 619.
\item How do you decide whether you have implemented a Java method correctly? Again, base your answer on your understanding \textbf{before} enrolling in SWE 619.
\end{enumerate}


\subsection{Reflection 4}
\label{sec:orgf138d1a}
\begin{enumerate}
\item Iteration is a basic concept, yet Liskov devotes an entire chapter to it. What, if anything, did you find in Liskov's presentation of iteration abstraction that is new to you?
\item Bloch's \texttt{Period} class (Item 50) has a lot going on in it. We'll revisit the this example in an in-class exercise. What, if anything, did you find confusing in this example?
\end{enumerate}


\subsection{Reflection 5}
\label{sec:org7faba0e}

\begin{enumerate}
\item Liskov 7 develops rules for assessing the correctness of subtypes. What do you think the connection is between these rules and the rules for verification addressed in Chapter 5?
\end{enumerate}

\begin{enumerate}
\item Consider the Java Set interface and two subtypes: HashSet and TreeSet. Do you think the abstract state for these three interfaces/classes are identical or different? (You might want to spend some time in the JavaDoc before jumping to a conclusion; there is a specific answer in there!)
\end{enumerate}



\subsection{Reflection 6}
\label{sec:org9e30842}

\begin{enumerate}
\item Can you explain why Java has both a Comparable interface and a Comparator interface?
\item How familiar is your group with the Java "anonymous class" and "lambda" constructs?
\item Can you explain the connection between anonymous classes and lambda expressions?
\end{enumerate}



\subsection{Reflection 7}
\label{sec:org9010b55}


\begin{enumerate}
\item Can you explain the basic role of generics in the Java language?
\item Do you have experience generifying Java classes? Explain.
\item Bloch explains how bounded wildcards can address certain limitations in the use of generics in inheritance settings. If you can, give a brief description of how this works. (If not, that's fine; we'll address in class.)
\end{enumerate}


\subsection{Reflection 8}
\label{sec:org5e72093}


\begin{enumerate}
\item Have you overridden the equals() or the hashCode() methods? In light of Bloch's discussion of both methods, do you think your implementations were correct?
\item Have you overridden the clone() method? Do you understand why inheritance is a particular concern for overridding this method?
\item What similarities and differences do you see between how Liskov and Bloch treat the toString() method?
\end{enumerate}


\subsection{Reflection 9}
\label{sec:orgf98c7fc}

\begin{enumerate}
\item What is your comfort level with "regular" logic? What aspect of using logic do you find most challenging?
\item Do you have any experience learning and/or using temporal logic?
\item How familiar/comfortable are you with finite state machines?
\end{enumerate}



\subsection{Reflection 10}
\label{sec:orgc347855}

\begin{enumerate}
\item Bloch discusses specific rules for making a class immutable. Did you find any of these rules confusing?
\item Bloch's InstrumentedHashSet example demonstrates how inheritance can break encapsulation. Does the JavaDoc for HashSet, Set and/or Collection follow the Bloch's Item 19 advice for documenting for inheritances?
\item Bloch's InstrumentedSet example has a lot going on in it. What aspects, if any, of this example did you find confusing?
\end{enumerate}



\subsection{Reflection 11}
\label{sec:org395c997}


\begin{enumerate}
\item How would you rate your experience with writing (ordinary) tests in the JUnit framework? Use a scale from "A few times for class" to "I do that professionally".
\item JUnit theories are the JUnit implementation of "property-based" testing. Have you every written a property-based test?
\item JUnit theories are included on the syllabus because they show how the precondition/postcondition model applies beyond method contracts. Does the pre/post model for JUnit theories make sense to you?
\end{enumerate}



\subsection{Reflection 12}
\label{sec:orgac212d2}


\begin{enumerate}
\item Is there anything about property based testing that you still find confusing?
\item Have you ever used a "C style" enum? If so, at the time, did this seem reasonable or ridiculous?
\item This week's in-class exercise is a recap. Is there a topic (or two) we've covered that you think you need more practice with?
\end{enumerate}

\section{Files}
\label{sec:org9c46194}
\begin{itemize}
\item \href{./files/LiskovSet.java}{LiskovSet.java}
\item \href{./files/Poly.java}{Poly.java}
\end{itemize}


\section{Links}
\label{sec:orgc206b1d}
\begin{itemize}
\item \href{./index.html}{Syllabus}
\item \href{./schedule.html}{Schedule}
\end{itemize}
\end{document}
